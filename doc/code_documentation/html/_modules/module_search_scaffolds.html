
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>module_search_scaffolds &#8212; amoebae 0.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for module_search_scaffolds</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright 2018 Lael D. Barlow</span>
<span class="c1"># </span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1"># </span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># </span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># </span>
<span class="sd">&quot;&quot;&quot;Contains functions used in search_scaffolds.py.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">SeqIO</span>
<span class="c1">#from Bio import SearchIO</span>
<span class="c1"># Import SearchIO and suppress experimental warning</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">BiopythonExperimentalWarning</span>
<span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">BiopythonExperimentalWarning</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">SearchIO</span>

<span class="kn">from</span> <span class="nn">Bio.Blast</span> <span class="k">import</span> <span class="n">NCBIXML</span>
<span class="kn">from</span> <span class="nn">Bio.Blast</span> <span class="k">import</span> <span class="n">Record</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="k">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="k">import</span> <span class="n">SeqRecord</span>
<span class="kn">import</span> <span class="nn">itertools</span>


<div class="viewcode-block" id="check_if_two_hsp_ranges_overlap"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.check_if_two_hsp_ranges_overlap">[docs]</a><span class="k">def</span> <span class="nf">check_if_two_hsp_ranges_overlap</span><span class="p">(</span><span class="n">lists</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes two lists which contain the start and stop positions of two HSPs,</span>
<span class="sd">    and returns True if they overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">intersect</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">overlap</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">intersect</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">overlap</span></div>


<div class="viewcode-block" id="check_if_two_hsps_overlap"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.check_if_two_hsps_overlap">[docs]</a><span class="k">def</span> <span class="nf">check_if_two_hsps_overlap</span><span class="p">(</span><span class="n">hsp_obj1</span><span class="p">,</span> <span class="n">hsp_obj2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes two HSP objects and returns True if their ranges overlap, and</span>
<span class="sd">    False if not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">hsp_obj1</span><span class="o">.</span><span class="n">hit_range</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">hsp_obj2</span><span class="o">.</span><span class="n">hit_range</span>

    <span class="n">overlap</span> <span class="o">=</span> <span class="n">check_if_two_hsp_ranges_overlap</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">overlap</span></div>


<div class="viewcode-block" id="check_if_hsps_overlapping"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.check_if_hsps_overlapping">[docs]</a><span class="k">def</span> <span class="nf">check_if_hsps_overlapping</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a list of HSP objects, and returns true if they overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compile a list of the ranges.</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_range</span>
        <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    
    <span class="c1"># Generate list of all possible combinations of two ranges.</span>
    <span class="n">combos</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Loop over combinations and check for overlap.</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">combos</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">combo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">combo</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">intersect</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intersect</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">overlap</span></div>


<div class="viewcode-block" id="check_strands"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.check_strands">[docs]</a><span class="k">def</span> <span class="nf">check_strands</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">,</span> <span class="n">fwd_strand</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if hsps in the list are not all on the same strand.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hsps_on_different_strands</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_frame</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">fwd_strand</span><span class="p">:</span>
            <span class="n">hsps_on_different_strands</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">hsps_on_different_strands</span></div>


<div class="viewcode-block" id="whether_fwd_strand"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.whether_fwd_strand">[docs]</a><span class="k">def</span> <span class="nf">whether_fwd_strand</span><span class="p">(</span><span class="n">hsp</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_frame</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="check_for_duplicate_ranges"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.check_for_duplicate_ranges">[docs]</a><span class="k">def</span> <span class="nf">check_for_duplicate_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if the given list of tuples contains duplicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">non_redun_range_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">range_list</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_redun_range_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_list</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="sort_left_ranges"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.sort_left_ranges">[docs]</a><span class="k">def</span> <span class="nf">sort_left_ranges</span><span class="p">(</span><span class="n">left_ranges</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">left_ranges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span></div>


<div class="viewcode-block" id="reduce_left_ranges"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.reduce_left_ranges">[docs]</a><span class="k">def</span> <span class="nf">reduce_left_ranges</span><span class="p">(</span><span class="n">sorted_left_ranges</span><span class="p">,</span> <span class="n">top_hsp_range</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="c1"># Reduce the list of left ranges to only those that meet the criteria.</span>
    <span class="n">reduced_left_ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">last_range</span> <span class="o">=</span> <span class="n">top_hsp_range</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">sorted_left_ranges</span><span class="p">:</span>
        <span class="c1"># Only include range if it ends before last range starts and</span>
        <span class="c1"># within max_gap.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">last_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_gap</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">last_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">reduced_left_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">last_range</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">reduced_left_ranges</span></div>
    

<div class="viewcode-block" id="sort_right_ranges"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.sort_right_ranges">[docs]</a><span class="k">def</span> <span class="nf">sort_right_ranges</span><span class="p">(</span><span class="n">right_ranges</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">right_ranges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="reduce_right_ranges"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.reduce_right_ranges">[docs]</a><span class="k">def</span> <span class="nf">reduce_right_ranges</span><span class="p">(</span><span class="n">sorted_right_ranges</span><span class="p">,</span> <span class="n">top_hsp_range</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="c1"># Reduce the list of right ranges to only those that meet the criteria.</span>
    <span class="n">reduced_right_ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">last_range</span> <span class="o">=</span> <span class="n">top_hsp_range</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">sorted_right_ranges</span><span class="p">:</span>
        <span class="c1"># Only include range if it starts after last range ends, and within max_gap.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">last_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">max_gap</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">last_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">reduced_right_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">last_range</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">return</span> <span class="n">reduced_right_ranges</span></div>


<div class="viewcode-block" id="get_proximate_hsp_ranges"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_proximate_hsp_ranges">[docs]</a><span class="k">def</span> <span class="nf">get_proximate_hsp_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">,</span> <span class="n">top_hsp_range</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a list of ranges and returns another list, but corresponding to</span>
<span class="sd">    the top HSP and proximate HSPs that do not overlap.</span>

<span class="sd">    Potential problem: Does not take into account the E-value of overlapping</span>
<span class="sd">    HPSs, and may exclude some HSPs with better E-values because of their</span>
<span class="sd">    position. It would perhaps be better to take E-values into account?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compile a list of proximate HSP ranges upstream (left regardless of which</span>
    <span class="c1"># way 5&#39; or 3&#39; is) of the range for the top HSP.</span>
    <span class="n">left_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">range_list</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">top_hsp_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="n">reduced_left_ranges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_ranges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Sort the ranges in descending order of their higher value.</span>
        <span class="n">sorted_left_ranges</span> <span class="o">=</span> <span class="n">sort_left_ranges</span><span class="p">(</span><span class="n">left_ranges</span><span class="p">)</span>

        <span class="c1"># Reduce the list of left ranges to only those that meet the criteria.</span>
        <span class="n">reduced_left_ranges</span> <span class="o">=</span> <span class="n">reduce_left_ranges</span><span class="p">(</span><span class="n">sorted_left_ranges</span><span class="p">,</span> <span class="n">top_hsp_range</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span>

    <span class="c1"># Compile a list of proximate HSPs downstream (right regardless of which</span>
    <span class="c1"># way 5&#39; or 3&#39; is) of top HSP.</span>
    <span class="n">right_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">range_list</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">top_hsp_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">reduced_right_ranges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_ranges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Sort the ranges in ascending order of their lower value.</span>
        <span class="n">sorted_right_ranges</span> <span class="o">=</span> <span class="n">sort_right_ranges</span><span class="p">(</span><span class="n">right_ranges</span><span class="p">)</span>

        <span class="c1"># Reduce the list of right ranges to only those that meet the criteria.</span>
        <span class="n">reduced_right_ranges</span> <span class="o">=</span> <span class="n">reduce_right_ranges</span><span class="p">(</span><span class="n">sorted_right_ranges</span><span class="p">,</span>
                <span class="n">top_hsp_range</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span>

    <span class="c1"># Concatenate left, top, and right range lists to make the final list.</span>
    <span class="n">final_proximate_ranges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reduced_left_ranges</span><span class="p">))</span>\
                             <span class="o">+</span> <span class="p">[</span><span class="n">top_hsp_range</span><span class="p">]</span>\
                             <span class="o">+</span> <span class="n">reduced_right_ranges</span>

    <span class="c1"># Compile list of ranges that fall within the range of HSPs in the final</span>
    <span class="c1"># list, but were not included because they overlap with higher ranking hsps</span>
    <span class="c1"># in the final list. </span>
    <span class="n">leftover_proximate_ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">range_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">final_proximate_ranges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fpr</span> <span class="ow">in</span> <span class="n">final_proximate_ranges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">check_if_two_hsp_ranges_overlap</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">fpr</span><span class="p">]):</span>
                    <span class="n">leftover_proximate_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># Return the final list of ranges.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">final_proximate_ranges</span><span class="p">,</span> <span class="n">leftover_proximate_ranges</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="remove_hsps_with_redun_ranges"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.remove_hsps_with_redun_ranges">[docs]</a><span class="k">def</span> <span class="nf">remove_hsps_with_redun_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">,</span> <span class="n">hsp_objs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove HSPs with redundant ranges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">non_redun_hsps</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Get list of ranges of which there are duplicates.</span>
    <span class="n">duplicate_ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">range_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">range_list</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">duplicate_ranges</span><span class="p">:</span>
            <span class="n">duplicate_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># Get corresponding list of HSP objects.</span>
    <span class="n">hsps_with_duplicate_ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">duplicate_ranges</span><span class="p">:</span>
        <span class="n">hsp_sublist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">hsp_sublist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">hsps_with_duplicate_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp_sublist</span><span class="p">)</span>

    <span class="c1"># For each list of HSPs with identical ranges, identify top HSP.</span>
    <span class="n">top_hsps_from_sublists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp_sublist</span> <span class="ow">in</span> <span class="n">hsps_with_duplicate_ranges</span><span class="p">:</span>
        <span class="n">top_hsp_in_sublist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hsp_sublist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">evalue</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">top_hsps_from_sublists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_hsp_in_sublist</span><span class="p">)</span>

    <span class="c1"># Remove the duplicate HSPs from the complete list.</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
        <span class="c1"># If range is in the duplicate ranges, only append if it is the top</span>
        <span class="c1"># HSP.</span>
        <span class="n">append</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">hit_range</span> <span class="ow">in</span> <span class="n">duplicate_ranges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">top_hsps_from_sublists</span><span class="p">:</span>
                <span class="n">append</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">append</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="n">non_redun_hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">non_redun_hsps</span></div>


<div class="viewcode-block" id="reduce_to_best_hsps"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.reduce_to_best_hsps">[docs]</a><span class="k">def</span> <span class="nf">reduce_to_best_hsps</span><span class="p">(</span><span class="n">sorted_hsps</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">,</span> <span class="n">recursion_num</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">leftright</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursively select HSPs upstream of the top HSP for inclusion in the</span>
<span class="sd">    cluster.</span>

<span class="sd">    Note: This function may be inefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">## Check that no HSPs with identical hit_ranges exist in the input list.</span>
    <span class="c1">#for hsp1 in sorted_hsps:</span>
    <span class="c1">#    for hsp2 in sorted_hsps:</span>
    <span class="c1">#        if not hsp1 == hsp2:</span>
    <span class="c1">#            assert hsp1.hit_range != hsp2.hit_range, &quot;&quot;&quot;HSPs with identical</span>
    <span class="c1">#            hit ranges exist in input hsp list.&quot;&quot;&quot;</span>
    
    <span class="c1">## Display.</span>
    <span class="c1">#print(&#39;\nHSPs input to reduce_to_best_hsps R&#39; + str(recursion_num) + &#39; &#39; +\</span>
    <span class="c1">#name + &#39;:&#39;)</span>
    <span class="c1">#print(&#39;Complete list:&#39;)</span>
    <span class="c1">#for hsp in sorted_hsps:</span>
    <span class="c1">#    print(hsp.hit_range)</span>
    <span class="c1">#print(&#39;\n&#39;)</span>

    <span class="n">reduced_sorted_hsps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">discard_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Iterate over the HSPs in the input list, and find up to one HSP to remove.</span>
    <span class="n">hsp_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">sorted_hsps</span><span class="p">:</span> 
        <span class="n">hsp_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_hsp</span> <span class="o">=</span> <span class="n">sorted_hsps</span><span class="p">[</span><span class="n">hsp_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_hsps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hsp_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Consider the most proximal hsp to the first hsp.</span>
            <span class="n">next_hsp</span> <span class="o">=</span> <span class="n">sorted_hsps</span><span class="p">[</span><span class="n">hsp_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            
            <span class="c1"># If the next hsp does not represent an appropriate upstream or</span>
            <span class="c1"># downstream portion of the query sequence (depending on whether on</span>
            <span class="c1"># the plus or minus strand, upstream or downstream of top hsp),</span>
            <span class="c1"># then discard it.</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">current_hsp</span><span class="o">.</span><span class="n">hit_frame</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># On plus strand.</span>
                <span class="c1">#print(&#39;on plus strand&#39;)</span>
                <span class="k">if</span> <span class="n">leftright</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                    <span class="c1">#print(&#39;going left&#39;)</span>
                    <span class="c1"># Subsequent HSPs should be upstream of the current HSP.</span>
                    <span class="n">stream</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print(&#39;going right&#39;)</span>
                    <span class="c1"># Subsequent HSPs should be downstream of the current HSP.</span>
                    <span class="n">stream</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span>
            <span class="k">elif</span> <span class="n">current_hsp</span><span class="o">.</span><span class="n">hit_frame</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># On minus strand.</span>
                <span class="c1">#print(&#39;on minus strand&#39;)</span>
                <span class="k">if</span> <span class="n">leftright</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                    <span class="c1">#print(&#39;going left&#39;)</span>
                    <span class="c1"># Subsequent HSPs should be downstream of the current HSP.</span>
                    <span class="n">stream</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print(&#39;going right&#39;)</span>
                    <span class="c1"># Subsequent HSPs should be upstream of the current HSP.</span>
                    <span class="n">stream</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span>
            <span class="c1"># Check whether next hsp is appropriately upstream or downstream in</span>
            <span class="c1"># terms of its query range.</span>
            <span class="k">if</span> <span class="n">stream</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
                <span class="c1"># Compare the end positions of the HSPs in the query sequence</span>
                <span class="c1"># as an indication of whether they are in an appropriate order.</span>
                <span class="k">if</span> <span class="n">next_hsp</span><span class="o">.</span><span class="n">query_end</span> <span class="o">&gt;=</span> <span class="n">current_hsp</span><span class="o">.</span><span class="n">query_end</span><span class="p">:</span>
                    <span class="c1"># Then not upstream as it should be.</span>
                    <span class="n">discard_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_hsp</span><span class="p">)</span>
                    <span class="c1"># Break the loop so that the HSP can be removed before</span>
                    <span class="c1"># proceeding with the next recursion.</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

                    <span class="c1"># TEMPORARY</span>
                    <span class="c1">#assert not next_hsp.hit_start == 8467356</span>
                    <span class="c1">#assert not next_hsp.hit_start == 8466585</span>
                    <span class="c1">#assert current_hsp.hit_start != 8466585 or\</span>
                    <span class="c1">#next_hsp.hit_start != 8467356</span>
                    <span class="c1">#assert current_hsp.hit_start != 8467356 or\</span>
                    <span class="c1">#next_hsp.hit_start != 8466585</span>

            <span class="k">elif</span> <span class="n">stream</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
                <span class="c1"># Compare the start positions of the HSPs in the query sequence</span>
                <span class="c1"># as an indication of whether they are in an appropriate order.</span>
                <span class="k">if</span> <span class="n">next_hsp</span><span class="o">.</span><span class="n">query_start</span> <span class="o">&lt;=</span> <span class="n">current_hsp</span><span class="o">.</span><span class="n">query_start</span><span class="p">:</span>
                    <span class="c1"># Then not downstream as it should be.</span>
                    <span class="n">discard_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_hsp</span><span class="p">)</span>
                    <span class="c1"># Break the loop so that the HSP can be removed before</span>
                    <span class="c1"># proceeding with the next recursion.</span>
                    <span class="k">break</span>

                    <span class="c1"># TEMPORARY</span>
                    <span class="c1">#print(&#39;\n&#39;)</span>
                    <span class="c1">#print(current_hsp.hit_range)</span>
                    <span class="c1">#print(&#39;current_hsp.query_start: &#39; + str(current_hsp.query_start))</span>
                    <span class="c1">#print(next_hsp.hit_range)</span>
                    <span class="c1">#print(&#39;next_hsp.query_start: &#39; + str(next_hsp.query_start))</span>
                    <span class="c1">#assert not next_hsp.hit_start == 8467356</span>
                    <span class="c1">#assert not next_hsp.hit_start == 8466585</span>
                    <span class="c1">#assert current_hsp.hit_start != 8466585 or\</span>
                    <span class="c1">#next_hsp.hit_start != 8467356</span>
                    <span class="c1">#assert current_hsp.hit_start != 8467356 or\</span>
                    <span class="c1">#next_hsp.hit_start != 8466585</span>



            <span class="c1"># If the first hsp overlaps with the next hsp, then keep the hsp that</span>
            <span class="c1"># has the better E-value.</span>
            <span class="k">if</span> <span class="n">check_if_two_hsps_overlap</span><span class="p">(</span><span class="n">next_hsp</span><span class="p">,</span> <span class="n">current_hsp</span><span class="p">):</span>
                <span class="c1">## Display.</span>
                <span class="c1">#print(str(current_hsp.hit_range) + &#39; overlaps with &#39; +\</span>
                <span class="c1">#        str(next_hsp.hit_range))</span>

                <span class="k">if</span> <span class="n">next_hsp</span><span class="o">.</span><span class="n">evalue</span> <span class="o">&lt;</span> <span class="n">current_hsp</span><span class="o">.</span><span class="n">evalue</span><span class="p">:</span>
                    <span class="n">discard_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_hsp</span><span class="p">)</span>

                    <span class="c1">## Display.</span>
                    <span class="c1">#print(str(next_hsp.hit_range) + &#39; &#39; + str(next_hsp.evalue) +\</span>
                    <span class="c1">#&#39; &lt; &#39; + str(current_hsp.hit_range) + &#39; &#39; +\</span>
                    <span class="c1">#str(current_hsp.evalue)) </span>
                    <span class="c1">#print(&#39;so discarding &#39; + str(current_hsp.hit_range))</span>

                <span class="k">elif</span> <span class="n">next_hsp</span><span class="o">.</span><span class="n">evalue</span> <span class="o">==</span> <span class="n">current_hsp</span><span class="o">.</span><span class="n">evalue</span><span class="p">:</span>
                    <span class="c1"># Use bitscore to break the tie.</span>
                    <span class="k">if</span> <span class="n">next_hsp</span><span class="o">.</span><span class="n">bitscore</span> <span class="o">&gt;</span> <span class="n">current_hsp</span><span class="o">.</span><span class="n">bitscore</span><span class="p">:</span>
                        <span class="n">discard_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_hsp</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">discard_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_hsp</span><span class="p">)</span>
                        <span class="c1"># TEMPORARY</span>
                        <span class="c1">#assert not next_hsp.hit_start == 8467356</span>
                        <span class="c1">#assert not next_hsp.hit_start == 8466585</span>
                        <span class="c1">#assert current_hsp.hit_start != 8466585 or\</span>
                        <span class="c1">#next_hsp.hit_start != 8467356</span>
                        <span class="c1">#assert current_hsp.hit_start != 8467356 or\</span>
                        <span class="c1">#next_hsp.hit_start != 8466585</span>

                    <span class="c1">#assert next_hsp.bitscore != current_hsp.bitscore,\</span>
                    <span class="c1">#&quot;&quot;&quot;Houston, we have a problem: Which HSP to keep?.&quot;&quot;&quot;</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The current HSP has the better E-value, so discard the</span>
                    <span class="c1"># other one.</span>
                    <span class="n">discard_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_hsp</span><span class="p">)</span>

                    <span class="c1"># TEMPORARY</span>
                    <span class="c1">#assert not next_hsp.hit_start == 8467356</span>
                    <span class="c1">#assert not next_hsp.hit_start == 8466585</span>
                    <span class="c1">#assert current_hsp.hit_start != 8466585 or\</span>
                    <span class="c1">#next_hsp.hit_start != 8467356</span>
                    <span class="c1">#assert current_hsp.hit_start != 8467356 or\</span>
                    <span class="c1">#next_hsp.hit_start != 8466585</span>

                    <span class="c1">## Display.</span>
                    <span class="c1">#if next_hsp.query_range == (274,341):</span>
                    <span class="c1">#    print(&#39;YYYYYYYYYYY&#39;)</span>
                    <span class="c1">#print(str(next_hsp.hit_range) + &#39; &#39; + str(next_hsp.evalue) +\</span>
                    <span class="c1">#&#39; &gt; &#39; + str(current_hsp.hit_range) + &#39; &#39; +\</span>
                    <span class="c1">#str(current_hsp.evalue)) </span>
                    <span class="c1">#print(&#39;so discarding &#39; + str(next_hsp.hit_range))</span>

                <span class="c1"># Break the loop so that the HSP can be removed before</span>
                <span class="c1"># proceeding with the next recursion.</span>
                <span class="k">break</span>
            <span class="c1"># If they do not overlap, then keep both, and move onto the next</span>
            <span class="c1"># HSP in the input list, unless the next HSP is too far away from</span>
            <span class="c1"># the current HSP.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check that the next HSP is within max_gap of the current</span>
                <span class="c1"># HSP. If not, then discard it and all remaining HSPs that are</span>
                <span class="c1"># even further.</span>

                <span class="c1">## Display.</span>
                <span class="c1">#print(str(current_hsp.hit_range) + &#39; does not overlap with &#39; +\</span>
                <span class="c1">#        str(next_hsp.hit_range))</span>

                <span class="n">gap_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">current_hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">next_hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="nb">abs</span><span class="p">(</span><span class="n">next_hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                           <span class="p">]</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">gap_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_gap</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_hsps</span><span class="p">[</span><span class="n">hsp_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">discard_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> 

                    <span class="c1">## Display.</span>
                    <span class="c1">#print(str(next_hsp.hit_range) + &#39; is not within &#39; +\</span>
                    <span class="c1">#str(max_gap) + &#39; bp of &#39; + str(current_hsp.hit_range)\</span>
                    <span class="c1">#+ &#39; so removing &#39; + str(next_hsp.hit_range) +\</span>
                    <span class="c1">#&#39; and all further HSPs.&#39;)</span>

                    <span class="c1"># Break the loop so that the HSP can be removed before</span>
                    <span class="c1"># proceeding with the next recursion.</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">## Display.</span>
                    <span class="c1">#print(str(next_hsp.hit_range) + &#39; is within &#39; +\</span>
                    <span class="c1">#str(max_gap) + &#39; bp of &#39; + str(current_hsp.hit_range)\</span>
                    <span class="c1">#+ &#39; so keeping &#39; + str(next_hsp.hit_range))</span>

                    <span class="k">pass</span>

    <span class="c1">## Display.</span>
    <span class="c1">#for hsp in discard_list:</span>
    <span class="c1">#    print(&#39;\tremoved &#39; + str(hsp.hit_range))</span>


    <span class="c1"># If there are no more HSPs to remove, then return the list. </span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">discard_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">## Display.</span>
        <span class="c1">#print(&#39;No more HSPs to remove.&#39;)</span>

        <span class="k">return</span> <span class="n">sorted_hsps</span> 

    <span class="c1"># Otherwise, remove the HSPs and do another recursion with the reduced</span>
    <span class="c1"># list.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Generate a reduced list of HSPs.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_hsps</span><span class="p">:</span>
            <span class="n">append</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">discard_list</span><span class="p">:</span>
                <span class="c1"># Note: Sometimes different HSPs have identical hit ranges.</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">hit_range</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">query_range</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">query_range</span><span class="p">:</span>
                    <span class="n">append</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
                <span class="n">reduced_sorted_hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># Do another recursion on the reduced list.</span>
        <span class="k">return</span> <span class="n">reduce_to_best_hsps</span><span class="p">(</span><span class="n">reduced_sorted_hsps</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">,</span> <span class="n">recursion_num</span>\
                <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">leftright</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_missed_hsp_ranges"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.find_missed_hsp_ranges">[docs]</a><span class="k">def</span> <span class="nf">find_missed_hsp_ranges</span><span class="p">(</span><span class="n">complete_ranges</span><span class="p">,</span>
                     <span class="n">final_proximate_ranges</span><span class="p">,</span>
                     <span class="n">leftover_proximate_ranges</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Testable function to test for problems.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">missed_hsps</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">complete_ranges</span><span class="p">:</span>
        <span class="n">total_prox</span> <span class="o">=</span> <span class="n">final_proximate_ranges</span> <span class="o">+</span> <span class="n">leftover_proximate_ranges</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">total_prox</span><span class="p">:</span>
            <span class="n">rset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">total_prox</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">total_prox</span><span class="p">])))</span> 
            <span class="n">rset2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">final_proximate_ranges</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">final_proximate_ranges</span><span class="p">])))</span> 
            <span class="c1">#if r[0] in rset or r[1] in rset:</span>
            <span class="n">in_range</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rset2</span><span class="p">:</span>
                    <span class="n">in_range</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">in_range</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;missed hsp&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">missed_hsps</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">missed_hsps</span></div>


<span class="c1"># Obsolete function:</span>
<div class="viewcode-block" id="get_best_proximate_hsps"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_best_proximate_hsps">[docs]</a><span class="k">def</span> <span class="nf">get_best_proximate_hsps</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">,</span> <span class="n">top_hsp</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of HSP objects that are sufficiently proximate to the top</span>
<span class="sd">    HSP, and among which there is no overlap in the sequence ranges. And, also</span>
<span class="sd">    return a list of HSP objects that are also proximate to these HSPs, but</span>
<span class="sd">    were not included in the final list of HSPs because they overlap with the</span>
<span class="sd">    ones that were. Instead of simply selecting HSPs based on hit range,</span>
<span class="sd">    consider E-values, favoring HSPs with better E-values if HSPs overlap and</span>
<span class="sd">    some have to be excluded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compile a list of proximate HSPs upstream (left regardless of which</span>
    <span class="c1"># way 5&#39; or 3&#39; is) of the the top HSP.</span>
    <span class="n">left_hsps</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hsp_objs</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">top_hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c1"># Remove top HSP from list.</span>
    <span class="n">left_hsps</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">top_hsp</span><span class="p">)</span>

    <span class="n">reduced_left_hsps</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_hsps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Sort the hsps in descending order of their 3&#39; position.</span>
        <span class="n">sorted_left_hsps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">left_hsps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Reduce the list of left ranges to only those that meet the criteria.</span>
        <span class="n">reduced_left_hsps</span> <span class="o">=</span> <span class="n">reduce_to_best_hsps</span><span class="p">([</span><span class="n">top_hsp</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_left_hsps</span><span class="p">,</span>
                <span class="n">max_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Left&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_left_hsps</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">([</span><span class="n">top_hsp</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_left_hsps</span><span class="p">)</span>

    <span class="c1"># Compile a list of proximate HSPs downstream (right regardless of which</span>
    <span class="c1"># way 5&#39; or 3&#39; is) of top HSP.</span>
    <span class="n">right_hsps</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hsp_objs</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">top_hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="c1"># Remove top HSP from list.</span>
    <span class="n">right_hsps</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">top_hsp</span><span class="p">)</span>

    <span class="n">reduced_right_hsps</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_hsps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Sort the HSPs in ascending order of their 5&#39; position.</span>
        <span class="n">sorted_right_hsps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">right_hsps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Reduce the list of right HSPs to only those that meet the criteria.</span>
        <span class="n">reduced_right_hsps</span> <span class="o">=</span> <span class="n">reduce_to_best_hsps</span><span class="p">([</span><span class="n">top_hsp</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_right_hsps</span><span class="p">,</span>
                <span class="n">max_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Right&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_right_hsps</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">([</span><span class="n">top_hsp</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_right_hsps</span><span class="p">)</span>

    <span class="c1"># Check that all HSPs in the input list are accounted for in the left</span>
    <span class="c1"># and/or right lists.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_hsps</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_hsps</span><span class="p">)),</span> <span class="s2">&quot;&quot;&quot;Did not</span>
<span class="s2">    account for all HSPs in input list.&quot;&quot;&quot;</span>

    <span class="c1"># Concatenate left, top, and right HSP lists to make the final list.</span>
    <span class="n">final_proximate_hsps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reduced_left_hsps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>\
                             <span class="o">+</span> <span class="p">[</span><span class="n">top_hsp</span><span class="p">]</span>\
                             <span class="o">+</span> <span class="n">reduced_right_hsps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1">## Unnecessary???</span>
    <span class="c1">## Check that top hsp was included.</span>
    <span class="c1">#found = False</span>
    <span class="c1">#for hsp in final_proximate_hsps:</span>
    <span class="c1">#    if hsp.hit_range == top_hsp.hit_range:</span>
    <span class="c1">#        found = True</span>
    <span class="c1">#assert found</span>

    <span class="c1"># Compile list of HSPs that fall within the range of HSPs in the final</span>
    <span class="c1"># list, but were not included because they overlap with higher ranking HSPs</span>
    <span class="c1"># in the final list. </span>
    <span class="c1">#leftover_proximate_hsps = []</span>
    <span class="c1">#for h in hsp_objs:</span>
    <span class="c1">#    if h.hit_range not in [x.hit_range for x in final_proximate_hsps]:</span>
    <span class="c1">#        for fh in final_proximate_hsps:</span>
    <span class="c1">#            if check_if_two_hsps_overlap(h, fh): </span>
    <span class="c1">#                leftover_proximate_hsps.append(h)</span>
    <span class="c1">#                break</span>
    <span class="c1">#for h in hsp_objs:</span>
    <span class="c1">#    for fh in final_proximate_hsps:</span>
    <span class="c1">#        if h.hit_range != fh.hit_range or h.query_range != fh.query_range:</span>
    <span class="c1">#            if check_if_two_hsps_overlap(h, fh): </span>
    <span class="c1">#                leftover_proximate_hsps.append(h)</span>
    <span class="c1">#                break</span>

    <span class="n">leftover_proximate_hsps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cluster_range</span> <span class="o">=</span> <span class="n">get_cluster_range</span><span class="p">(</span><span class="n">final_proximate_hsps</span><span class="p">)</span>
    <span class="n">cluster_range_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">cluster_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_gap</span><span class="p">,</span> <span class="n">cluster_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">max_gap</span><span class="p">))</span>
    <span class="c1">#print(&#39;\ncluster_range&#39;)</span>
    <span class="c1">#print(cluster_range)</span>
    <span class="c1">#print(&#39;hsps in complete list&#39;)</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
        <span class="c1">#print(&#39;\t&#39; + str(h.hit_range))</span>
        <span class="c1"># Determine whether the HSP is in the list of proximate HSPs.</span>
        <span class="n">possible</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">fh</span> <span class="ow">in</span> <span class="n">final_proximate_hsps</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">fh</span><span class="o">.</span><span class="n">hit_range</span> <span class="ow">and</span> <span class="n">h</span><span class="o">.</span><span class="n">query_range</span> <span class="o">==</span> <span class="n">fh</span><span class="o">.</span><span class="n">query_range</span><span class="p">:</span>
                <span class="n">possible</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1">#print(&#39;\t\talready in proximate hsp list for cluster&#39;)</span>
                <span class="k">break</span>
        <span class="c1"># If not, then determine whether it is within the range of the</span>
        <span class="c1"># proximate HSPs.</span>
        <span class="k">if</span> <span class="n">possible</span><span class="p">:</span>
            <span class="c1"># If it is, then add it to the list of leftover HSPs.</span>
            <span class="c1">#if h.hit_start in cluster_range_set or h.hit_end in cluster_range_set: </span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hit_start</span><span class="p">,</span><span class="n">h</span><span class="o">.</span><span class="n">hit_end</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cluster_range_set</span><span class="p">:</span>
                    <span class="c1">#print(&#39;\t\tadded to leftover list for cluster&#39;)</span>
                    <span class="n">leftover_proximate_hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="k">break</span>

    <span class="c1">## Redundant.</span>
    <span class="c1">## Check that there are no HSPs in the list that are within the range of the</span>
    <span class="c1">## cluster that are not in either the final or leftover lists.</span>
    <span class="c1">#cluster_range = get_cluster_range(final_proximate_hsps)</span>
    <span class="c1">#for h in hsp_objs:</span>
    <span class="c1">#    if h.hit_range not in [x.hit_range for x in (final_proximate_hsps + leftover_proximate_hsps)]:</span>
    <span class="c1">#        r = range(cluster_range[0], cluster_range[1])</span>
    <span class="c1">#        in_range = False</span>
    <span class="c1">#        if h.hit_range[0] in r:</span>
    <span class="c1">#            in_range = True</span>
    <span class="c1">#        elif h.hit_range[1] in r:</span>
    <span class="c1">#            in_range = True</span>
    <span class="c1">#        assert not in_range, &quot;&quot;&quot;A HSP still falls</span>
    <span class="c1">#        within the range of identified proximate HSPs.&quot;&quot;&quot;</span>

    <span class="c1"># Check whether any HSPs that should have been identified and added</span>
    <span class="c1"># to the leftover_proximate_hsps list were missed.</span>
    <span class="n">complete_hsp_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">]</span>
    <span class="n">final_proximate_hsp_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">final_proximate_hsps</span><span class="p">]</span>
    <span class="n">leftover_proximate_hsp_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leftover_proximate_hsps</span><span class="p">]</span>
    <span class="n">missed</span> <span class="o">=</span> <span class="n">find_missed_hsp_ranges</span><span class="p">(</span><span class="n">complete_hsp_ranges</span><span class="p">,</span> <span class="n">final_proximate_hsp_ranges</span><span class="p">,</span><span class="n">leftover_proximate_hsp_ranges</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">missed</span>

    <span class="c1"># Return the final and leftover (excluded proximate) hsp lists.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">final_proximate_hsps</span><span class="p">,</span> <span class="n">leftover_proximate_hsps</span><span class="p">]</span> </div>

<span class="c1"># Obsolete function:</span>
<div class="viewcode-block" id="get_proximate_hsp_objs"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_proximate_hsp_objs">[docs]</a><span class="k">def</span> <span class="nf">get_proximate_hsp_objs</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">,</span> <span class="n">top_hsp</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of HSP objects that are sufficiently proximate to the top</span>
<span class="sd">    HSP, and among which there is no overlap in the sequence ranges. And, also</span>
<span class="sd">    return a list of HSP objects that are also proximate to these HSPs, but</span>
<span class="sd">    were not included in the final list of HSPs because they overlap with the</span>
<span class="sd">    ones that were.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define maximum gap length (bp) between consecutive HSPs upstream and</span>
    <span class="c1"># downstream of the top HSP.</span>
    <span class="n">max_gap</span> <span class="o">=</span> <span class="n">max_gap</span>

    <span class="c1"># Define the range for the top HSP.</span>
    <span class="n">top_hsp_range</span> <span class="o">=</span> <span class="n">top_hsp</span><span class="o">.</span><span class="n">hit_range</span>

    <span class="c1"># Get a list of hit ranges</span>
    <span class="n">range_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
        <span class="n">range_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hit_range</span><span class="p">)</span>

    <span class="c1"># Check whether any of the ranges are identical (and can therefore be used</span>
    <span class="c1"># to identify different HSPs).</span>
    <span class="n">has_duplicate_ranges</span> <span class="o">=</span> <span class="n">check_for_duplicate_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">has_duplicate_ranges</span><span class="p">:</span>
        <span class="c1"># Remove HSPs with redundant ranges.</span>
        <span class="n">non_redun_hsps</span> <span class="o">=</span> <span class="n">remove_hsps_with_redun_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">,</span> <span class="n">hsp_objs</span><span class="p">)</span>

        <span class="c1"># Get a list of hit ranges again.</span>
        <span class="n">range_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">non_redun_hsps</span><span class="p">:</span>
            <span class="n">range_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hit_range</span><span class="p">)</span>

        <span class="c1"># Check whether any of the ranges are identical again.</span>
        <span class="n">has_duplicate_ranges</span> <span class="o">=</span> <span class="n">check_for_duplicate_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">has_duplicate_ranges</span><span class="p">,</span> <span class="s2">&quot;Error: Some HSPs have identical ranges.&quot;</span>

    <span class="c1"># Get a list of ranges for HSPs proximate to the top HSP, and not</span>
    <span class="c1"># overlapping with each other. </span>
    <span class="n">phr</span> <span class="o">=</span> <span class="n">get_proximate_hsp_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">,</span>
                                   <span class="n">top_hsp_range</span><span class="p">,</span>
                                   <span class="n">max_gap</span><span class="p">)</span>
    <span class="n">proximate_hsp_ranges</span> <span class="o">=</span> <span class="n">phr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">leftover_proximate_hsp_ranges</span> <span class="o">=</span> <span class="n">phr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Generate a list of proximate HPS objects, and leftover HSP objects (those</span>
    <span class="c1"># that don&#39;t make it into the final list because they overylap with</span>
    <span class="c1"># higher-ranking hsps) from the list of their ranges.</span>
    <span class="n">final_proximate_hsps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">proximate_hsp_ranges</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">final_proximate_hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="n">leftover_proximate_hsps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">leftover_proximate_hsp_ranges</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">leftover_proximate_hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="c1"># Check whether the HSPs overlap. Unnecessary?</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="n">check_if_hsps_overlapping</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">)</span>

    <span class="c1">#num = 0</span>
    <span class="c1">#for h in final_proximate_hsps:</span>
    <span class="c1">#    num += 1</span>
    <span class="c1">#    #print(&#39;&gt;&#39; + str(h.hit_range[0]) + &#39; &#39; + str(h.hit_range[1]) + &#39;\n&#39; + str(h.hit.seq).replace(&#39;-&#39;, &#39;&#39;) + &#39;\n&#39;)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">final_proximate_hsps</span><span class="p">,</span> <span class="n">leftover_proximate_hsps</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_proximate_hsp_objs2"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_proximate_hsp_objs2">[docs]</a><span class="k">def</span> <span class="nf">get_proximate_hsp_objs2</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">,</span> <span class="n">top_hsp</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of HSP objects that are sufficiently proximate to the top</span>
<span class="sd">    HSP, and among which there is no overlap in the sequence ranges. And, also</span>
<span class="sd">    return a list of HSP objects that are also proximate to these HSPs, but</span>
<span class="sd">    were not included in the final list of HSPs because they overlap with the</span>
<span class="sd">    ones that were. Instead of simply selecting HSPs based on hit range,</span>
<span class="sd">    consider E-values, favoring HSPs with better E-values if HSPs overlap and</span>
<span class="sd">    some have to be excluded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define the range for the top HSP.</span>
    <span class="n">top_hsp_range</span> <span class="o">=</span> <span class="n">top_hsp</span><span class="o">.</span><span class="n">hit_range</span>

    <span class="c1"># Get a list of hit ranges</span>
    <span class="n">range_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
        <span class="n">range_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hit_range</span><span class="p">)</span>

    <span class="c1"># Check whether any of the ranges are identical (and can therefore be used</span>
    <span class="c1"># to identify different HSPs).</span>
    <span class="n">has_duplicate_ranges</span> <span class="o">=</span> <span class="n">check_for_duplicate_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">has_duplicate_ranges</span><span class="p">:</span>
        <span class="c1"># Remove HSPs with redundant ranges.</span>
        <span class="n">non_redun_hsps</span> <span class="o">=</span> <span class="n">remove_hsps_with_redun_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">,</span> <span class="n">hsp_objs</span><span class="p">)</span>

        <span class="c1"># Get a list of hit ranges again.</span>
        <span class="n">range_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">non_redun_hsps</span><span class="p">:</span>
            <span class="n">range_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hit_range</span><span class="p">)</span>

        <span class="c1"># Check whether any of the ranges are identical again.</span>
        <span class="n">has_duplicate_ranges</span> <span class="o">=</span> <span class="n">check_for_duplicate_ranges</span><span class="p">(</span><span class="n">range_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">has_duplicate_ranges</span><span class="p">,</span> <span class="s2">&quot;Error: Some HSPs have identical ranges.&quot;</span>

    <span class="c1">## Get a list of ranges for HSPs proximate to the top HSP, and not</span>
    <span class="c1">## overlapping with each other. </span>
    <span class="c1">#phr = get_proximate_hsp_ranges(range_list,</span>
    <span class="c1">#                               top_hsp_range,</span>
    <span class="c1">#                               max_gap)</span>
    <span class="c1">#proximate_hsp_ranges = phr[0]</span>
    <span class="c1">#leftover_proximate_hsp_ranges = phr[1]</span>

    <span class="c1">## Generate a list of proximate HPS objects, and leftover HSP objects (those</span>
    <span class="c1">## that don&#39;t make it into the final list because they overylap with</span>
    <span class="c1">## higher-ranking hsps) from the list of their ranges.</span>
    <span class="c1">#final_proximate_hsps = []</span>
    <span class="c1">#for r in proximate_hsp_ranges:</span>
    <span class="c1">#    for h in hsp_objs:</span>
    <span class="c1">#        if h.hit_range == r:</span>
    <span class="c1">#            final_proximate_hsps.append(h)</span>
    <span class="c1">#leftover_proximate_hsps = []</span>
    <span class="c1">#for r in leftover_proximate_hsp_ranges:</span>
    <span class="c1">#    for h in hsp_objs:</span>
    <span class="c1">#        if h.hit_range == r:</span>
    <span class="c1">#            leftover_proximate_hsps.append(h)</span>

    <span class="c1">## Get a list of HSPs proximate to the top HSP, and not</span>
    <span class="c1">## overlapping with each other. </span>
    <span class="c1">#bph = get_best_proximate_hsps(hsp_objs,</span>
    <span class="c1">#                              top_hsp,</span>
    <span class="c1">#                              max_gap)</span>
    <span class="c1">#final_proximate_hsps = bph[0]</span>
    <span class="c1">#leftover_proximate_hsps = bph[1]</span>

    <span class="c1">## Check whether the HSPs overlap. Unnecessary?</span>
    <span class="c1">#overlap = check_if_hsps_overlapping(hsp_objs)</span>

    <span class="c1">#return [final_proximate_hsps, leftover_proximate_hsps]</span>

    <span class="c1"># Compile a list of proximate HSPs upstream (left regardless of which</span>
    <span class="c1"># way 5&#39; or 3&#39; is) of the the top HSP.</span>
    <span class="n">left_hsps</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hsp_objs</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">top_hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c1"># Remove top HSP from list.</span>
    <span class="n">left_hsps</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">top_hsp</span><span class="p">)</span>

    <span class="n">reduced_left_hsps</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_hsps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Sort the hsps in descending order of their 3&#39; position.</span>
        <span class="n">sorted_left_hsps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">left_hsps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Reduce the list of left ranges to only those that meet the criteria.</span>
        <span class="n">reduced_left_hsps</span> <span class="o">=</span> <span class="n">reduce_to_best_hsps</span><span class="p">([</span><span class="n">top_hsp</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_left_hsps</span><span class="p">,</span>
                <span class="n">max_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Left&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_left_hsps</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">([</span><span class="n">top_hsp</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_left_hsps</span><span class="p">)</span>

    <span class="c1"># Compile a list of proximate HSPs downstream (right regardless of which</span>
    <span class="c1"># way 5&#39; or 3&#39; is) of top HSP.</span>
    <span class="n">right_hsps</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hsp_objs</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">top_hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="c1"># Remove top HSP from list.</span>
    <span class="n">right_hsps</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">top_hsp</span><span class="p">)</span>

    <span class="n">reduced_right_hsps</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_hsps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Sort the HSPs in ascending order of their 5&#39; position.</span>
        <span class="n">sorted_right_hsps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">right_hsps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Reduce the list of right HSPs to only those that meet the criteria.</span>
        <span class="n">reduced_right_hsps</span> <span class="o">=</span> <span class="n">reduce_to_best_hsps</span><span class="p">([</span><span class="n">top_hsp</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_right_hsps</span><span class="p">,</span>
                <span class="n">max_gap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Right&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_right_hsps</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">([</span><span class="n">top_hsp</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_right_hsps</span><span class="p">)</span>

    <span class="c1"># Check that all HSPs in the input list are accounted for in the left</span>
    <span class="c1"># and/or right lists.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_hsps</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_hsps</span><span class="p">)),</span> <span class="s2">&quot;&quot;&quot;Did not</span>
<span class="s2">    account for all HSPs in input list.&quot;&quot;&quot;</span>

    <span class="c1"># Concatenate left, top, and right HSP lists to make the final list.</span>
    <span class="n">final_proximate_hsps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">reduced_left_hsps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>\
                             <span class="o">+</span> <span class="p">[</span><span class="n">top_hsp</span><span class="p">]</span>\
                             <span class="o">+</span> <span class="n">reduced_right_hsps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1">## Unnecessary???</span>
    <span class="c1">## Check that top hsp was included.</span>
    <span class="c1">#found = False</span>
    <span class="c1">#for hsp in final_proximate_hsps:</span>
    <span class="c1">#    if hsp.hit_range == top_hsp.hit_range:</span>
    <span class="c1">#        found = True</span>
    <span class="c1">#assert found</span>

    <span class="c1"># Compile list of HSPs that fall within the range of HSPs in the final</span>
    <span class="c1"># list, but were not included because they overlap with higher ranking HSPs</span>
    <span class="c1"># in the final list. </span>
    <span class="c1">#leftover_proximate_hsps = []</span>
    <span class="c1">#for h in hsp_objs:</span>
    <span class="c1">#    if h.hit_range not in [x.hit_range for x in final_proximate_hsps]:</span>
    <span class="c1">#        for fh in final_proximate_hsps:</span>
    <span class="c1">#            if check_if_two_hsps_overlap(h, fh): </span>
    <span class="c1">#                leftover_proximate_hsps.append(h)</span>
    <span class="c1">#                break</span>
    <span class="c1">#for h in hsp_objs:</span>
    <span class="c1">#    for fh in final_proximate_hsps:</span>
    <span class="c1">#        if h.hit_range != fh.hit_range or h.query_range != fh.query_range:</span>
    <span class="c1">#            if check_if_two_hsps_overlap(h, fh): </span>
    <span class="c1">#                leftover_proximate_hsps.append(h)</span>
    <span class="c1">#                break</span>

    <span class="n">leftover_proximate_hsps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cluster_range</span> <span class="o">=</span> <span class="n">get_cluster_range</span><span class="p">(</span><span class="n">final_proximate_hsps</span><span class="p">)</span>
    <span class="n">cluster_range_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">cluster_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_gap</span><span class="p">,</span> <span class="n">cluster_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">max_gap</span><span class="p">))</span>
    <span class="c1">#print(&#39;\ncluster_range&#39;)</span>
    <span class="c1">#print(cluster_range)</span>
    <span class="c1">#print(&#39;hsps in complete list&#39;)</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
        <span class="c1">#print(&#39;\t&#39; + str(h.hit_range))</span>
        <span class="c1"># Determine whether the HSP is in the list of proximate HSPs.</span>
        <span class="n">possible</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">fh</span> <span class="ow">in</span> <span class="n">final_proximate_hsps</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">fh</span><span class="o">.</span><span class="n">hit_range</span> <span class="ow">and</span> <span class="n">h</span><span class="o">.</span><span class="n">query_range</span> <span class="o">==</span> <span class="n">fh</span><span class="o">.</span><span class="n">query_range</span><span class="p">:</span>
                <span class="n">possible</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1">#print(&#39;\t\talready in proximate hsp list for cluster&#39;)</span>
                <span class="k">break</span>
        <span class="c1"># If not, then determine whether it is within the range of the</span>
        <span class="c1"># proximate HSPs.</span>
        <span class="k">if</span> <span class="n">possible</span><span class="p">:</span>
            <span class="c1"># If it is, then add it to the list of leftover HSPs.</span>
            <span class="c1">#if h.hit_start in cluster_range_set or h.hit_end in cluster_range_set: </span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hit_start</span><span class="p">,</span><span class="n">h</span><span class="o">.</span><span class="n">hit_end</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cluster_range_set</span><span class="p">:</span>
                    <span class="c1">#print(&#39;\t\tadded to leftover list for cluster&#39;)</span>
                    <span class="n">leftover_proximate_hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="k">break</span>

    <span class="c1">## Redundant.</span>
    <span class="c1">## Check that there are no HSPs in the list that are within the range of the</span>
    <span class="c1">## cluster that are not in either the final or leftover lists.</span>
    <span class="c1">#cluster_range = get_cluster_range(final_proximate_hsps)</span>
    <span class="c1">#for h in hsp_objs:</span>
    <span class="c1">#    if h.hit_range not in [x.hit_range for x in (final_proximate_hsps + leftover_proximate_hsps)]:</span>
    <span class="c1">#        r = range(cluster_range[0], cluster_range[1])</span>
    <span class="c1">#        in_range = False</span>
    <span class="c1">#        if h.hit_range[0] in r:</span>
    <span class="c1">#            in_range = True</span>
    <span class="c1">#        elif h.hit_range[1] in r:</span>
    <span class="c1">#            in_range = True</span>
    <span class="c1">#        assert not in_range, &quot;&quot;&quot;A HSP still falls</span>
    <span class="c1">#        within the range of identified proximate HSPs.&quot;&quot;&quot;</span>

    <span class="c1"># Check whether any HSPs that should have been identified and added</span>
    <span class="c1"># to the leftover_proximate_hsps list were missed.</span>
    <span class="n">complete_hsp_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">]</span>
    <span class="n">final_proximate_hsp_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">final_proximate_hsps</span><span class="p">]</span>
    <span class="n">leftover_proximate_hsp_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leftover_proximate_hsps</span><span class="p">]</span>
    <span class="n">missed</span> <span class="o">=</span> <span class="n">find_missed_hsp_ranges</span><span class="p">(</span><span class="n">complete_hsp_ranges</span><span class="p">,</span> <span class="n">final_proximate_hsp_ranges</span><span class="p">,</span><span class="n">leftover_proximate_hsp_ranges</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">missed</span>

    <span class="c1"># Return the final and leftover (excluded proximate) hsp lists.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">final_proximate_hsps</span><span class="p">,</span> <span class="n">leftover_proximate_hsps</span><span class="p">]</span> </div>


<div class="viewcode-block" id="get_hit_seq_record_and_coord"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_hit_seq_record_and_coord">[docs]</a><span class="k">def</span> <span class="nf">get_hit_seq_record_and_coord</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">proximate_hsp_objs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of SearchIO HSP objects (arguably representing a single</span>
<span class="sd">    gene), return a Bio.Seq record composed of concatenated HSP sequences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get strand that the HSPs are on.</span>
    <span class="n">strand</span> <span class="o">=</span> <span class="n">get_strand_word</span><span class="p">(</span><span class="n">proximate_hsp_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hit_frame</span><span class="p">)</span>

    <span class="c1"># Concatenate the (translated peptide) hsp sequences in order from 5&#39; to 3&#39;</span>
    <span class="c1"># as they appear in the nucleotide subject sequence.</span>
    <span class="n">hit_sequence</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;plus&#39;</span><span class="p">:</span> 
        <span class="n">hit_sequence</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">hit</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;minus&#39;</span><span class="p">:</span> 
        <span class="c1"># Reverse the order of the HSPs.</span>
        <span class="n">hit_sequence</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">hit</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Make a description of where the hit sequence came from.</span>
    <span class="n">seq_origin</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;..&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
        <span class="o">+</span> <span class="s1">&#39;]&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">])</span>

    <span class="c1"># Define sequence coordinates as a list.</span>
    <span class="n">seq_coord</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>\
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">]</span>

    <span class="c1"># Generate a fasta sequence record.</span>
    <span class="n">hit_seq_record</span> <span class="o">=</span> <span class="n">SeqRecord</span><span class="p">(</span><span class="n">hit_sequence</span><span class="p">)</span>
    <span class="n">hit_seq_record</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span>
    <span class="n">descr_without_quotation_marks</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">hit_seq_record</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">descr_without_quotation_marks</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span>\
    <span class="n">strand</span> <span class="o">+</span> <span class="s1">&#39; strand &#39;</span> <span class="o">+</span> <span class="n">seq_origin</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">hit_seq_record</span><span class="p">,</span> <span class="n">seq_coord</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_hit_seq_obj"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_hit_seq_obj">[docs]</a><span class="k">def</span> <span class="nf">get_hit_seq_obj</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a SearchIO hit object (containing one or more HSPs) and returns a</span>
<span class="sd">    fasta sequence object likely to correspond to a single gene (the most</span>
<span class="sd">    similar gene to the query in the nucleotide subject sequence).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a list of HSP objects within the given hit object.</span>
    <span class="n">hsp_objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">:</span>
        <span class="n">hsp_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

    <span class="c1"># Determine whether the top HSP is on the forward or reverse strand.</span>
    <span class="n">top_hsp</span> <span class="o">=</span> <span class="n">hsp_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fwd_strand</span> <span class="o">=</span> <span class="n">whether_fwd_strand</span><span class="p">(</span><span class="n">top_hsp</span><span class="p">)</span> 

    <span class="c1"># Check that all the hsps are on the same strand.</span>
    <span class="n">hsps_on_different_strands</span> <span class="o">=</span> <span class="n">check_strands</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">,</span> <span class="n">fwd_strand</span><span class="p">)</span>

    <span class="c1"># If HSPs are on different strands, then make a reduced list of HSP objects</span>
    <span class="c1"># composed of only those that are on the same strand as the top HSP.</span>
    <span class="n">hsp_objs_red</span> <span class="o">=</span> <span class="n">hsp_objs</span> 
    <span class="k">if</span> <span class="n">hsps_on_different_strands</span><span class="p">:</span>
        <span class="n">hsp_objs_red</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">whether_fwd_strand</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>
            <span class="c1"># Only include in reduced list if on same strand as top HSP.</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fwd_strand</span><span class="p">:</span>
                <span class="n">hsp_objs_red</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

    <span class="c1"># (If more than one hsp)</span>

    <span class="c1"># Only include HSPs that are sufficiently proximate to the top HSP, and not</span>
    <span class="c1"># overlapping.</span>
    <span class="n">proximate_hsp_objs</span> <span class="o">=</span> <span class="n">get_proximate_hsp_objs2</span><span class="p">(</span><span class="n">hsp_objs_red</span><span class="p">,</span> <span class="n">top_hsp</span><span class="p">,</span>
            <span class="n">max_gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Concatenate the hsp sequences in order from 5&#39; to 3&#39; as they appear</span>
    <span class="c1"># in the nucleotide subject sequence.</span>
    <span class="c1"># Make a description of where the hit sequence came from.</span>
    <span class="c1"># Generate a fasta sequence record.</span>
    <span class="n">hit_seq_record</span> <span class="o">=</span> <span class="n">get_hit_seq_record_and_coord</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">proximate_hsp_objs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">hit_seq_record</span></div>


<div class="viewcode-block" id="get_tblastn_hit_seq_obj_and_coord"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_tblastn_hit_seq_obj_and_coord">[docs]</a><span class="k">def</span> <span class="nf">get_tblastn_hit_seq_obj_and_coord</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a SearchIO hit object (containing one or more HSPs) and returns a</span>
<span class="sd">    fasta sequence object likely to correspond to a single gene (the most</span>
<span class="sd">    similar gene to the query in the nucleotide subject sequence).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a list of HSP objects within the given hit object.</span>
    <span class="n">hsp_objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">:</span>
        <span class="n">hsp_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

    <span class="c1"># Determine whether the top HSP is on the forward or reverse strand.</span>
    <span class="n">top_hsp</span> <span class="o">=</span> <span class="n">hsp_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fwd_strand</span> <span class="o">=</span> <span class="n">whether_fwd_strand</span><span class="p">(</span><span class="n">top_hsp</span><span class="p">)</span> 

    <span class="c1"># Check that all the hsps are on the same strand.</span>
    <span class="n">hsps_on_different_strands</span> <span class="o">=</span> <span class="n">check_strands</span><span class="p">(</span><span class="n">hsp_objs</span><span class="p">,</span> <span class="n">fwd_strand</span><span class="p">)</span>

    <span class="c1"># If HSPs are on different strands, then make a reduced list of HSP objects</span>
    <span class="c1"># composed of only those that are on the same strand as the top HSP.</span>
    <span class="n">hsp_objs_red</span> <span class="o">=</span> <span class="n">hsp_objs</span> 
    <span class="k">if</span> <span class="n">hsps_on_different_strands</span><span class="p">:</span>
        <span class="n">hsp_objs_red</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">whether_fwd_strand</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>
            <span class="c1"># Only include in reduced list if on same strand as top HSP.</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fwd_strand</span><span class="p">:</span>
                <span class="n">hsp_objs_red</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

    <span class="c1"># (If more than one hsp)</span>

    <span class="c1"># Only include HSPs that are sufficiently proximate to the top HSP, and not</span>
    <span class="c1"># overlapping.</span>
    <span class="n">proximate_hsp_objs</span> <span class="o">=</span> <span class="n">get_proximate_hsp_objs2</span><span class="p">(</span><span class="n">hsp_objs_red</span><span class="p">,</span> <span class="n">top_hsp</span><span class="p">,</span>
            <span class="n">max_gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Concatenate the hsp sequences in order from 5&#39; to 3&#39; as they appear</span>
    <span class="c1"># in the nucleotide subject sequence.</span>
    <span class="c1">#hit_sequence = Seq(&#39;&#39;.join([str(x.hit.seq).replace(&#39;-&#39;, &#39;&#39;) for x in proximate_hsp_objs]))</span>
    <span class="n">hit_sequence</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;plus&#39;</span><span class="p">:</span> 
        <span class="n">hit_sequence</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">hit</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;minus&#39;</span><span class="p">:</span> 
        <span class="c1"># Reverse the order of the HSPs.</span>
        <span class="n">hit_sequence</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">hit</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>


    <span class="c1"># Make a description of where the hit sequence came from.</span>
    <span class="c1">#seq_origin = &#39;,&#39;.join([&#39;[&#39; + str(x.hit_range[0]) + &#39;..&#39; + str(x.hit_range[1])\</span>
    <span class="c1">#    + &#39;]&#39; for x in proximate_hsp_objs])</span>

    <span class="c1"># Define sequence coordinates as a list.</span>
    <span class="n">seq_coord</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>\
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">]</span>

    <span class="c1"># Generate a fasta sequence record.</span>
    <span class="n">hit_seq_record</span> <span class="o">=</span> <span class="n">SeqRecord</span><span class="p">(</span><span class="n">hit_sequence</span><span class="p">)</span>
    <span class="n">hit_seq_record</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span>
    <span class="n">descr_without_quotation_marks</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">hit_seq_record</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">descr_without_quotation_marks</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span>\
    <span class="nb">str</span><span class="p">(</span><span class="n">seq_coord</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span>

    <span class="c1"># Return the sequence record and sequence coordinates.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">hit_seq_record</span><span class="p">,</span> <span class="n">seq_coord</span><span class="p">]</span></div>


<div class="viewcode-block" id="recursively_add_clusters"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.recursively_add_clusters">[docs]</a><span class="k">def</span> <span class="nf">recursively_add_clusters</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">,</span> <span class="n">hsp_clusters</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;take a list of SearchIO HSP objects and a list of HSP clusters</span>
<span class="sd">    (representing distinct genes), and add clusters recursively. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that there are hsps in the hsp list.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;The input list is empty.&quot;&quot;&quot;</span>

    <span class="c1"># Visualize input hsps.</span>
    <span class="c1">#print_cluster(clusterplus, hit_num, cluster_num, num_dots, startend=None)</span>
    <span class="c1">#print_cluster([hsp_list,[]], &#39;Hit X&#39;, &#39;recursively_add_clusters recursion x&#39;, 150, startend=None)</span>

    <span class="c1"># Check that the clusters are listed in order of ascending E-value.</span>
    <span class="n">hsp_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">evalue</span><span class="p">)</span>
    <span class="c1">#print(&#39;\t\thsp_list: &#39; + str([x.hit_range for x in hsp_list]))</span>

    <span class="c1"># Define top HSP.</span>
    <span class="n">top_hsp</span> <span class="o">=</span> <span class="n">hsp_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#print(&#39;\t\ttop_hsp: &#39; + str(top_hsp.hit_range))</span>

    <span class="c1"># Only include HSPs that are sufficiently proximate to the top HSP, and not</span>
    <span class="c1"># overlapping.</span>
    <span class="c1">#pho = get_proximate_hsp_objs(hsp_list, top_hsp, max_gap)</span>
    <span class="n">pho</span> <span class="o">=</span> <span class="n">get_proximate_hsp_objs2</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">,</span> <span class="n">top_hsp</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span>
    <span class="n">proximate_hsp_objs</span> <span class="o">=</span> <span class="n">pho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">proximate_hsp_objs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Did not properly identify HSPs</span>
<span class="s2">    within hit for clustering at locus.&quot;&quot;&quot;</span>
    <span class="n">leftover_proximate_hsp_objs</span> <span class="o">=</span> <span class="n">pho</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#print(&#39;\t\tproximate_hsp_objs: &#39; + str([x.hit_range for x in proximate_hsp_objs]))</span>

    <span class="c1"># Visualize proximate HSPs.</span>
    <span class="c1">#print_cluster([proximate_hsp_objs, leftover_proximate_hsp_objs], &#39;Hit X&#39;, &#39;recursively_add_clusters recursion x proximate hsps&#39;, 150, startend=None)</span>

    <span class="c1">#print(&#39;XXXXXX&#39;)</span>
    <span class="c1">#print(top_hsp)</span>
    <span class="c1">#print(sorted(proximate_hsp_objs, key=lambda x: x.evalue)[0])</span>

    <span class="c1">## Check that top hsp included in proximate list. Unecessary?</span>
    <span class="c1">#found = False</span>
    <span class="c1">#for hsp in proximate_hsp_objs:</span>
    <span class="c1">#    if hsp.hit_range == top_hsp.hit_range:</span>
    <span class="c1">#        found = True</span>
    <span class="c1">#assert found</span>

    <span class="c1"># Add proximate HPS cluster to list.</span>
    <span class="n">hsp_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">proximate_hsp_objs</span><span class="p">,</span> <span class="n">leftover_proximate_hsp_objs</span><span class="p">])</span>

    <span class="c1"># Note: need to clean up redundancy in code below.</span>

    <span class="c1"># Remove proximate hsp objects (and leftover proximate hsp objects) from</span>
    <span class="c1"># the initial list.</span>
    <span class="n">new_hsp_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">)</span>
    <span class="n">new_new_hsp_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hsps_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">proximate_hsp_objs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Compile a list of HSPs to remove.</span>
        <span class="k">for</span> <span class="n">hsp1</span> <span class="ow">in</span> <span class="n">new_hsp_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hsp2</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span> <span class="o">+</span> <span class="n">leftover_proximate_hsp_objs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp1</span><span class="o">.</span><span class="n">hit</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp2</span><span class="o">.</span><span class="n">hit</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">hsp1</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">hsp2</span><span class="o">.</span><span class="n">hit_range</span><span class="p">:</span>
                        <span class="c1"># Note: Different HSPs may have identical hit_range, but</span>
                        <span class="c1"># different query_range if the query contains repeats.</span>
                        <span class="k">if</span> <span class="n">hsp1</span><span class="o">.</span><span class="n">query_range</span> <span class="o">==</span> <span class="n">hsp2</span><span class="o">.</span><span class="n">query_range</span><span class="p">:</span>
                            <span class="n">hsps_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp1</span><span class="p">)</span>
                            <span class="k">break</span>
        <span class="c1"># Remove from list.</span>
        <span class="c1">#for hsp in hsps_to_remove:</span>
        <span class="c1">#    new_hsp_list.remove(hsp)</span>
        <span class="k">for</span> <span class="n">hsp1</span> <span class="ow">in</span> <span class="n">new_hsp_list</span><span class="p">:</span>
            <span class="n">append</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">hsp2</span> <span class="ow">in</span> <span class="n">hsps_to_remove</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp1</span><span class="o">.</span><span class="n">hit</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp2</span><span class="o">.</span><span class="n">hit</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">hsp1</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">hsp2</span><span class="o">.</span><span class="n">hit_range</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">hsp1</span><span class="o">.</span><span class="n">query_range</span> <span class="o">==</span> <span class="n">hsp2</span><span class="o">.</span><span class="n">query_range</span><span class="p">:</span>
                            <span class="n">append</span> <span class="o">=</span> <span class="kc">False</span> 
                            <span class="k">break</span>
            <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
                <span class="n">new_new_hsp_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp1</span><span class="p">)</span>

        <span class="c1"># Check whether the removal worked.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_new_hsp_list</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Did not remove any HSPs</span>
<span class="s2">        from the list.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsps_to_remove</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">hsps_to_remove</span><span class="p">)),</span> <span class="s2">&quot;&quot;&quot;Redundant</span>
<span class="s2">        HSPs were added to the hsps_to_remove list.&quot;&quot;&quot;</span>
        <span class="c1"># Display.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">hsps_to_remove</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_hsp_list</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_new_hsp_list</span><span class="p">))):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of HSPs to remove: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">to_remove_count</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of HSPs removed: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_hsp_list</span><span class="p">)</span> <span class="o">-</span>\
                <span class="nb">len</span><span class="p">(</span><span class="n">new_new_hsp_list</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;HSPs not removed that should have been:&#39;</span><span class="p">)</span>
            <span class="n">hsps_that_should_have_been_removed_but_were_not</span> <span class="o">=</span>\
                <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">hsps_to_remove</span><span class="p">)</span>\
                <span class="o">-</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_hsp_list</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_new_hsp_list</span><span class="p">)))</span>

            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hsps_that_should_have_been_removed_but_were_not</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hsps_that_should_have_been_removed_but_were_not</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_range</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">hsps_to_remove</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_hsp_list</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_new_hsp_list</span><span class="p">)))</span>

    <span class="c1">#print(&#39;new_hsp_list: &#39; + str(new_hsp_list))</span>

    <span class="c1"># Check that there are no redundant HSPs in the clusters.</span>
    <span class="k">for</span> <span class="n">clusterplus</span> <span class="ow">in</span> <span class="n">hsp_clusters</span><span class="p">:</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">clusterplus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cluster</span><span class="p">)),</span> <span class="s2">&quot;&quot;&quot;Redundant HSPs in list for</span>
<span class="s2">        cluster.&quot;&quot;&quot;</span>

    <span class="c1"># Check that there are no overlaps in the sets of HSPs in the clusters</span>
    <span class="c1"># (redundancy).</span>
    <span class="k">for</span> <span class="n">cluster1</span> <span class="ow">in</span> <span class="n">hsp_clusters</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cluster2</span> <span class="ow">in</span> <span class="n">hsp_clusters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cluster1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cluster2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">hsp1</span> <span class="ow">in</span> <span class="n">cluster1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">hsp2</span> <span class="ow">in</span> <span class="n">cluster2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">assert</span> <span class="n">hsp1</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">!=</span> <span class="n">hsp2</span><span class="o">.</span><span class="n">hit_range</span><span class="p">,</span>\
                        <span class="sd">&quot;&quot;&quot;Different clusters of HSPs contain overlapping sets of HSPs.&quot;&quot;&quot;</span> 

    <span class="c1">## Redundant:</span>
    <span class="c1">## Check that there are no HSPs in the reduced list that fall within the</span>
    <span class="c1">## range of the cluster just identified.</span>
    <span class="c1">#current_cluster_range1 = get_cluster_range(proximate_hsp_objs)</span>
    <span class="c1">#for hsp1 in new_new_hsp_list:</span>
    <span class="c1">#    r1 = set(range(current_cluster_range1[0], current_cluster_range1[1]))</span>
    <span class="c1">#    if not set([hsp1.hit_start, hsp1.hit_end]).intersection(r1) == set():</span>
    <span class="c1">#        print(&#39;problem leftover HSP:&#39;)</span>
    <span class="c1">#        print(hsp1)</span>
    <span class="c1">#        print(&#39;HSPs in cluster:&#39;)</span>
    <span class="c1">#        for hsp in proximate_hsp_objs:</span>
    <span class="c1">#            print(hsp)</span>
    <span class="c1">#    assert set([hsp1.hit_start, hsp1.hit_end]).intersection(r1) == set(),\</span>
    <span class="c1">#    &quot;&quot;&quot;HSP %s falls within the range of the current identified cluster %s.&quot;&quot;&quot;\</span>
    <span class="c1">#    % (str(hsp1.hit_range), str(current_cluster_range1))</span>

    <span class="c1">#if len(leftover_proximate_hsp_objs) &gt; 0:</span>
    <span class="c1">#    current_cluster_range2 = get_cluster_range(leftover_proximate_hsp_objs)</span>
    <span class="c1">#    for hsp1 in new_new_hsp_list:</span>
    <span class="c1">#        r2 = set(range(current_cluster_range2[0], current_cluster_range2[1]))</span>
    <span class="c1">#        assert set([hsp1.hit_start, hsp1.hit_end]).intersection(r2) == set(),\</span>
    <span class="c1">#        &quot;&quot;&quot;HSP %s falls within the range of the HSPs excluded from the current</span>
    <span class="c1">#        identified cluster due to overlap.&quot;&quot;&quot;\</span>
    <span class="c1">#        % str(hsp1.hit_range)</span>

    <span class="c1"># Check that there are no gaps between HSPs larger than max_gap.</span>
    <span class="n">last_hsp</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">last_hsp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">last_hsp</span><span class="o">.</span><span class="n">hit_end</span> <span class="o">-</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span> <span class="o">&lt;=</span> <span class="n">max_gap</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;A gap between</span>
<span class="s2">            adjacent HSPs is larger than max_gap.&quot;&quot;&quot;</span>

    <span class="c1">## Redundant:</span>
    <span class="c1">## Check that top hsp is not included in remaining list.</span>
    <span class="c1">#found = False</span>
    <span class="c1">#for hsp in new_new_hsp_list:</span>
    <span class="c1">#    if hsp.hit_range == top_hsp.hit_range:</span>
    <span class="c1">#        found = True</span>
    <span class="c1">#assert not found</span>

    <span class="c1"># Redundant check?:</span>
    <span class="c1"># Check that none of the HSPs in the proximate HSP list/cluster have</span>
    <span class="c1"># overlapping ranges with each other.</span>
    <span class="k">for</span> <span class="n">hsp1</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">hsp2</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hsp1</span><span class="o">.</span><span class="n">hit_range</span> <span class="o">==</span> <span class="n">hsp2</span><span class="o">.</span><span class="n">hit_range</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">check_if_two_hsps_overlap</span><span class="p">(</span><span class="n">hsp1</span><span class="p">,</span> <span class="n">hsp2</span><span class="p">):</span>
                    <span class="n">overlap</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">hsp1</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">hsp2</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">overlap</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;HSPs in proximate HSP list have</span>
<span class="s2">                overlapping ranges.&quot;&quot;&quot;</span>

    <span class="c1"># Check that the order of HSPs in the proximate HSPs selected makes sense</span>
    <span class="c1"># given their query ranges.</span>
    <span class="n">strand</span> <span class="o">=</span> <span class="n">get_strand_word</span><span class="p">(</span><span class="n">proximate_hsp_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hit_frame</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;plus&#39;</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">proximate_hsp_objs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">proximate_hsp_objs</span><span class="p">)</span>
    <span class="n">last_hsp_query_start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">last_hsp_query_end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1">#print(&#39;\nhsps in proximate_hsp_objs:&#39;)</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="c1">#print(str(hsp.query_start) + &#39; &#39; + str(hsp.hit_start))</span>
        <span class="k">assert</span> <span class="n">hsp</span><span class="o">.</span><span class="n">query_start</span> <span class="o">&gt;</span> <span class="n">last_hsp_query_start</span>\
               <span class="ow">or</span> <span class="n">hsp</span><span class="o">.</span><span class="n">query_end</span> <span class="o">&gt;</span> <span class="n">last_hsp_query_end</span><span class="p">,</span>\
               <span class="sd">&quot;&quot;&quot;Query ranges of the proximate HSPS are not in the appropriate</span>
<span class="sd">               order.&quot;&quot;&quot;</span>
        <span class="n">last_hsp_query_start</span> <span class="o">=</span> <span class="n">hsp</span><span class="o">.</span><span class="n">query_start</span>
        <span class="n">last_hsp_query_end</span> <span class="o">=</span> <span class="n">hsp</span><span class="o">.</span><span class="n">query_end</span>

    <span class="c1"># Stop rule.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_new_hsp_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hsp_clusters</span>
    <span class="c1"># Recursion.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">recursively_add_clusters</span><span class="p">(</span><span class="n">new_new_hsp_list</span><span class="p">,</span> <span class="n">hsp_clusters</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_hsp_clusters"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_hsp_clusters">[docs]</a><span class="k">def</span> <span class="nf">get_hsp_clusters</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a SearchIO Hit object and return a list of lists, where the</span>
<span class="sd">    sublists are HSPs that cluster together on the subject sequence such that</span>
<span class="sd">    it is likely that they represent a distinct gene.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a list of HSP objects within the given hit object.</span>
    <span class="n">hsp_objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">:</span>
        <span class="n">hsp_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

    <span class="c1"># Split HSPs into those on the forward strand and those on the reverse</span>
    <span class="c1"># strand.</span>
    <span class="n">hsp_objs_fwd</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hsp_objs_rev</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hsp_objs</span><span class="p">:</span>
        <span class="n">on_fwd_strand</span> <span class="o">=</span> <span class="n">whether_fwd_strand</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">on_fwd_strand</span><span class="p">:</span>
            <span class="n">hsp_objs_fwd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hsp_objs_rev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

    <span class="c1"># Define list of HSP lists</span>
    <span class="n">list_of_hsp_lists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">templist</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsp_objs_fwd</span><span class="p">,</span> <span class="n">hsp_objs_rev</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">templist</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">list_of_hsp_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_hsp_lists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1">#for i in list_of_hsp_lists:</span>
    <span class="c1">#    for j in i:</span>
    <span class="c1">#        print(j)</span>

    <span class="c1">## Order by lowest E-value of best hit.</span>
    <span class="c1">#if len(list_of_hsp_lists) &gt; 1:</span>
    <span class="c1">#    print(&#39;\nlist_of_hsp_lists: &#39; + str(list_of_hsp_lists))</span>
    <span class="c1">#    list_of_hsp_lists = sorted(list_of_hsp_lists, key=lambda x: min([y.evalue for y in x]))</span>

    <span class="c1"># Add to list of clusters. </span>
    <span class="n">hsp_clusters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp_list</span> <span class="ow">in</span> <span class="n">list_of_hsp_lists</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#hsp_clusters = recursively_add_clusters(hsp_list, hsp_clusters, max_gap)</span>
            <span class="c1">#print(&#39;\n\nRunning recursively_add_clusters on a strand of &#39; + hit.id)</span>
            <span class="n">strand_hsp_clusters</span> <span class="o">=</span> <span class="n">recursively_add_clusters</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">,</span> <span class="p">[],</span> <span class="n">max_gap</span><span class="p">)</span>

            <span class="c1">## Redundant check, because done in recursively_add_clusters</span>
            <span class="c1">## function:</span>
            <span class="c1">## Check that the clusters do not overlap with each other on this</span>
            <span class="c1">## strand of the subject sequence.</span>
            <span class="c1">#for cluster1 in strand_hsp_clusters:</span>
            <span class="c1">#    for cluster2 in strand_hsp_clusters:</span>
            <span class="c1">#        if cluster1[0] != cluster2[0]:</span>
            <span class="c1">#            assert not clusters_overlap(cluster1[0], cluster2[0]),\</span>
            <span class="c1">#            &quot;&quot;&quot;Clusters overlap: %s, and %s&quot;&quot;&quot; %\</span>
            <span class="c1">#            (cluster1[0][0].hit_id + str(get_cluster_range(cluster1[0])) +\</span>
            <span class="c1">#                    &#39; on the &#39; + get_strand_word(cluster1[0][0].hit_frame) + &#39; strand&#39;\</span>
            <span class="c1">#             , cluster2[0][0].hit_id + str(get_cluster_range(cluster2[0])) +\</span>
            <span class="c1">#             &#39; on the &#39; + get_strand_word(cluster2[0][0].hit_frame) + &#39; strand&#39;)</span>

            <span class="c1"># Add clusters to complete list. </span>
            <span class="n">hsp_clusters</span> <span class="o">=</span> <span class="n">hsp_clusters</span> <span class="o">+</span> <span class="n">strand_hsp_clusters</span>

    <span class="c1"># Order clusters by ascending E-value.</span>
    <span class="n">hsp_clusters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hsp_clusters</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">evalue</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>


    <span class="c1">## Concatenate the hsp sequences in order from 5&#39; to 3&#39; as they appear</span>
    <span class="c1">## in the nucleotide subject sequence.</span>
    <span class="c1">#hit_sequence = Seq(&#39;&#39;.join([str(x.hit.seq).replace(&#39;-&#39;, &#39;&#39;) for x in proximate_hsp_objs]))</span>

    <span class="c1">## Make a description of where the hit sequence came from.</span>
    <span class="c1">##seq_origin = &#39;,&#39;.join([&#39;[&#39; + str(x.hit_range[0]) + &#39;..&#39; + str(x.hit_range[1])\</span>
    <span class="c1">##    + &#39;]&#39; for x in proximate_hsp_objs])</span>

    <span class="c1">## Define sequence coordinates as a list.</span>
    <span class="c1">#seq_coord = [[x.hit_range[0],x.hit_range[1]]\</span>
    <span class="c1">#    for x in proximate_hsp_objs]</span>

    <span class="c1">## Generate a fasta sequence record.</span>
    <span class="c1">#hit_seq_record = SeqRecord(hit_sequence)</span>
    <span class="c1">#hit_seq_record.id = hit.id</span>
    <span class="c1">#descr_without_quotation_marks = hit.description.replace(&#39;\&quot;&#39;, &#39;&#39;)</span>
    <span class="c1">#hit_seq_record.description = &#39;\&quot;&#39; + descr_without_quotation_marks + &#39; &#39; +\</span>
    <span class="c1">#str(seq_coord) + &#39;\&quot;&#39;</span>

    <span class="c1"># Return list of HSPs.</span>
    <span class="k">return</span> <span class="n">hsp_clusters</span></div>


<div class="viewcode-block" id="get_strand_word"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_strand_word">[docs]</a><span class="k">def</span> <span class="nf">get_strand_word</span><span class="p">(</span><span class="n">hsp_hit_frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a frame (for a translation of a DNA sequence) and return &#39;plus&#39; or</span>
<span class="sd">    &#39;minus&#39; depending on which strand the frame corresponds to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hsp_hit_frame</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;plus&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;minus&#39;</span></div>


<div class="viewcode-block" id="get_cluster_range"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_cluster_range">[docs]</a><span class="k">def</span> <span class="nf">get_cluster_range</span><span class="p">(</span><span class="n">hsp_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a list of SearchIO HSP objects an return a range from the furthest</span>
<span class="sd">    5&#39; hsp end to the furthest 3&#39; hsp end.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hsp_list</span><span class="p">])</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hsp_list</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span></div>


<div class="viewcode-block" id="clusters_overlap"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.clusters_overlap">[docs]</a><span class="k">def</span> <span class="nf">clusters_overlap</span><span class="p">(</span><span class="n">cluster1</span><span class="p">,</span> <span class="n">cluster2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take two lists of HSPs, and determine if they define overlapping ranges</span>
<span class="sd">    in the subject sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get cluster ranges.</span>
    <span class="n">cluster1_range</span> <span class="o">=</span> <span class="n">get_cluster_range</span><span class="p">(</span><span class="n">cluster1</span><span class="p">)</span>
    <span class="n">cluster2_range</span> <span class="o">=</span> <span class="n">get_cluster_range</span><span class="p">(</span><span class="n">cluster2</span><span class="p">)</span>

    <span class="n">overlap</span> <span class="o">=</span> <span class="n">check_if_two_hsp_ranges_overlap</span><span class="p">([</span><span class="n">cluster1_range</span><span class="p">,</span> <span class="n">cluster2_range</span><span class="p">])</span>
    <span class="c1">## Convert range lists to sets, and check for intersection of those sets.</span>
    <span class="c1">#x = set(range(cluster1_range[0], cluster1_range[1]))</span>
    <span class="c1">#y = set(range(cluster2_range[0], cluster2_range[1]))</span>
    <span class="c1">#intersect = x.intersection(y)</span>

    <span class="c1">#overlap = False</span>
    <span class="c1">#if intersect != set():</span>
    <span class="c1">#    overlap = True</span>

    <span class="k">return</span> <span class="n">overlap</span></div>


<div class="viewcode-block" id="print_cluster"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.print_cluster">[docs]</a><span class="k">def</span> <span class="nf">print_cluster</span><span class="p">(</span><span class="n">clusterplus</span><span class="p">,</span> <span class="n">hit_num</span><span class="p">,</span> <span class="n">cluster_num</span><span class="p">,</span> <span class="n">num_dots</span><span class="p">,</span> <span class="n">startend</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print visualization of cluster.</span>

<span class="sd">    startend is a tuple containing the start and end position of the</span>
<span class="sd">    subsequence of the subject sequence to be visualized.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="n">clusterplus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Get cluster range.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">startend</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">cr</span> <span class="o">=</span> <span class="n">get_cluster_range</span><span class="p">(</span><span class="n">clusterplus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">clusterplus</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">cr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">cr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">startend</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">startend</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">subseqlen</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Hit &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; HSP cluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>
    <span class="c1">#print(&#39;\t\tcluster range: &#39; + str(cr))</span>
    <span class="c1">#print(&#39;\t\tsubseqlen: &#39; + str(subseqlen))</span>
    <span class="c1">#print(&#39;\t\t\t&#39; + hit.id)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;HSP positions in subject sequence (1 dot = &#39;</span> <span class="o">+</span>\
    <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">subseqlen</span> <span class="o">/</span> <span class="n">num_dots</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; bp):&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_dots</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;v&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_dots</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;v&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="n">num_dots</span><span class="p">)</span>

    <span class="c1"># Make a list of hsps.</span>
    <span class="n">hsps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
        <span class="n">hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

    <span class="c1"># Sort the HSPs.</span>
    <span class="n">hsps2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hsps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_start</span><span class="p">)</span>

    <span class="c1"># Display the HSPs.</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hsps2</span><span class="p">:</span>
        <span class="n">prepend_dots</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(((</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="n">num_dots</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">subseqlen</span><span class="p">))</span>
        <span class="n">hsp_string</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(((</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_end</span> <span class="o">-</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_dots</span><span class="p">)</span><span class="o">/</span><span class="n">subseqlen</span><span class="p">)</span>
        <span class="n">append_dots</span> <span class="o">=</span>  <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="nb">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_dots</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">prepend_dots</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsp_string</span><span class="p">)])</span>
        <span class="n">span_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;..&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_end</span><span class="p">)</span>
        <span class="n">strand</span> <span class="o">=</span> <span class="n">get_strand_word</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_frame</span><span class="p">)</span>
        <span class="n">info_string</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">span_string</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="n">strand</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">evalue</span><span class="p">)</span> 
        <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">prepend_dots</span> <span class="o">+</span> <span class="n">hsp_string</span> <span class="o">+</span> <span class="n">append_dots</span> <span class="o">+</span>\
        <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">info_string</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="c1">#for hsp in hsps2:</span>
    <span class="c1">#    string = &#39;\t&#39;</span>
    <span class="c1">#    prepend_dots = &#39;.&#39; * int(((hsp.hit_start - start)*num_dots)/(subseqlen))</span>
    <span class="c1">#    string = string + prepend_dots </span>
    <span class="c1">#    span_string = str(hsp.hit_start) + &#39;, &#39; + str(hsp.hit_end)</span>
    <span class="c1">#    string = string + span_string</span>
    <span class="c1">#    string = string + &#39;.&#39; * max([0, num_dots - len(prepend_dots) - len(span_string)])</span>
    <span class="c1">#    print(string)</span>

    <span class="c1"># Get list of hsps that are proximate to this cluster, but were</span>
    <span class="c1"># exluded due to overlap.</span>
    <span class="n">unsorted_leftover_hsps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">clusterplus</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">unsorted_leftover_hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>
    <span class="n">leftover_hsps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unsorted_leftover_hsps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_start</span><span class="p">)</span>
    
    <span class="c1"># Display leftover HSPs that were excluded due to overlap.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover_hsps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="s1">&#39;Excluded HPSs &#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">t</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_dots</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">leftover_hsps</span><span class="p">:</span>
            <span class="n">prepend_dots</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(((</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="n">num_dots</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">subseqlen</span><span class="p">))</span>
            <span class="n">hsp_string</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(((</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_end</span> <span class="o">-</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_dots</span><span class="p">)</span><span class="o">/</span><span class="n">subseqlen</span><span class="p">)</span>
            <span class="n">append_dots</span> <span class="o">=</span>  <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="nb">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_dots</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">prepend_dots</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsp_string</span><span class="p">)])</span>
            <span class="n">span_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;..&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_end</span><span class="p">)</span>
            <span class="n">strand</span> <span class="o">=</span> <span class="n">get_strand_word</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_frame</span><span class="p">)</span>
            <span class="n">info_string</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">span_string</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="n">strand</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">evalue</span><span class="p">)</span> 
            <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">prepend_dots</span> <span class="o">+</span> <span class="n">hsp_string</span> <span class="o">+</span> <span class="n">append_dots</span> <span class="o">+</span>\
            <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">info_string</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="split_tblastn_hits_into_separate_genes"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.split_tblastn_hits_into_separate_genes">[docs]</a><span class="k">def</span> <span class="nf">split_tblastn_hits_into_separate_genes</span><span class="p">(</span><span class="n">query_res_obj</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a SearchIO QueryResult object and return a new object with hits</span>
<span class="sd">    split into groups of HSPs that represent distinct genes. This is important,</span>
<span class="sd">    because there may be multiple paralogous genes present in a single</span>
<span class="sd">    nucleotide subject sequence (such as a chromosome or scaffold).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Print message.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">Search program was tblastn.</span><span class="se">\n\t</span><span class="s1">Checking number of distinct genes represented by HSPs.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Copy the query result object.</span>
    <span class="c1">#query_res_obj2 = copy.deepcopy(query_res_obj)</span>

    <span class="c1"># Compile a list of all HSP clusters.</span>
    <span class="c1"># Display a simple visualization of HSP location.</span>
    <span class="c1"># List hits and HSPs in original object.</span>
    <span class="n">num_dots</span> <span class="o">=</span> <span class="mi">150</span> 
    <span class="n">all_hsp_clusters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hit_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">query_res_obj</span><span class="p">:</span>
        <span class="n">hit_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Query: &#39;</span> <span class="o">+</span> <span class="n">hit</span><span class="o">.</span><span class="n">query_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Hit &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">hit</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;HSP positions in subject sequence (1 dot = &#39;</span> <span class="o">+</span>\
        <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hit</span><span class="o">.</span><span class="n">seq_len</span> <span class="o">/</span> <span class="n">num_dots</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; bp):&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> &#39;</span> <span class="o">+</span> <span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_dots</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hit</span><span class="o">.</span><span class="n">seq_len</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> &#39;</span> <span class="o">+</span> <span class="s1">&#39;v&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_dots</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;v&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> &#39;</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="n">num_dots</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="s1">&#39;Query range:&#39;</span><span class="p">)</span>

        <span class="c1"># Make a list of hsps.</span>
        <span class="n">hsps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">:</span>
            <span class="n">hsps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

        <span class="c1"># Sort the HSPs.</span>
        <span class="n">hsps2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hsps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">hit_start</span><span class="p">)</span>

        <span class="c1"># Display the HSPs.</span>
        <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hsps2</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_frame</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
            <span class="k">elif</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_frame</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="n">prepend_dots</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="nb">int</span><span class="p">((</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span><span class="o">*</span><span class="n">num_dots</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">hit</span><span class="o">.</span><span class="n">seq_len</span><span class="p">))</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span> <span class="o">+</span> <span class="n">sign</span> <span class="o">+</span> <span class="n">prepend_dots</span> 
            <span class="n">span_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_start</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">hit_end</span><span class="p">)</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span> <span class="o">+</span> <span class="n">span_string</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="nb">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_dots</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">prepend_dots</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">span_string</span><span class="p">)])</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hsp</span><span class="o">.</span><span class="n">query_range</span><span class="p">)</span> <span class="c1">#+ &#39; &#39; + str(hsp.evalue)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
            <span class="c1">#print(hsp.hit.seq)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Generate an expanded list of hit objects.</span>

        <span class="c1"># Recursively find clusters of HSPs that likely represent different</span>
        <span class="c1"># genes, and return as a list of lists.</span>
        <span class="n">hsp_clusters</span> <span class="o">=</span> <span class="n">get_hsp_clusters</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span>
        <span class="n">all_hsp_clusters</span> <span class="o">=</span> <span class="n">all_hsp_clusters</span> <span class="o">+</span> <span class="n">hsp_clusters</span>

        <span class="c1"># Display HSPs in each cluster.</span>
        <span class="n">cluster_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">clusterplus</span> <span class="ow">in</span> <span class="n">hsp_clusters</span><span class="p">:</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="n">clusterplus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cluster_num</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Call function for printing visualization.</span>
            <span class="n">print_cluster</span><span class="p">(</span><span class="n">clusterplus</span><span class="p">,</span> <span class="n">hit_num</span><span class="p">,</span> <span class="n">cluster_num</span><span class="p">,</span> <span class="n">num_dots</span><span class="p">)</span> <span class="c1">#***</span>

        <span class="c1">## ***Redundant?:</span>
        <span class="c1">## Check that the clusters do not overlap with each other on the subject</span>
        <span class="c1">## sequence.</span>
        <span class="c1">#for cluster1 in hsp_clusters:</span>
        <span class="c1">#    for cluster2 in hsp_clusters:</span>
        <span class="c1">#        if cluster1[0] != cluster2[0]:</span>
        <span class="c1">#            if clusters_overlap(cluster1[0], cluster2[0]):</span>
        <span class="c1">#                # Visualize overlapping clusters (for troubleshooting).</span>
        <span class="c1">#                startend = get_cluster_range(cluster1[0] + cluster2[0])</span>
        <span class="c1">#                print(&#39;Overlapping clusters:&#39;)</span>
        <span class="c1">#                print_cluster(cluster1,\</span>
        <span class="c1">#                        str(get_cluster_range(cluster1[0])),\</span>
        <span class="c1">#                        cluster_num, num_dots, startend)</span>
        <span class="c1">#                print_cluster(cluster2,\</span>
        <span class="c1">#                        str(get_cluster_range(cluster2[0])),\</span>
        <span class="c1">#                        cluster_num, num_dots, startend)</span>

        <span class="c1">#            ## Assert no overlap.</span>
        <span class="c1">#            #assert not clusters_overlap(cluster1[0], cluster2[0]),\</span>
        <span class="c1">#            #&quot;&quot;&quot;Clusters overlap: %s and %s&quot;&quot;&quot; %\</span>
        <span class="c1">#            #(cluster1[0][0].hit_id + str(get_cluster_range(cluster1[0])),\</span>
        <span class="c1">#            # cluster2[0][0].hit_id + str(get_cluster_range(cluster2[0])))</span>

    <span class="c1">## Check that the clusters do not overlap with each other on the subject</span>
    <span class="c1">## sequence.</span>
    <span class="c1">#for cluster1 in all_hsp_clusters:</span>
    <span class="c1">#    for cluster2 in all_hsp_clusters:</span>
    <span class="c1">#        if cluster1[0] != cluster2[0]:</span>
    <span class="c1">#            assert not clusters_overlap(cluster1[0], cluster2[0]),\</span>
    <span class="c1">#            &quot;&quot;&quot;Clusters overlap: %s and %s&quot;&quot;&quot; %\</span>
    <span class="c1">#            (cluster1[0][0].hit_id + str(get_cluster_range(cluster1[0])),\</span>
    <span class="c1">#             cluster2[0][0].hit_id + str(get_cluster_range(cluster2[0])))</span>

    <span class="c1"># Return the list of SearchIO HSP (not Hit) object clusters/lists.</span>
    <span class="k">return</span> <span class="n">all_hsp_clusters</span></div>


<div class="viewcode-block" id="get_blastp_hit_seq_obj_and_coord"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.get_blastp_hit_seq_obj_and_coord">[docs]</a><span class="k">def</span> <span class="nf">get_blastp_hit_seq_obj_and_coord</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a SearchIO hit object (containing one or more HSPs) and returns a</span>
<span class="sd">    fasta sequence object likely to correspond to a single gene or the portion</span>
<span class="sd">    of the subject sequence that is actually homologous to the query sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a list of HSP objects within the given hit object.</span>
    <span class="n">hsp_objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">:</span>
        <span class="n">hsp_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsp</span><span class="p">)</span>

    <span class="c1">## Determine whether the top HSP is on the forward or reverse strand.</span>
    <span class="n">top_hsp</span> <span class="o">=</span> <span class="n">hsp_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#fwd_strand = whether_fwd_strand(top_hsp) </span>

    <span class="c1">## Check that all the hsps are on the same strand.</span>
    <span class="c1">#hsps_on_different_strands = check_strands(hsp_objs, fwd_strand)</span>

    <span class="c1">## If HSPs are on different strands, then make a reduced list of HSP objects</span>
    <span class="c1">## composed of only those that are on the same strand as the top HSP.</span>
    <span class="n">hsp_objs_red</span> <span class="o">=</span> <span class="n">hsp_objs</span> 
    <span class="c1">#if hsps_on_different_strands:</span>
    <span class="c1">#    hsp_objs_red = []</span>
    <span class="c1">#    for hsp in hsp_objs:</span>
    <span class="c1">#        x = whether_fwd_strand(hsp)</span>
    <span class="c1">#        # Only include in reduced list if on same strand as top HSP.</span>
    <span class="c1">#        if x == fwd_strand:</span>
    <span class="c1">#            hsp_objs_red.append(hsp)</span>

    <span class="c1"># (If more than one hsp)</span>

    <span class="c1"># Only include HSPs that are sufficiently proximate to the top HSP, and not</span>
    <span class="c1"># overlapping.</span>
    <span class="n">proximate_hsp_objs</span> <span class="o">=</span> <span class="n">get_proximate_hsp_objs2</span><span class="p">(</span><span class="n">hsp_objs_red</span><span class="p">,</span> <span class="n">top_hsp</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Concatenate the hsp sequences in order from 5&#39; to 3&#39; as they appear</span>
    <span class="c1"># in the nucleotide subject sequence.</span>
    <span class="n">hit_sequence</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">hit</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">]))</span>

    <span class="c1"># Make a description of where the hit sequence came from.</span>
    <span class="c1">#seq_origin = &#39;,&#39;.join([&#39;[&#39; + str(x.hit_range[0]) + &#39;..&#39; + str(x.hit_range[1])\</span>
    <span class="c1">#    + &#39;]&#39; for x in proximate_hsp_objs])</span>

    <span class="c1"># Define sequence coordinates as a list.</span>
    <span class="n">seq_coord</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="o">.</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>\
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">proximate_hsp_objs</span><span class="p">]</span>

    <span class="c1"># Generate a fasta sequence record.</span>
    <span class="n">hit_seq_record</span> <span class="o">=</span> <span class="n">SeqRecord</span><span class="p">(</span><span class="n">hit_sequence</span><span class="p">)</span>
    <span class="n">hit_seq_record</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span>
    <span class="n">descr_without_quotation_marks</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">hit_seq_record</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">descr_without_quotation_marks</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span>\
    <span class="nb">str</span><span class="p">(</span><span class="n">seq_coord</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span>

    <span class="c1"># Return the sequence record and sequence coordinates.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">hit_seq_record</span><span class="p">,</span> <span class="n">seq_coord</span><span class="p">]</span></div>




<span class="c1">#def get_tblastn_hit_subseq_coord(hit, max_gap):</span>
<span class="c1">#    &quot;&quot;&quot;Takes a SearchIO hit object (containing one or more HSPs) and returns a</span>
<span class="c1">#    coordinates for the subsequence(s) likely to correspond to the coding</span>
<span class="c1">#    sequence of a single gene (the most similar gene to the query in the</span>
<span class="c1">#    nucleotide subject sequence).</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    # Make a list of HSP objects within the given hit object.</span>
<span class="c1">#    hsp_objs = []</span>
<span class="c1">#    for hsp in hit:</span>
<span class="c1">#        hsp_objs.append(hsp)</span>
<span class="c1">#</span>
<span class="c1">#    # Determine whether the top HSP is on the forward or reverse strand.</span>
<span class="c1">#    top_hsp = hsp_objs[0]</span>
<span class="c1">#    fwd_strand = whether_fwd_strand(top_hsp) </span>
<span class="c1">#</span>
<span class="c1">#    # Check that all the hsps are on the same strand.</span>
<span class="c1">#    hsps_on_different_strands = check_strands(hsp_objs, fwd_strand)</span>
<span class="c1">#</span>
<span class="c1">#    # If HSPs are on different strands, then make a reduced list of HSP objects</span>
<span class="c1">#    # composed of only those that are on the same strand as the top HSP.</span>
<span class="c1">#    hsp_objs_red = hsp_objs </span>
<span class="c1">#    if hsps_on_different_strands:</span>
<span class="c1">#        hsp_objs_red = []</span>
<span class="c1">#        for hsp in hsp_objs:</span>
<span class="c1">#            x = whether_fwd_strand(hsp)</span>
<span class="c1">#            # Only include in reduced list if on same strand as top HSP.</span>
<span class="c1">#            if x == fwd_strand:</span>
<span class="c1">#                hsp_objs_red.append(hsp)</span>
<span class="c1">#</span>
<span class="c1">#    # (If more than one hsp)</span>
<span class="c1">#</span>
<span class="c1">#    # Only include HSPs that are sufficiently proximate to the top HSP, and not</span>
<span class="c1">#    # overlapping.</span>
<span class="c1">#    proximate_hsp_objs = get_proximate_hsp_objs(hsp_objs_red, top_hsp, max_gap)</span>
<span class="c1">#</span>
<span class="c1">#    # Concatenate the hsp sequences in order from 5&#39; to 3&#39; as they appear</span>
<span class="c1">#    # in the nucleotide subject sequence.</span>
<span class="c1">#    #hit_sequence = Seq(&#39;&#39;.join([str(x.hit.seq).replace(&#39;-&#39;, &#39;&#39;) for x in proximate_hsp_objs]))</span>
<span class="c1">#</span>
<span class="c1">#    # Make a description of where the hit sequence came from.</span>
<span class="c1">#    seq_origin = &#39;,&#39;.join([&#39;[&#39; + str(x.hit_range[0]) + &#39;..&#39; + str(x.hit_range[1])\</span>
<span class="c1">#        + &#39;]&#39; for x in proximate_hsp_objs])</span>
<span class="c1">#</span>
<span class="c1">#    # Generate a fasta sequence record.</span>
<span class="c1">#    #hit_seq_record = SeqRecord(hit_sequence)</span>
<span class="c1">#    #hit_seq_record.id = hit.id</span>
<span class="c1">#    #descr_without_quotation_marks = hit.description.replace(&#39;\&quot;&#39;, &#39;&#39;)</span>
<span class="c1">#    #hit_seq_record.description = &#39;\&quot;&#39; + descr_without_quotation_marks + &#39; &#39; + seq_origin + &#39;\&quot;&#39;</span>
<span class="c1">#</span>
<span class="c1">#    #return hit_seq_record</span>
<span class="c1">#    print(&#39;seq_origin&#39;)</span>
<span class="c1">#    print(seq_origin)</span>
<span class="c1">#    return seq_origin</span>


<div class="viewcode-block" id="parse_tblastn"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.parse_tblastn">[docs]</a><span class="k">def</span> <span class="nf">parse_tblastn</span><span class="p">(</span><span class="n">tblastn_out_path</span><span class="p">,</span> <span class="n">seq_out_path</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse a given tblastn output file (XML) and write appropriate sequences</span>
<span class="sd">    corresponding to hits therein to a given sequence file path. Also, return</span>
<span class="sd">    relevant info for recording results. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define input and output paths.</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="n">tblastn_out_path</span>
    <span class="n">outfile3</span> <span class="o">=</span> <span class="n">seq_out_path</span>

    <span class="c1"># Parse tblastn output (using biopython &quot;experimental code&quot;).</span>
    <span class="n">fwd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">)</span>
    <span class="n">fwd_recs</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">fwd</span><span class="p">,</span> <span class="s1">&#39;blast-xml&#39;</span><span class="p">)</span>
    <span class="n">rec_num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile3</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span> 
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">fwd_recs</span><span class="p">:</span>
            <span class="n">rec_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">hit_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">record</span><span class="p">:</span>
                <span class="n">hit_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">hit_seq_obj</span> <span class="o">=</span> <span class="n">get_hit_seq_obj</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span>

                <span class="c1"># Write fasta string to output file.</span>
                <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">hit_seq_obj</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="search_scaffolds"><a class="viewcode-back" href="../module_search_scaffolds.html#module_search_scaffolds.search_scaffolds">[docs]</a><span class="k">def</span> <span class="nf">search_scaffolds</span><span class="p">(</span><span class="n">query_file</span><span class="p">,</span> <span class="n">subject_db</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uses functions to search a given nucleotide db with a given protein</span>
<span class="sd">    query.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define output for tblastn search.</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="n">query_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;_tblastn_out.txt&#39;</span><span class="p">)</span>
    <span class="n">outfile2</span> <span class="o">=</span> <span class="n">query_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;_tblastn_out_text.txt&#39;</span><span class="p">)</span>
    <span class="n">outfile3</span> <span class="o">=</span> <span class="n">query_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;_tblastn_out_seqs.fa&#39;</span><span class="p">)</span>

    <span class="c1"># Run tblastn using given files.</span>
    <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s2">&quot;tblastn&quot;</span><span class="p">,</span> <span class="s2">&quot;-query&quot;</span><span class="p">,</span> <span class="n">query_file</span><span class="p">,</span> <span class="s2">&quot;-db&quot;</span><span class="p">,</span> <span class="n">subject_db</span><span class="p">,</span> <span class="s2">&quot;-out&quot;</span><span class="p">,</span>\
        <span class="n">outfile</span><span class="p">,</span> <span class="s2">&quot;-outfmt&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;-evalue&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)])</span>

    <span class="c1">## Do it again just to get text output (TEMPORARY).</span>
    <span class="c1">#subprocess.call([&quot;tblastn&quot;, &quot;-query&quot;, query_file, &quot;-db&quot;, subject_db, &quot;-out&quot;,\</span>
    <span class="c1">#    outfile2, &quot;-evalue&quot;, str(0.05)])</span>

    <span class="c1"># Parse tblastn output file and write hit sequence to given file.</span>
    <span class="n">parse_tblastn</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">outfile3</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span></div>



</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Lael D. Barlow.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>