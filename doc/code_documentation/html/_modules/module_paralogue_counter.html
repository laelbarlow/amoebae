
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>module_paralogue_counter &#8212; amoebae 0.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for module_paralogue_counter</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright 2018 Lael D. Barlow</span>
<span class="c1"># </span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1"># </span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># </span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># </span>
<span class="sd">&quot;&quot;&quot;This module contains functions to be used in the paralogue_counter.py</span>
<span class="sd">script (or other scripts). </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">AlignIO</span><span class="p">,</span> <span class="n">SeqIO</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="k">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">module_amoebae_nex_to_hmm</span> <span class="k">import</span> <span class="n">nex_to_hmm</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">from</span> <span class="nn">module_afa_to_nex</span> <span class="k">import</span> <span class="n">afa_to_nex</span><span class="p">,</span> <span class="n">delete_extra_mesquite_lines</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="k">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="k">import</span> <span class="n">IUPAC</span><span class="p">,</span> <span class="n">Gapped</span>
<span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="k">import</span> <span class="n">SeqRecord</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">settings</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">from</span> <span class="nn">module_similarity_score</span> <span class="k">import</span> <span class="n">get_similarity_score</span><span class="p">,</span> <span class="n">get_score_dataframe_from_file</span>
<span class="kn">import</span> <span class="nn">module_amoebae</span>
<span class="kn">import</span> <span class="nn">gffutils</span>
<span class="kn">from</span> <span class="nn">module_amoebae</span> <span class="k">import</span> <span class="n">mask_nex2</span>
<span class="kn">from</span> <span class="nn">module_amoebae</span> <span class="k">import</span> <span class="n">get_seq_obj_from_srch_res_csv_info</span><span class="p">,</span>\
<span class="n">get_hit_range_from_hsp_ranges</span> 
<span class="kn">from</span> <span class="nn">module_amoebae_trim_nex</span> <span class="k">import</span> <span class="n">trim_nex</span>


<div class="viewcode-block" id="remove_irrelevant_data_from_alignment"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.remove_irrelevant_data_from_alignment">[docs]</a><span class="k">def</span> <span class="nf">remove_irrelevant_data_from_alignment</span><span class="p">(</span><span class="n">ali_plus_top_seq_plus_1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove all but the last two sequences, and remove all the positions that</span>
<span class="sd">    only contain gaps.</span>

<span class="sd">    ***This function is not in use, because as currently written it will crash</span>
<span class="sd">    the computer. I don&#39;t know why.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parse the input alignment.</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">ali_plus_top_seq_plus_1</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>

    <span class="c1"># Remove the original file.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ali_plus_top_seq_plus_1</span><span class="p">)</span>

    <span class="c1"># Remove all but the last two sequences from the alignment.</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">alignment</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>


    <span class="c1"># Remove positions in the alignment that have only gaps for both</span>
    <span class="c1"># sequences.</span>

    <span class="c1"># get a list of columns as strings in the original alignment.</span>
    <span class="n">seq_len</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">alignment</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_len</span><span class="p">)]</span> 

    <span class="c1"># Get a list of column indexes for columns that need to be remove.</span>
    <span class="n">col_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">col_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
        <span class="n">col_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">col_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_index</span><span class="p">)</span>

    
    <span class="c1">#seq_len = alignment.get_alignment_length()</span>
    <span class="c1">#print(seq_len)</span>
    <span class="c1">#print(alignment[:,col_to_remove[0]])</span>

    <span class="c1"># Remove columns (positions) from alignment.</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">col_index</span> <span class="ow">in</span> <span class="n">col_to_remove</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">adj_col_index</span> <span class="o">=</span> <span class="n">col_index</span> <span class="o">-</span> <span class="n">num</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="n">alignment</span><span class="p">[:,:</span><span class="n">adj_col_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">alignment</span><span class="p">[:,</span><span class="n">adj_col_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="c1">#if col_index != (seq_len -1):</span>
        <span class="c1">#    alignment = alignment[:,:adj_col_index] + alignment[:,adj_col_index + 1:]</span>
        <span class="c1">#else:</span>
        <span class="c1">#    alignment = alignment[:,:adj_col_index]</span>

    <span class="c1">#seq_len = alignment.get_alignment_length()</span>
    <span class="c1">#print(seq_len)</span>
    <span class="c1">#print(alignment[:,col_to_remove[0]])</span>

    <span class="c1"># Write modified alignment to the same filepath as the original.</span>
    <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">ali_plus_top_seq_plus_1</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="check_for_redundant_seq_names"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.check_for_redundant_seq_names">[docs]</a><span class="k">def</span> <span class="nf">check_for_redundant_seq_names</span><span class="p">(</span><span class="n">alignment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take an alignment, and assert that there are no sequences with identical</span>
<span class="sd">    names in the alignment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="rank_seqs_by_hmm"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.rank_seqs_by_hmm">[docs]</a><span class="k">def</span> <span class="nf">rank_seqs_by_hmm</span><span class="p">(</span><span class="n">inali</span><span class="p">,</span> <span class="n">inseqs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes an HMM and fasta sequences, and ranks the sequences according to</span>
<span class="sd">    similarity to the HMM, outputting a list of Bio.SeqIO sequence objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert nexus alignment to HMM.</span>
    <span class="n">hmmname</span> <span class="o">=</span> <span class="n">inali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_TEMP.hmm&#39;</span>
    <span class="n">hmmstdoutname</span> <span class="o">=</span> <span class="n">hmmname</span> <span class="o">+</span> <span class="s1">&#39;.stdout.txt&#39;</span>
    <span class="n">nex_to_hmm</span><span class="p">(</span><span class="n">inali</span><span class="p">,</span> <span class="n">hmmname</span><span class="p">)</span>

    <span class="c1"># Search input fasta file with HMM.</span>
    <span class="n">hmmoutput</span> <span class="o">=</span> <span class="n">hmmname</span> <span class="o">+</span> <span class="s1">&#39;_out.txt&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">hmmstdoutname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s1">&#39;hmmsearch&#39;</span><span class="p">,</span> <span class="s1">&#39;--tblout&#39;</span><span class="p">,</span> <span class="n">hmmoutput</span><span class="p">,</span> <span class="n">hmmname</span><span class="p">,</span> <span class="n">inseqs</span><span class="p">],</span>\
                <span class="n">stdout</span><span class="o">=</span><span class="n">o</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>

    <span class="c1"># Parse output, and get ranked list of accessions.</span>
    <span class="n">space_char</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39; +&#39;</span><span class="p">)</span>
    <span class="n">ranked_acc_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">inum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">hmmoutput</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
                <span class="n">inum</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">parsed_i</span> <span class="o">=</span> <span class="n">space_char</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">parsed_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ranked_acc_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">]</span> <span class="o">=</span> <span class="n">inum</span>
    <span class="c1">#assert ranked_acc_dict != {}, &quot;&quot;&quot;Error: could not parse accessions from</span>
    <span class="c1">#sequence objects.&quot;&quot;&quot;</span>

    <span class="c1"># Get list of sequence objects from input fasta file.</span>
    <span class="n">num_seqs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">seq_objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">inseqs</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
        <span class="n">num_seqs</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">seq_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

    <span class="c1"># Check that all the sequences were identified as hits with HMMer.</span>
    <span class="k">assert</span> <span class="n">inum</span> <span class="o">==</span> <span class="n">num_seqs</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Error: Not all sequences in input fasta file</span>
<span class="s2">    are identified as hits for the HMM.&quot;&quot;&quot;</span>

    <span class="c1"># Rank the list of sequence objects according to similarity to the HMM.</span>
    <span class="n">seq_objs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ranked_acc_dict</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Delete intermediate files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">hmmname</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">hmmoutput</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">hmmstdoutname</span><span class="p">)</span>

    <span class="c1"># return ranked list of sequence objects.</span>
    <span class="k">return</span> <span class="n">seq_objs</span></div>


<div class="viewcode-block" id="get_sig_overlap"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.get_sig_overlap">[docs]</a><span class="k">def</span> <span class="nf">get_sig_overlap</span><span class="p">(</span><span class="n">inali</span><span class="p">,</span> <span class="n">score_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if there is significant overlap between two sequences in an</span>
<span class="sd">    alignment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minimum_aligning_residues</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">minimum_identical_residues</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">minimum_similar_residues</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">sig_overlap</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Delete extra lines in input nexus file, if present, because biopython cannot</span>
    <span class="c1"># read nexus alignments with these extra lines.</span>
    <span class="n">delete_extra_mesquite_lines</span><span class="p">(</span><span class="n">inali</span><span class="p">)</span>

    <span class="c1">#percent_identity = None</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inali</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="c1"># Check that the input file has the filename extension &quot;.nex&quot;.</span>
        <span class="k">assert</span> <span class="n">inali</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.nex&#39;</span><span class="p">),</span> <span class="s2">&quot;Error: Input file name must have the</span><span class="se">\</span>
<span class="s2"> extension &#39;.nex&#39;.&quot;</span>

        <span class="c1"># Read the alignment file.</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>

        <span class="c1"># get a list of columns as strings in the original alignment.</span>
        <span class="n">seq_len</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">alignment</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_len</span><span class="p">)]</span> 

        <span class="c1"># Count columns where the last two sequences have aligned residues, and</span>
        <span class="c1"># where they have identical residues.</span>
        <span class="n">aligned_residues_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">identical_residues_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">similar_not_ident_residues_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">last_two</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">last_two</span><span class="p">:</span>
                <span class="n">aligned_residues_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">identical_residues_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">get_similarity_score</span><span class="p">(</span><span class="n">last_two</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">score_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">similar_not_ident_residues_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Calculate percent identity.</span>
        <span class="c1">#percent_identity = (identical_residues_count/aligned_residues_count)*100</span>

        <span class="c1"># Temporary print statements.</span>
        <span class="c1">#print(&#39;aligned_residues_count: &#39; + str(aligned_residues_count))</span>
        <span class="c1">#print(&#39;identical_residues_count: &#39; + str(identical_residues_count))</span>
        <span class="c1">#print(&#39;similar_not_ident_residues_count: &#39; + str(similar_not_ident_residues_count))</span>

        <span class="c1"># Determine whether there is significant overlap.</span>
        <span class="k">if</span> <span class="n">aligned_residues_count</span> <span class="o">&gt;=</span> <span class="mi">20</span> <span class="ow">and</span> <span class="n">identical_residues_count</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="ow">and</span>\
            <span class="p">(</span><span class="n">identical_residues_count</span> <span class="o">+</span> <span class="n">similar_not_ident_residues_count</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">15</span><span class="p">:</span>
            <span class="n">sig_overlap</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Return percent identity.    </span>
    <span class="k">return</span> <span class="n">sig_overlap</span></div>


<span class="c1"># Unused??</span>
<div class="viewcode-block" id="get_percent_identity"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.get_percent_identity">[docs]</a><span class="k">def</span> <span class="nf">get_percent_identity</span><span class="p">(</span><span class="n">inali</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take an alignment, and return the percent identity between the last two</span>
<span class="sd">    sequences in an alignment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Delete extra lines in input nexus file, if present, because biopython cannot</span>
    <span class="c1"># read nexus alignments with these extra lines.</span>
    <span class="n">delete_extra_mesquite_lines</span><span class="p">(</span><span class="n">inali</span><span class="p">)</span>

    <span class="n">percent_identity</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inali</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="c1"># Check that the input file has the filename extension &quot;.nex&quot;.</span>
        <span class="k">assert</span> <span class="n">inali</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.nex&#39;</span><span class="p">),</span> <span class="s2">&quot;Error: Input file name must have the</span><span class="se">\</span>
<span class="s2"> extension &#39;.nex&#39;.&quot;</span>

        <span class="c1"># Read the alignment file.</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>

        <span class="c1"># get a list of columns as strings in the original alignment.</span>
        <span class="n">seq_len</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">alignment</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_len</span><span class="p">)]</span> 

        <span class="c1"># Count columns where the last two sequences have aligned residues, and</span>
        <span class="c1"># where they have identical residues.</span>
        <span class="n">aligned_residues_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">identical_residues_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">last_two</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">last_two</span><span class="p">:</span>
                <span class="n">aligned_residues_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">identical_residues_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Calculate percent identity.</span>
        <span class="n">percent_identity</span> <span class="o">=</span> <span class="p">(</span><span class="n">identical_residues_count</span><span class="o">/</span><span class="n">aligned_residues_count</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>

    <span class="c1"># Return percent identity.    </span>
    <span class="k">return</span> <span class="n">percent_identity</span></div>

    <span class="c1"># Could calculate similarity as well?</span>


<div class="viewcode-block" id="add_seq_to_alignment2"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.add_seq_to_alignment2">[docs]</a><span class="k">def</span> <span class="nf">add_seq_to_alignment2</span><span class="p">(</span><span class="n">inseqobj</span><span class="p">,</span> <span class="n">innexpath</span><span class="p">,</span> <span class="n">outnexpath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a sequence and adds it to an alignment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Write input sequence object to a file temporarily for input to MUSCLE.</span>
    <span class="n">fa_temp_1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outnexpath</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">innexpath</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_temp1.fa&#39;</span><span class="p">)</span>
    <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">inseqobj</span><span class="p">,</span> <span class="n">fa_temp_1</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>

    <span class="c1"># Temporarily save a copy of the input alignment (nexus format) to fasta</span>
    <span class="c1"># file.</span>
    <span class="c1"># Check input format.</span>
    <span class="n">informat</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">innexpath</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">):</span>
                <span class="n">informat</span> <span class="o">=</span> <span class="s1">&#39;fasta&#39;</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">informat</span> <span class="o">=</span> <span class="s1">&#39;nexus&#39;</span>
    <span class="c1"># Convert if nexus.</span>
    <span class="n">inali</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">informat</span> <span class="o">==</span> <span class="s1">&#39;nexus&#39;</span><span class="p">:</span> 
        <span class="c1"># Delete extra lines in input nexus file, if present, because biopython cannot</span>
        <span class="c1"># read nexus alignments with these extra lines.</span>
        <span class="n">delete_extra_mesquite_lines</span><span class="p">(</span><span class="n">innexpath</span><span class="p">)</span>

        <span class="c1"># Read the alignment file.</span>
        <span class="n">inali</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">innexpath</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inali</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">innexpath</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>
    <span class="c1"># Define temporary fasta alignment file path.</span>
    <span class="n">fa_temp_2</span> <span class="o">=</span> <span class="n">fa_temp_1</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_temp1.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;_temp2.afa&#39;</span><span class="p">)</span>
    <span class="c1"># Write alignment to path in fasta format. </span>
    <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">inali</span><span class="p">,</span> <span class="n">fa_temp_2</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>

    <span class="c1"># Check that the input sequence does not have the same name as any of the</span>
    <span class="c1"># sequences in the input alignment.</span>
    <span class="c1"># Get list of sequence names from alignment.</span>
    <span class="n">existing_seq_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fa_temp_2</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
            <span class="n">extra_text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\.copy$&#39;</span><span class="p">)</span>
            <span class="n">rec_id_no_extra</span> <span class="o">=</span> <span class="n">extra_text</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">description</span><span class="p">)</span> 
            <span class="n">existing_seq_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec_id_no_extra</span><span class="p">)</span>
            <span class="c1">#existing_seq_names.append(record.id)</span>
    <span class="c1"># Get additional sequence name.</span>
    <span class="n">additional_seq_name</span> <span class="o">=</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span>

    <span class="c1"># Align sequence to alignment (make sure that gap penalties are optimized).</span>
    <span class="n">fa_temp_3</span> <span class="o">=</span> <span class="n">fa_temp_2</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_temp2.afa&#39;</span><span class="p">,</span> <span class="s1">&#39;_temp3.afa&#39;</span><span class="p">)</span>
    <span class="n">musclestdoutname</span> <span class="o">=</span> <span class="n">fa_temp_3</span> <span class="o">+</span> <span class="s1">&#39;_musclestdout.txt&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">musclestdoutname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s2">&quot;muscle&quot;</span><span class="p">,</span> <span class="s2">&quot;-profile&quot;</span><span class="p">,</span> <span class="s2">&quot;-in1&quot;</span><span class="p">,</span> <span class="n">fa_temp_2</span><span class="p">,</span> <span class="s2">&quot;-in2&quot;</span><span class="p">,</span>
            <span class="n">fa_temp_1</span><span class="p">,</span> <span class="s2">&quot;-out&quot;</span><span class="p">,</span> <span class="n">fa_temp_3</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">o</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;The alignment file </span><span class="si">%s</span><span class="s2"> was not</span>
<span class="s2">    produced. Check that the alignment does not contain &#39;?&#39; characters as</span>
<span class="s2">    residues for any sequences.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">)</span>

    <span class="c1"># Convert alignment to nexus format.</span>
    <span class="n">nex_out_1</span> <span class="o">=</span> <span class="n">outnexpath</span>
    <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">,</span> <span class="n">nex_out_1</span><span class="p">)</span> 

    <span class="c1">## Mask alignment (mask out any positions in which the last sequence, the</span>
    <span class="c1">## additional sequence, has a residue but none of the other sequences have</span>
    <span class="c1">## residues at that position).</span>
    <span class="c1">#nex_out_2_mask = nex_out_1.rsplit(&#39;.&#39;, 1)[0] + &#39;_mask.nex&#39;</span>
    <span class="c1">#mask_nex2(nex_out_1, nex_out_2_mask) </span>

    <span class="c1">## Trim alignment.</span>
    <span class="c1">#nex_out_3_trim = nex_out_2_mask.rsplit(&#39;_&#39;, 1)[0] + &#39;_trim.nex&#39;</span>
    <span class="c1">#trim_nex(nex_out_2_mask, nex_out_3_trim)</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_1</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_2</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">musclestdoutname</span><span class="p">)</span></div>
    <span class="c1">#os.remove(nex_out_1)</span>


<div class="viewcode-block" id="modify_seq_descr_for_tree"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.modify_seq_descr_for_tree">[docs]</a><span class="k">def</span> <span class="nf">modify_seq_descr_for_tree</span><span class="p">(</span><span class="n">inseqobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a SeqIO sequence object, and modify the header for easy parsing in</span>
<span class="sd">    alignment and tree files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set the ID to the a modification of the original description (assuming</span>
    <span class="c1"># that the ID is included in the original description).</span>
    <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span><span class="p">:</span>
        <span class="n">inseqobj</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span>\
            <span class="o">+</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inseqobj</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span>\
            <span class="o">+</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="c1"># Set the description to an empty string.</span>
    <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span></div>


<div class="viewcode-block" id="add_seq_to_alignment3"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.add_seq_to_alignment3">[docs]</a><span class="k">def</span> <span class="nf">add_seq_to_alignment3</span><span class="p">(</span><span class="n">inseqobj</span><span class="p">,</span> <span class="n">innexpath</span><span class="p">,</span> <span class="n">outnexpath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a sequence and adds it to an alignment. Make sure that the</span>
<span class="sd">    sequence header is formatted correctly (e.g., use modify_seq_descr_for_tree</span>
<span class="sd">    function).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Write input sequence object to a file temporarily for input to MUSCLE.</span>
    <span class="n">fa_temp_1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outnexpath</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">innexpath</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_temp1.fa&#39;</span><span class="p">)</span>
    <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">inseqobj</span><span class="p">,</span> <span class="n">fa_temp_1</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>

    <span class="c1"># Temporarily save a copy of the input alignment (nexus format) to fasta</span>
    <span class="c1"># file.</span>
    <span class="c1"># Check input format.</span>
    <span class="n">informat</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">innexpath</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">):</span>
                <span class="n">informat</span> <span class="o">=</span> <span class="s1">&#39;fasta&#39;</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">informat</span> <span class="o">=</span> <span class="s1">&#39;nexus&#39;</span>
    <span class="c1"># Convert if nexus.</span>
    <span class="n">inali</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">informat</span> <span class="o">==</span> <span class="s1">&#39;nexus&#39;</span><span class="p">:</span> 
        <span class="c1"># Delete extra lines in input nexus file, if present, because biopython cannot</span>
        <span class="c1"># read nexus alignments with these extra lines.</span>
        <span class="n">delete_extra_mesquite_lines</span><span class="p">(</span><span class="n">innexpath</span><span class="p">)</span>

        <span class="c1"># Read the alignment file.</span>
        <span class="n">inali</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">innexpath</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inali</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">innexpath</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>
    <span class="c1"># Define temporary fasta alignment file path.</span>
    <span class="n">fa_temp_2</span> <span class="o">=</span> <span class="n">fa_temp_1</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_temp1.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;_temp2.afa&#39;</span><span class="p">)</span>
    <span class="c1"># Write alignment to path in fasta format. </span>
    <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">inali</span><span class="p">,</span> <span class="n">fa_temp_2</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>

    <span class="c1"># Check that the input sequence does not have the same name as any of the</span>
    <span class="c1"># sequences in the input alignment.</span>
    <span class="c1"># Get list of sequence names from alignment.</span>
    <span class="n">existing_seq_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fa_temp_2</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
            <span class="n">extra_text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\.copy$&#39;</span><span class="p">)</span>
            <span class="n">rec_id_no_extra</span> <span class="o">=</span> <span class="n">extra_text</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">description</span><span class="p">)</span> 
            <span class="n">existing_seq_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec_id_no_extra</span><span class="p">)</span>
            <span class="c1">#existing_seq_names.append(record.id)</span>
    <span class="c1"># Get additional sequence name.</span>
    <span class="n">additional_seq_name</span> <span class="o">=</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span>

    <span class="c1"># Align sequence to alignment (make sure that gap penalties are optimized).</span>
    <span class="n">fa_temp_3</span> <span class="o">=</span> <span class="n">fa_temp_2</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_temp2.afa&#39;</span><span class="p">,</span> <span class="s1">&#39;_temp3.afa&#39;</span><span class="p">)</span>
    <span class="n">musclestdoutname</span> <span class="o">=</span> <span class="n">fa_temp_3</span> <span class="o">+</span> <span class="s1">&#39;_musclestdout.txt&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">musclestdoutname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s2">&quot;muscle&quot;</span><span class="p">,</span> <span class="s2">&quot;-profile&quot;</span><span class="p">,</span> <span class="s2">&quot;-in1&quot;</span><span class="p">,</span> <span class="n">fa_temp_2</span><span class="p">,</span> <span class="s2">&quot;-in2&quot;</span><span class="p">,</span>
            <span class="n">fa_temp_1</span><span class="p">,</span> <span class="s2">&quot;-out&quot;</span><span class="p">,</span> <span class="n">fa_temp_3</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">o</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;The alignment file </span><span class="si">%s</span><span class="s2"> was not</span>
<span class="s2">    produced. Check that the alignment does not contain &#39;?&#39; characters as</span>
<span class="s2">    residues for any sequences.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">)</span>

    <span class="c1"># Convert alignment to nexus format.</span>
    <span class="n">nex_out_1</span> <span class="o">=</span> <span class="n">outnexpath</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_untrimmed.nex&#39;</span>
    <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">,</span> <span class="n">nex_out_1</span><span class="p">)</span> 

    <span class="c1"># Mask alignment (mask out any positions in which the last sequence, the</span>
    <span class="c1"># additional sequence, has a residue but none of the other sequences have</span>
    <span class="c1"># residues at that position).</span>
    <span class="n">nex_out_2_mask</span> <span class="o">=</span> <span class="n">nex_out_1</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_mask.nex&#39;</span>
    <span class="n">mask_nex2</span><span class="p">(</span><span class="n">nex_out_1</span><span class="p">,</span> <span class="n">nex_out_2_mask</span><span class="p">)</span> 

    <span class="c1"># Trim alignment.</span>
    <span class="c1">#nex_out_3_trim = nex_out_2_mask.rsplit(&#39;_&#39;, 1)[0] + &#39;_trim.nex&#39;</span>
    <span class="c1">#trim_nex(nex_out_2_mask, nex_out_3_trim)</span>
    <span class="n">trim_nex</span><span class="p">(</span><span class="n">nex_out_2_mask</span><span class="p">,</span> <span class="n">outnexpath</span><span class="p">)</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_1</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_2</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">musclestdoutname</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">nex_out_1</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_sequence_comparison_dict"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.get_sequence_comparison_dict">[docs]</a><span class="k">def</span> <span class="nf">get_sequence_comparison_dict</span><span class="p">(</span><span class="n">inali</span><span class="p">,</span> <span class="n">score_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes an alignment in nexus format and determines if the last two</span>
<span class="sd">    sequences overlap, etc.</span>

<span class="sd">    Overlap could be defined in various ways, depending on what is relevant...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Delete extra lines in input nexus file, if present, because biopython cannot</span>
    <span class="c1"># read nexus alignments with these extra lines.</span>
    <span class="n">delete_extra_mesquite_lines</span><span class="p">(</span><span class="n">inali</span><span class="p">)</span>

    <span class="c1"># Initiate definitions of relevant variables.</span>
    <span class="n">aligned_residues_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">identical_residues_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">similar_not_ident_residues_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num_continuous_identical_spans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">length_of_longest_identical_span</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Extract the relevant information from the alignment file and use to</span>
    <span class="c1"># assign values to variables.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inali</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="c1"># Check that the input file has the filename extension &quot;.nex&quot;.</span>
        <span class="k">assert</span> <span class="n">inali</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.nex&#39;</span><span class="p">),</span> <span class="s2">&quot;Error: Input file name must have the</span><span class="se">\</span>
<span class="s2"> extension &#39;.nex&#39;.&quot;</span>

        <span class="c1"># Read the alignment file.</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>

        <span class="c1"># get a list of columns as strings in the original alignment.</span>
        <span class="n">seq_len</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">alignment</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_len</span><span class="p">)]</span> 

        <span class="c1"># Count columns where the last two sequences have aligned residues, and</span>
        <span class="c1"># where they have identical residues, and where they have similar but</span>
        <span class="c1"># not identical residues.</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">last_two</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">last_two</span><span class="p">:</span>
                <span class="n">aligned_residues_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">identical_residues_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">get_similarity_score</span><span class="p">(</span><span class="n">last_two</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">score_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">similar_not_ident_residues_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Get info about continuous spans of identical residues.</span>
        <span class="n">seq2_spans_of_identical_res</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_identical</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">cur_span</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">col_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last_col_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">col_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">last_two</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">aa1</span> <span class="o">=</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">aa2</span> <span class="o">=</span> <span class="n">last_two</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
            <span class="c1"># Ignore positions where there are gaps in both sequences.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">aa1</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">aa2</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>

                <span class="c1"># Determine whether the position is identical.</span>
                <span class="n">identical</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">aa1</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">aa2</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                    <span class="n">identical</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Add to existing span or restart a span as necessary.</span>

                <span class="k">if</span> <span class="n">identical</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">prev_identical</span><span class="p">:</span>
                        <span class="c1"># Add residue to existing span of identical residues.</span>
                        <span class="n">cur_span</span> <span class="o">=</span> <span class="n">cur_span</span> <span class="o">+</span> <span class="n">aa2</span>

                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">prev_identical</span><span class="p">:</span>
                        <span class="c1"># Restart a span of identical residues.</span>
                        <span class="n">cur_span</span> <span class="o">=</span> <span class="n">aa2</span>

                    <span class="k">if</span> <span class="n">col_num</span> <span class="o">==</span> <span class="n">last_col_num</span><span class="p">:</span>
                        <span class="c1"># If on the last residue, then it&#39;s the end of the</span>
                        <span class="c1"># span, so add to the list.</span>
                        <span class="n">seq2_spans_of_identical_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_span</span><span class="p">)</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">identical</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">prev_identical</span><span class="p">:</span>
                        <span class="c1"># Then reached end of a span.</span>
                        <span class="c1"># Add previous span of identical residues to list.</span>
                        <span class="k">if</span> <span class="n">col_num</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">seq2_spans_of_identical_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_span</span><span class="p">)</span>

                <span class="c1"># Assign current value to &quot;previous&quot; variable.</span>
                <span class="n">prev_identical</span> <span class="o">=</span> <span class="n">identical</span>

            <span class="c1"># Account for possibility that sequences are identical and the</span>
            <span class="c1"># alignment does not end in a position where the sequences have</span>
            <span class="c1"># aligned residues (both are gaps).</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col_num</span> <span class="o">==</span> <span class="n">last_col_num</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cur_span</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                        <span class="n">seq2_spans_of_identical_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_span</span><span class="p">)</span>

        <span class="c1"># Determine relevant information from list of identical spans.</span>
        <span class="n">num_continuous_identical_spans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq2_spans_of_identical_res</span><span class="p">)</span>
        <span class="n">length_of_longest_identical_span</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">seq2_spans_of_identical_res</span><span class="p">,</span>\
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Calculate percent identity.</span>
    <span class="n">percent_identity</span> <span class="o">=</span> <span class="p">(</span><span class="n">identical_residues_count</span><span class="o">/</span><span class="n">aligned_residues_count</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>

    <span class="c1"># Calculate percent similarity (not counting identical positions).</span>
    <span class="n">percent_similarity</span> <span class="o">=</span> <span class="p">(</span><span class="n">similar_not_ident_residues_count</span><span class="o">/</span><span class="n">aligned_residues_count</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>

    <span class="c1"># Calculate percent similarity + identity.</span>
    <span class="n">percent_similarity_plus_identity</span> <span class="o">=</span> <span class="p">((</span><span class="n">identical_residues_count</span> <span class="o">+</span> <span class="n">similar_not_ident_residues_count</span><span class="p">)</span><span class="o">/</span><span class="n">aligned_residues_count</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>

    <span class="c1"># Calculate gene model redundancy index value.</span>

    <span class="c1">#gene_model_redundancy_index =\</span>
    <span class="c1">#(identical_residues_count * length_of_longest_identical_span)\</span>
    <span class="c1">#    / (1 + (similar_not_ident_residues_count * num_continuous_identical_spans))</span>

    <span class="c1">#gene_model_redundancy_index =\</span>
    <span class="c1">#(identical_residues_count * length_of_longest_identical_span)\</span>
    <span class="c1">#    / ((1 + similar_not_ident_residues_count) * num_continuous_identical_spans)</span>

    <span class="c1">#gene_model_redundancy_index =\</span>
    <span class="c1">#(identical_residues_count + length_of_longest_identical_span)\</span>
    <span class="c1">#    / ((1 + similar_not_ident_residues_count) + num_continuous_identical_spans)</span>

    <span class="c1">#gene_model_redundancy_index =\</span>
    <span class="c1">#((aligned_residues_count - similar_not_ident_residues_count)*100)\</span>
    <span class="c1">#    / aligned_residues_count </span>

    <span class="c1">#gene_model_redundancy_index =\</span>
    <span class="c1">#((aligned_residues_count - similar_not_ident_residues_count)\</span>
    <span class="c1">#    / aligned_residues_count) + length_of_longest_identical_span </span>

    <span class="c1">#gene_model_redundancy_index =\</span>
    <span class="c1">#(identical_residues_count +\</span>
    <span class="c1">#        (length_of_longest_identical_span/(identical_residues_count)))\</span>
    <span class="c1">#    / ((1 + similar_not_ident_residues_count) +\</span>
    <span class="c1">#            (num_continuous_identical_spans\</span>
    <span class="c1">#        /identical_residues_count))</span>

    <span class="n">w1</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">w3</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">w4</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">gene_model_redundancy_index</span> <span class="o">=</span>\
        <span class="p">(</span><span class="n">identical_residues_count</span><span class="o">/</span><span class="n">aligned_residues_count</span><span class="p">)</span><span class="o">*</span><span class="n">w1</span> \
        <span class="o">-</span> <span class="p">(</span><span class="n">similar_not_ident_residues_count</span><span class="o">/</span><span class="n">aligned_residues_count</span><span class="p">)</span><span class="o">*</span><span class="n">w2</span> \
        <span class="o">+</span> <span class="p">(</span><span class="n">length_of_longest_identical_span</span><span class="o">/</span><span class="n">aligned_residues_count</span><span class="p">)</span><span class="o">*</span><span class="n">w3</span> \
        <span class="o">-</span> <span class="p">(</span><span class="n">num_continuous_identical_spans</span><span class="o">/</span><span class="n">aligned_residues_count</span><span class="p">)</span><span class="o">*</span><span class="n">w4</span> 



    <span class="c1"># Construct dictionary with info to return.</span>
    <span class="n">info_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;aligned_residues_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aligned_residues_count</span>
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;identical_residues_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">identical_residues_count</span>
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;percent_identity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">percent_identity</span> 
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;similar_not_ident_residues_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">similar_not_ident_residues_count</span>
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;percent_similarity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">percent_similarity</span>
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;percent_simlarity_plus_identity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">percent_similarity_plus_identity</span>
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;num_continuous_identical_spans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_continuous_identical_spans</span>
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;length_of_longest_identical_span&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">length_of_longest_identical_span</span>
    <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;gene_model_redundancy_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gene_model_redundancy_index</span>

    <span class="c1"># Return count tuple.    </span>
    <span class="k">return</span> <span class="n">info_dict</span></div>


<div class="viewcode-block" id="get_all_comparison_output_filepath"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.get_all_comparison_output_filepath">[docs]</a><span class="k">def</span> <span class="nf">get_all_comparison_output_filepath</span><span class="p">(</span><span class="n">outdir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define path for output file (csv format) that lists all sequence</span>
<span class="sd">    comparisons made, and their details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;0_all_sequence_comparisons.csv&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_redun_model_recursively"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.find_redun_model_recursively">[docs]</a><span class="k">def</span> <span class="nf">find_redun_model_recursively</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">cur_ali_num</span><span class="p">,</span> <span class="n">inali</span><span class="p">,</span> <span class="n">ranked_seq_objs</span><span class="p">,</span>
        <span class="n">redundant_gene_model_dict</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">metric_value_minimum</span><span class="p">,</span>
        <span class="n">minimum_percent_similarity</span><span class="p">,</span> <span class="n">extra_info_dict</span><span class="p">,</span> <span class="n">overlap_required</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursively process sequence objects, classifying them into groups of</span>
<span class="sd">    redundant predictions for single loci/alleles.</span>

<span class="sd">            info_tuple = (index,</span>
<span class="sd">                          acc,</span>
<span class="sd">                          seq_obj,</span>
<span class="sd">                          evalue, </span>
<span class="sd">                          program,</span>
<span class="sd">                          percent_len,</span>
<span class="sd">                          hit_range,</span>
<span class="sd">                          actual_acc,</span>
<span class="sd">                          sequence_filename</span>
<span class="sd">                          )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Take the top hit as a representative of a true unique locus.</span>
    <span class="n">top_hit_seq_obj</span> <span class="o">=</span> <span class="n">ranked_seq_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


    <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">top_hit_seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>\
        <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">top_hit_seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>\
        <span class="s1">&#39;likely represents a unique (paralogous) gene locus (see alignment &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_ali_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;); &#39;</span>

    <span class="c1"># Remove top hit sequence object from list.</span>
    <span class="n">ranked_seq_objs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">top_hit_seq_obj</span><span class="p">)</span>

    <span class="c1"># Align it to the HMM alignment (using profile-profile alignment).</span>
    <span class="n">ali_plus_top_seq</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_ali_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span><span class="p">)</span>
    <span class="n">cur_ali_num</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">add_seq_to_alignment2</span><span class="p">(</span><span class="n">top_hit_seq_obj</span><span class="p">,</span> <span class="n">inali</span><span class="p">,</span> <span class="n">ali_plus_top_seq</span><span class="p">)</span>

    <span class="c1"># Print input sequence object ids.</span>
    <span class="n">ranked_seq_accs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ranked_seq_objs</span><span class="p">:</span>
        <span class="n">ranked_seq_accs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    
    <span class="c1"># For each subsequent hit: </span>
    <span class="n">acc_for_objs_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">seq_obj</span> <span class="ow">in</span> <span class="n">ranked_seq_objs</span><span class="p">:</span>
        <span class="c1"># Get sequence object accessions.</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">seq_obj</span><span class="o">.</span><span class="n">id</span>

        <span class="c1"># Align to the HMM alignment plus top hit.</span>
        <span class="n">ali_plus_top_seq_plus_1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_ali_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span><span class="p">)</span>
        <span class="n">cur_ali_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">add_seq_to_alignment2</span><span class="p">(</span><span class="n">seq_obj</span><span class="p">,</span> <span class="n">ali_plus_top_seq</span><span class="p">,</span> <span class="n">ali_plus_top_seq_plus_1</span><span class="p">)</span>

        <span class="c1"># Get a dataframe for interpreting amino acid similarity in alignment.</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">get_score_dataframe_from_file</span><span class="p">(</span>\
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)),</span> <span class="s1">&#39;blosum62.csv&#39;</span><span class="p">))</span>

        <span class="c1"># Determine whether sequences overlap significantly.</span>
        <span class="n">sig_overlap</span> <span class="o">=</span> <span class="n">get_sig_overlap</span><span class="p">(</span><span class="n">ali_plus_top_seq_plus_1</span><span class="p">,</span> <span class="n">score_df</span><span class="p">)</span>

        <span class="c1"># If no significant overlap, then note as not necessarily represenative of a</span>
        <span class="c1"># different locus from the current &quot;top hit&quot;.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sig_overlap</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">overlap_required</span><span class="p">:</span>
                <span class="c1"># Record lack of overlap.</span>
                <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>\
                <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;No significant overlap &#39;</span> <span class="o">+</span>\
                <span class="s1">&#39;in alignment with sequence &#39;</span> <span class="o">+</span> <span class="n">top_hit_seq_obj</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span>\
                <span class="s1">&#39; therefore cannot confirm that this represents a distinct&#39;</span> <span class="o">+</span>\
                <span class="s1">&#39; (paralogous) gene locus (see alignment &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_ali_num</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;);&#39;</span>

                <span class="c1"># Remove sequence object from list (because not necessarily</span>
                <span class="c1"># representative of a paralogous locus distinct from higher-ranking</span>
                <span class="c1"># hits).</span>
                <span class="n">acc_for_objs_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="c1"># If significant overlap, get percent identity to decide whether the</span>
        <span class="c1"># sequence is representative of a different locus from the current &quot;top</span>
        <span class="c1"># hit&quot;.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Determine information about similarity between the sequences in the</span>
            <span class="c1"># alignment (would be more efficient if this was done only after it is</span>
            <span class="c1"># determined that they do overlap significantly).</span>
            <span class="n">info_dict</span> <span class="o">=</span> <span class="n">get_sequence_comparison_dict</span><span class="p">(</span><span class="n">ali_plus_top_seq_plus_1</span><span class="p">,</span>
                    <span class="n">score_df</span><span class="p">)</span>

            <span class="c1"># Contents of dictionary:</span>
            <span class="c1">#info_dict[&#39;aligned_residues_count&#39;] = aligned_residues_count</span>
            <span class="c1">#info_dict[&#39;identical_residues_count&#39;] = identical_residues_count</span>
            <span class="c1">#info_dict[&#39;percent_identity&#39;] = percent_identity </span>
            <span class="c1">#info_dict[&#39;similar_not_ident_residues_count&#39;] = similar_not_ident_residues_count</span>
            <span class="c1">#info_dict[&#39;percent_similarity&#39;] = percent_similarity</span>
            <span class="c1">#info_dict[&#39;percent_simlarity_plus_identity&#39;] = percent_similarity_plus_identity</span>
            <span class="c1">#info_dict[&#39;num_continuous_identical_spans&#39;] = num_continuous_identical_spans</span>
            <span class="c1">#info_dict[&#39;length_of_longest_identical_span&#39;] = length_of_longest_identical_span</span>
            <span class="c1">#info_dict[&#39;gene_model_redundancy_index&#39;] = gene_model_redundancy_index</span>

            <span class="c1"># Record relevant info to output file with all comparisons</span>
            <span class="c1"># (separate from main analysis).</span>
            <span class="n">outputfile</span> <span class="o">=</span> <span class="n">get_all_comparison_output_filepath</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputfile</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
                <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">top_hit_seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                  <span class="n">acc</span><span class="p">,</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;aligned_residues_count&#39;</span><span class="p">]),</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;identical_residues_count&#39;</span><span class="p">]),</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;percent_identity&#39;</span><span class="p">]),</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;similar_not_ident_residues_count&#39;</span><span class="p">]),</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;percent_similarity&#39;</span><span class="p">]),</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;num_continuous_identical_spans&#39;</span><span class="p">]),</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;length_of_longest_identical_span&#39;</span><span class="p">]),</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;gene_model_redundancy_index&#39;</span><span class="p">]),</span>
                                  <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">ali_plus_top_seq_plus_1</span><span class="p">),</span>
                                  <span class="n">ali_plus_top_seq_plus_1</span><span class="p">,</span>
                                  <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]</span>
                                  <span class="p">))</span>

            <span class="c1"># Decide whether criterion for classifying gene models/predictions</span>
            <span class="c1"># as redundant is met.</span>
            <span class="n">criterion_met</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">metric_value</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Determine value of relevant metric.</span>
            <span class="k">assert</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;percent_identity&#39;</span><span class="p">,</span>\
                    <span class="s1">&#39;gene_model_redundancy_index&#39;</span><span class="p">],</span> <span class="s2">&quot;&quot;&quot;Invalid metric name</span>
<span class="s2">                    provided.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metric_name</span> <span class="o">==</span> <span class="s1">&#39;percent_identity&#39;</span><span class="p">:</span>
                <span class="n">metric_value</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;percent_identity&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">metric_name</span> <span class="o">==</span> <span class="s1">&#39;gene_model_redundancy_index&#39;</span><span class="p">:</span>
                <span class="n">metric_value</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;gene_model_redundancy_index&#39;</span><span class="p">]</span>
            <span class="c1"># Determine whether criterion met.</span>
            <span class="k">if</span> <span class="n">metric_value</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metric_value_minimum</span><span class="p">):</span>
                <span class="n">criterion_met</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Record percent comparison metric to current &quot;top hit&quot;.</span>
            <span class="n">comparison_string1</span> <span class="o">=</span>\
            <span class="n">metric_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">metric_value</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; in alignment with sequence &#39;</span> <span class="o">+</span> <span class="n">top_hit_seq_obj</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>\
            <span class="s1">&#39;(longest identical span &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;length_of_longest_identical_span&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; residues)&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
            <span class="c1"># Add comparison string to full string.</span>
            <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">comparison_string1</span>
    
            <span class="c1"># If criterion met, then classify the sequence as redundant with the top</span>
            <span class="c1"># hit.</span>
            <span class="k">if</span> <span class="n">criterion_met</span><span class="p">:</span>
                <span class="c1"># classify as a redundant to top hit.</span>
                <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>\
                <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;therefore redundant &#39;</span> <span class="o">+</span>\
                <span class="s1">&#39;with it &#39;</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Keep sequence object in list for next recursion.</span>
                <span class="c1"># classify as a redundant to top hit.</span>
                <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>\
                <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;therefore not redundant &#39;</span> <span class="o">+</span>\
                <span class="s1">&#39;with it &#39;</span>

            <span class="c1"># Note alignment file name.</span>
            <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>\
            <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;(see alignment </span><span class="si">%s</span><span class="s1">); &#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_ali_num</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1">## Check whether there is overlap with existing gene models in the</span>
            <span class="c1">## corresponding GFF file (if tblastn hit).</span>
            <span class="c1">## Get overlapping entries (genes) from annotation file if available.</span>
            <span class="c1">#top_hit_search_program = extra_info_dict[top_hit_seq_obj.id][4]</span>
            <span class="c1">#hit_search_program = extra_info_dict[acc][4]</span>
            <span class="c1">#overlapping_genes = []</span>
            <span class="c1">#if hit_search_program.startswith(&#39;tblastn&#39;): </span>
            <span class="c1">#    # Determine whether there is a relevant annotation file to</span>
            <span class="c1">#    # check in.</span>
            <span class="c1">#    annotation_file = None</span>
            <span class="c1">#    sequence_filename = extra_info_dict[acc][8]</span>
            <span class="c1">#    with open(settings.db_info_csv) as infh:</span>
            <span class="c1">#        df = pd.read_csv(infh)</span>
            <span class="c1">#        for index, row in df.iterrows():</span>
            <span class="c1">#            if row[&#39;Filename&#39;] == sequence_filename:</span>
            <span class="c1">#                annotation_file = row[&#39;Annotations file&#39;]</span>

            <span class="c1">#    # If there is an annotation file available, determine whether</span>
            <span class="c1">#    # the hit is at the same locus in the nucleotide sequence as</span>
            <span class="c1">#    # the peptide sequence hit.</span>
            <span class="c1">#    if annotation_file is not None:</span>
            <span class="c1">#        annotation_file_path = os.path.join(settings.dbdirpath,</span>
            <span class="c1">#                annotation_file)</span>

            <span class="c1">#        # Call function for getting IDs of overlapping genes.</span>
            <span class="c1">#        overlapping_genes =\</span>
            <span class="c1">#        get_overlapping_genes_from_gff3(annotation_file_path,</span>
            <span class="c1">#                extra_info_dict[acc][7], extra_info_dict[acc][6])</span>

            <span class="c1">## Add info to info text if the top hit that the current hit is</span>
            <span class="c1">## being compared to is a peptide sequence.</span>
            <span class="c1">#at_same_locus_as_top_hit = False</span>
            <span class="c1">#if not top_hit_search_program.startswith(&#39;tblastn&#39;):</span>
            <span class="c1">#    for i in overlapping_genes:</span>
            <span class="c1">#        top_hit_acc = top_hit_seq_obj.id</span>
            <span class="c1">#        # ***Note: This may not work for all gene ID/accession</span>
            <span class="c1">#        # nomenclature schemes.</span>
            <span class="c1">#        if i.startswith(top_hit_acc.rsplit(&#39;.&#39;, 1)[0]):</span>
            <span class="c1">#            # Add note to output text string.</span>
            <span class="c1">#            redundant_gene_model_dict[acc][2] =\</span>
            <span class="c1">#            redundant_gene_model_dict[acc][2] +\</span>
            <span class="c1">#            &#39;Overlaps with protein %s at gene locus %s, therefore redundant with it; &#39; % (top_hit_acc, i)</span>

            <span class="c1">#            at_same_locus_as_top_hit = True</span>

            <span class="c1">#            # Break the loop.</span>
            <span class="c1">#            break</span>

            <span class="c1"># Make the decision whether the current hit is redundant with the</span>
            <span class="c1"># top hit or not.</span>
            <span class="c1">#if at_same_locus_as_top_hit or criterion_met:</span>
            <span class="k">if</span> <span class="n">criterion_met</span><span class="p">:</span>
                <span class="c1"># Add accession to list for current &quot;top hit&quot; sequence.</span>
                <span class="k">if</span> <span class="n">acc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">top_hit_seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="mi">3</span><span class="p">]:</span>
                    <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">top_hit_seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>\
                            <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">top_hit_seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">acc</span><span class="p">]</span>

                <span class="c1"># Remove sequence object from list.</span>
                <span class="n">acc_for_objs_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

                <span class="c1"># Remove sequence object from list (this means that it</span>
                <span class="c1"># won&#39;t be considered a unique paralogous hit).</span>
                <span class="n">acc_for_objs_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq_obj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="c1"># Remove objects from the list.</span>
    <span class="k">for</span> <span class="n">acc</span> <span class="ow">in</span> <span class="n">acc_for_objs_to_remove</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ranked_seq_objs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">acc</span><span class="p">:</span>
                <span class="c1">#print(&#39;\tremoving: &#39; + ranked_seq_objs[i].id)</span>
                <span class="k">del</span> <span class="n">ranked_seq_objs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">break</span>


    <span class="c1"># Check that a not was made in the spreadsheet for each sequence removed. </span>
    <span class="c1">#...?</span>

    <span class="n">ranked_seq_accs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ranked_seq_objs</span><span class="p">:</span>
        <span class="n">ranked_seq_accs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    
    <span class="c1"># Iterate/recurse over the remaining sequences that were not redundant and</span>
    <span class="c1"># treat each in turn as a top hit, and consider remaining sequences as either</span>
    <span class="c1"># redundant with it, or potential paralogues.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranked_seq_objs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">find_redun_model_recursively</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">cur_ali_num</span><span class="p">,</span> <span class="n">inali</span><span class="p">,</span> <span class="n">ranked_seq_objs</span><span class="p">,</span>\
                <span class="n">redundant_gene_model_dict</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">metric_value_minimum</span><span class="p">,</span>\
                <span class="n">minimum_percent_similarity</span><span class="p">,</span> <span class="n">extra_info_dict</span><span class="p">,</span> <span class="n">overlap_required</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">redundant_gene_model_dict</span></div>


<div class="viewcode-block" id="count_paralogues"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.count_paralogues">[docs]</a><span class="k">def</span> <span class="nf">count_paralogues</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">fasta</span><span class="p">,</span> <span class="n">fwdeval</span><span class="p">,</span> <span class="n">identity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Manage input and output details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that there are no redundant sequence names or identical sequences in</span>
    <span class="c1"># the fasta file.</span>
    <span class="n">extra_text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\.copy$&#39;</span><span class="p">)</span>
    <span class="n">name_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seq_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">):</span>
        <span class="c1">#print(record.id)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">extra_text</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">name_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">seq_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">name_list</span><span class="p">)),</span> <span class="s2">&quot;&quot;&quot;Error: Redundant sequence</span>
<span class="s2">    names in input alignment.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">seq_list</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Warning: Identical sequences in input fasta records.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Rank sequences in the fasta file according to similarity to the HMM.</span>
    <span class="c1"># use rank_seqs_by_hmm()</span>
    <span class="n">ranked_seq_objs</span> <span class="o">=</span> <span class="n">rank_seqs_by_hmm</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">fasta</span><span class="p">)</span>


    <span class="c1"># Construct a dict of ids for true paralogues and ids for sequences that are</span>
    <span class="c1"># redundant with each.</span>
    <span class="n">redundant_gene_model_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Define an output directory for the results (alignments and summary csv file).</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y_%m_</span><span class="si">%d</span><span class="s2">_%H_%M_%S&quot;</span><span class="p">)</span>
    <span class="n">outdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fasta</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_paralogue_count_&#39;</span> <span class="o">+</span> <span class="n">timestamp</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>
    <span class="c1"># Add rank info to dict.</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">ranked_seq_objs</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">seq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[]]</span>
    <span class="c1"># Add sequence comparison info to dict.</span>
    <span class="c1">#print(&#39;\ninitial redundant_gene_model_dict: &#39; + str(redundant_gene_model_dict))</span>
    <span class="n">full_redundant_gene_model_dict</span> <span class="o">=</span> <span class="n">find_redun_model_recursively</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span>\
            <span class="n">ranked_seq_objs</span><span class="p">,</span> <span class="n">redundant_gene_model_dict</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">metric_value_minimum</span><span class="p">)</span>

    <span class="c1">#print(&#39;full_redundant_gene_model_dict: &#39; + str(full_redundant_gene_model_dict))</span>


    <span class="c1"># TEMPORARY:</span>
    <span class="c1"># Write assignments in readable format.</span>
    <span class="c1">#outfp = args.fasta + &#39;_paralogue_count.csv&#39;</span>
    <span class="n">outfp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;0_summary.csv&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="c1"># Write output csv header line.</span>
        <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;Sequence rank against HMM&#39;</span><span class="p">,</span> 
                          <span class="s1">&#39;Sequence accession&#39;</span><span class="p">,</span> 
                          <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">,</span> 
                          <span class="s1">&#39;Accessions for sequences that are redundant with the sequence&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]))</span> 
        <span class="c1"># Write content of redundancy dict.</span>
        <span class="n">key_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>\
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">key_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
                              <span class="n">key</span><span class="p">,</span>
                              <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">])</span>
                              <span class="p">)</span></div>


<div class="viewcode-block" id="get_seq_obj_x"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.get_seq_obj_x">[docs]</a><span class="k">def</span> <span class="nf">get_seq_obj_x</span><span class="p">(</span><span class="n">acc_list</span><span class="p">,</span> <span class="n">fastadir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take an accession and find the corresponding sequence in fasta file(s)</span>
<span class="sd">    in a given directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compile a list of sequence object.</span>
    <span class="n">seq_objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seq_obj_accs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">acc_list2</span> <span class="o">=</span> <span class="n">acc_list</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fastadir</span><span class="p">,</span> <span class="s1">&#39;*.fa&#39;</span><span class="p">)):</span>
        <span class="c1">#print(&#39;\t\t&#39; + f)</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
            <span class="c1">#print(&#39;\t\t\t&#39; + seq.id)</span>
            <span class="k">for</span> <span class="n">acc</span> <span class="ow">in</span> <span class="n">acc_list2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">acc</span><span class="p">:</span>
                    <span class="c1">#print(&#39;\t\t\tmatch&#39;)</span>
                    <span class="n">seq_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
                    <span class="n">seq_obj_accs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="k">break</span>

    <span class="c1">#print(acc_list)</span>
    <span class="c1">#print(seq_obj_accs)</span>

    <span class="c1"># Check that there are no redundant sequences found.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_obj_accs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc_list</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Redundant sequences in input</span>
<span class="s2">    sequence file(s).&quot;&quot;&quot;</span>

    <span class="c1"># Check that there are no missing sequences.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_obj_accs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc_list</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Missing sequences in input</span>
<span class="s2">    sequence file(s).&quot;&quot;&quot;</span>

    <span class="c1"># Re-order the list of sequence objects to match the order of corresponding</span>
    <span class="c1"># accessions in the input list.</span>
    <span class="n">ranked_seq_obj_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">acc</span> <span class="ow">in</span> <span class="n">acc_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">seq_objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">acc</span><span class="p">:</span>
                <span class="n">ranked_seq_obj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

    <span class="c1"># Return list.</span>
    <span class="k">return</span> <span class="n">ranked_seq_obj_list</span></div>


<div class="viewcode-block" id="get_seq_obj_x2"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.get_seq_obj_x2">[docs]</a><span class="k">def</span> <span class="nf">get_seq_obj_x2</span><span class="p">(</span><span class="n">acc_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a list of accessions and find the corresponding sequence in fasta file(s)</span>
<span class="sd">    in a given directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compile a list of sequence object.</span>
    <span class="c1">#seq_objs = []</span>
    <span class="n">seq_obj_accs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">acc_list2</span> <span class="o">=</span> <span class="n">acc_list</span>
    <span class="n">ranked_seq_obj_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">acc_list2</span><span class="p">:</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_seqs_from_fasta_db</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ranked_seq_obj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">id</span>
        <span class="n">seq_obj_accs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
    <span class="c1">#for f in glob.glob(os.path.join(fastadir, &#39;*.fa&#39;)):</span>
    <span class="c1">#    #print(&#39;\t\t&#39; + f)</span>
    <span class="c1">#    for seq in SeqIO.parse(f, &#39;fasta&#39;):</span>
    <span class="c1">#        #print(&#39;\t\t\t&#39; + seq.id)</span>
    <span class="c1">#        for acc in acc_list2:</span>
    <span class="c1">#            if seq.id == acc:</span>
    <span class="c1">#                #print(&#39;\t\t\tmatch&#39;)</span>
    <span class="c1">#                seq_objs.append(seq)</span>
    <span class="c1">#                seq_obj_accs.append(seq.id)</span>
    <span class="c1">#                break</span>

    <span class="c1">#print(acc_list)</span>
    <span class="c1">#print(seq_obj_accs)</span>

    <span class="c1"># Check that there are no redundant sequences found.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_obj_accs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc_list</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Redundant sequences in input</span>
<span class="s2">    sequence file(s).&quot;&quot;&quot;</span>

    <span class="c1"># Check that there are no missing sequences.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_obj_accs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc_list</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Missing sequences in input</span>
<span class="s2">    sequence file(s).&quot;&quot;&quot;</span>

    <span class="c1">## Re-order the list of sequence objects to match the order of corresponding</span>
    <span class="c1">## accessions in the input list.</span>
    <span class="c1">#ranked_seq_obj_list = []</span>
    <span class="c1">#for acc in acc_list:</span>
    <span class="c1">#    for seq in seq_objs:</span>
    <span class="c1">#        if seq.id == acc:</span>
    <span class="c1">#            ranked_seq_obj_list.append(seq)</span>

    <span class="c1"># Return list.</span>
    <span class="k">return</span> <span class="n">ranked_seq_obj_list</span></div>


<div class="viewcode-block" id="get_cur_ali_num"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.get_cur_ali_num">[docs]</a><span class="k">def</span> <span class="nf">get_cur_ali_num</span><span class="p">(</span><span class="n">alignmentdir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gets number of alignment with largest number in its filename.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_paths</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignmentdir</span><span class="p">,</span> <span class="s1">&#39;*.nex&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>\
            <span class="n">file_paths</span><span class="p">])</span></div>


<div class="viewcode-block" id="count_paralogues2"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.count_paralogues2">[docs]</a><span class="k">def</span> <span class="nf">count_paralogues2</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">alignmentdir</span><span class="p">,</span> <span class="n">fastadir</span><span class="p">,</span> <span class="n">fwdeval</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span>
        <span class="n">metric_value_minimum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Manage input and output details.</span>
<span class="sd">    fwdeval not used?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define timestamp.</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y_%m_</span><span class="si">%d</span><span class="s2">_%H_%M_%S&quot;</span><span class="p">)</span>

    <span class="c1"># Define an output directory for the results (alignments and summary csv file).</span>
    <span class="n">outdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">csv_file</span>  <span class="o">+</span> <span class="s1">&#39;_paralogue_count_&#39;</span> <span class="o">+</span> <span class="n">timestamp</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>


    <span class="c1">## Check that there are no redundant sequence names or identical sequences in</span>
    <span class="c1">## the alignment file.</span>
    <span class="c1">#extra_text = re.compile(r&#39;\.copy$&#39;)</span>
    <span class="c1">#name_list = []</span>
    <span class="c1">#seq_list = []</span>
    <span class="c1">#for record in AlignIO.read(alignment, &#39;nexus&#39;):</span>
    <span class="c1">#    #print(record.id)</span>
    <span class="c1">#    name = extra_text.sub(&#39;&#39;, record.id)</span>
    <span class="c1">#    name_list.append(name)</span>
    <span class="c1">#    seq = str(record.seq)</span>
    <span class="c1">#    seq_list.append(seq)</span>

    <span class="c1">#assert len(name_list) == len(set(name_list)), &quot;&quot;&quot;Error: Redundant sequence</span>
    <span class="c1">#names in input alignment.&quot;&quot;&quot;</span>

    <span class="c1">#if len(seq_list) != len(set(seq_list)):</span>
    <span class="c1">#    print(&#39;\nWarning: Identical sequences in input fasta records.\n&#39;)</span>


    <span class="c1"># Use pandas to parse the input csv (spreadsheet) file.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>

    <span class="c1"># Define a dictionary of relevant column labels (so I can change the title</span>
    <span class="c1"># that it looks for without changing the name that that tile is referred to</span>
    <span class="c1"># with). The input spreadsheet needs to have columns with these labels</span>
    <span class="c1"># (values).</span>
    <span class="n">column_header_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;query title&#39;</span><span class="p">:</span> <span class="s1">&#39;Protein name&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;alignment name&#39;</span><span class="p">:</span> <span class="s1">&#39;Alignment name&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;taxon name&#39;</span><span class="p">:</span> <span class="s1">&#39;Subject organism&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;accession&#39;</span><span class="p">:</span> <span class="s1">&#39;Positive hit accession&#39;</span>
                          <span class="p">}</span>
    <span class="c1">#&#39;rank&#39;: &#39;Hit rank&#39;,</span>

    <span class="c1"># New column labels (for new columns to be appended).</span>
    <span class="n">new_column_label_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Sequence rank against HMM&#39;</span><span class="p">,</span> 
                             <span class="s1">&#39;Sequence accession&#39;</span><span class="p">,</span> 
                             <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">,</span> 
                             <span class="s1">&#39;Accessions for sequences that are redundant with the sequence&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Represents an identifiably unique paralogue&#39;</span><span class="p">]</span>

    <span class="c1"># Initiate new dataframe with columns to be appended/joined to existing</span>
    <span class="c1"># dataframe.</span>
    <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span>

    <span class="c1"># Join constructed dataframe to input dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>

    <span class="c1"># Parse relevant info from spreadsheet, and construct additional columns to</span>
    <span class="c1"># append.</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">alignment_path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">acc_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prev_acc_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prev_query_title</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">prev_taxon_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">num_rows</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">rank</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Determine query title, taxon name, and hit accession for result in row.</span>
        <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;query title&#39;</span><span class="p">]]</span>
        <span class="n">taxon_name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;taxon name&#39;</span><span class="p">]]</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;accession&#39;</span><span class="p">]]</span>

        <span class="c1"># Restart rank counting as appropriate.</span>
        <span class="k">if</span> <span class="n">query_title</span> <span class="o">!=</span> <span class="n">prev_query_title</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">taxon_name</span> <span class="o">!=</span> <span class="n">prev_taxon_name</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Define alignment to use, and add accession to list or restart</span>
        <span class="c1"># accession list as appropriate.</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">alignment_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignmentdir</span><span class="p">,</span>\
                    <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;alignment name&#39;</span><span class="p">]])</span>
            <span class="n">prev_acc_list</span> <span class="o">=</span> <span class="n">acc_list</span>
            <span class="n">acc_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">acc</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">acc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;Row&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">query_title</span><span class="p">,</span> <span class="n">taxon_name</span><span class="p">]))</span>


        <span class="c1"># Process the accession (sequence) listed in the row, and add info to</span>
        <span class="c1"># output dataframe.</span>

        <span class="c1"># When appropriate, take a list of accessions, get corresponding</span>
        <span class="c1"># sequence objects, process these, and add information to appropriate</span>
        <span class="c1"># rows/fields in the dataframe.</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">==</span> <span class="n">num_rows</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Process preceding set of hits for (previous) query title.</span>

            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">num_rows</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Reached the end of the dataframe/spreadsheet, so have to set</span>
                <span class="c1"># current query title, etc, to prev.</span>
                <span class="n">prev_query_title</span> <span class="o">=</span> <span class="n">query_title</span>
                <span class="n">prev_alignment_path</span> <span class="o">=</span> <span class="n">alignment_path</span>
                <span class="n">prev_taxon_name</span> <span class="o">=</span> <span class="n">taxon_name</span>
                <span class="n">prev_acc_list</span> <span class="o">=</span> <span class="n">acc_list</span>

            <span class="c1"># Get list of sequence objects corresponding to list of accessions.</span>
            <span class="n">ranked_seq_objs</span> <span class="o">=</span> <span class="n">get_seq_obj_x</span><span class="p">(</span><span class="n">prev_acc_list</span><span class="p">,</span> <span class="n">fastadir</span><span class="p">)</span>

            <span class="c1"># Construct a dict of ids for true paralogues and ids for sequences that are</span>
            <span class="c1"># redundant with each.</span>
            <span class="n">redundant_gene_model_dict</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Add rank info to dict.</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">ranked_seq_objs</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">seq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[]]</span>

            <span class="c1"># get current alignment number so that it can pick up where it</span>
            <span class="c1"># started.</span>
            <span class="n">cur_ali_num</span> <span class="o">=</span> <span class="n">get_cur_ali_num</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span> 

            <span class="c1"># Add sequence comparison info to dict.</span>
            <span class="n">full_redundant_gene_model_dict</span> <span class="o">=</span>\
            <span class="n">find_redun_model_recursively</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">cur_ali_num</span><span class="p">,</span> <span class="n">alignment_path</span><span class="p">,</span>\
                    <span class="n">ranked_seq_objs</span><span class="p">,</span> <span class="n">redundant_gene_model_dict</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">metric_value_minimum</span><span class="p">)</span>

            <span class="c1">#print(&#39;full_redundant_gene_model_dict: &#39; + str(full_redundant_gene_model_dict))</span>


            <span class="c1"># Add info from dict to dataframe.</span>
            <span class="n">key_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>\
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">key_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Get index for row that info should be added to.</span>
                <span class="n">index_in_dataframe</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="n">key_num</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">num_rows</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">index_in_dataframe</span> <span class="o">=</span> <span class="n">index_in_dataframe</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Determine from dict whether the hit represents the first hit</span>
                <span class="c1"># for an identifiably unique paralogous gene locus.</span>
                <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;No&#39;</span>
                <span class="k">if</span> <span class="s1">&#39;represents a unique (paralogous) gene locus&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;Yes&#39;</span>

                <span class="c1"># Define dataframe values using info from dict.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Sequence rank against HMM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Sequence accession&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Accessions for sequences that are redundant with the sequence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Represents an identifiably unique paralogue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique</span>

        <span class="c1"># Define previous query title and alignment path for next run through loop.</span>
        <span class="n">prev_query_title</span> <span class="o">=</span> <span class="n">query_title</span>
        <span class="n">prev_alignment_path</span> <span class="o">=</span> <span class="n">alignment_path</span>
        <span class="n">prev_taxon_name</span> <span class="o">=</span> <span class="n">taxon_name</span>

    <span class="c1"># Write modified dataframe to output file path.</span>
    <span class="n">output_fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_out.csv&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_fp</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Results written to file:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">output_fp</span><span class="p">)</span>


    <span class="c1"># Visualize all comparisons to evaluate whether metric adequately</span>
    <span class="c1"># distinguished between sequences.</span>

    <span class="c1"># Get filepath for relevant output file. </span>
    <span class="n">outputfile</span> <span class="o">=</span> <span class="n">get_all_comparison_output_filepath</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span></div>

    <span class="c1"># Make histogram.</span>
    <span class="c1"># ...</span>


<div class="viewcode-block" id="get_overlapping_genes_from_gff3"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.get_overlapping_genes_from_gff3">[docs]</a><span class="k">def</span> <span class="nf">get_overlapping_genes_from_gff3</span><span class="p">(</span><span class="n">sql_database</span><span class="p">,</span> <span class="n">seq_id</span><span class="p">,</span> <span class="n">cluster_range</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to a gffutils SQL database (based on a gff3 file), the</span>
<span class="sd">    sequence id for the relevant sequnce referred to in the gff file, and a</span>
<span class="sd">    range (coordinates in the form of a list object with two items). And,</span>
<span class="sd">    return IDs for any genes that fall within that range on the sequence. This</span>
<span class="sd">    is for determining whether tblastn hits correspond to already annotated</span>
<span class="sd">    protein sequences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parse database.</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">gffutils</span><span class="o">.</span><span class="n">FeatureDB</span><span class="p">(</span><span class="n">sql_database</span><span class="p">,</span> <span class="n">keep_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Find any genes that fall within the range (or overlap at</span>
    <span class="c1"># all).</span>
    <span class="n">overlapping_entries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">region</span><span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="p">(</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">cluster_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cluster_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                    <span class="n">completely_within</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">featuretype</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span>
                                    <span class="p">))</span>

    <span class="c1"># Get gene IDs.</span>
    <span class="n">overlap_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">overlapping_entries</span><span class="p">:</span>
        <span class="n">overlap_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="c1"># Return list of IDs.</span>
    <span class="k">return</span> <span class="n">overlap_ids</span></div>


<div class="viewcode-block" id="count_paralogues3"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.count_paralogues3">[docs]</a><span class="k">def</span> <span class="nf">count_paralogues3</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">metric_value_minimum</span><span class="p">,</span>
        <span class="n">minimum_percent_similarity</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">overlap_required</span><span class="p">,</span>
        <span class="n">minimum_length_of_query_to_be_distinct_paralogue</span><span class="p">,</span>
        <span class="n">minimum_percent_length_of_query_to_be_distinct_paralogue</span><span class="p">,</span>
        <span class="n">remove_tblastn_hits_at_annotated_loci</span><span class="p">,</span> <span class="n">outfp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Manage input and output details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define unique identifier string for this analysis.</span>
    <span class="n">paralogue_count_id</span> <span class="o">=</span> <span class="s1">&#39;paralogue_count_&#39;</span> <span class="o">+</span> <span class="n">timestamp</span>

    <span class="c1"># Define directory to acces with alignments.</span>
    <span class="n">alignmentdir</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">querydirpath</span>

    <span class="c1"># Define an output directory for the results (alignments and summary csv file).</span>
    <span class="n">outdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">csv_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">paralogue_count_id</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>

    <span class="c1"># Make a file for recording all sequence comparisons made.</span>
    <span class="n">outputfile</span> <span class="o">=</span> <span class="n">get_all_comparison_output_filepath</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputfile</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="c1"># Write header line.</span>
        <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;ID for sequence 1&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;ID for sequence 2&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;aligning residues position count&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;identical position count&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;percent_identity&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;similar (not identical) position count&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;percent_similarity&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;num_continuous_identical_spans&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;length_of_longest_identical_span&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_model_redundancy_index&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;alignment file name&#39;</span>
                          <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]</span>
                          <span class="p">))</span>


    <span class="c1">## Check that there are no redundant sequence names or identical sequences in</span>
    <span class="c1">## the alignment file.</span>
    <span class="c1">#extra_text = re.compile(r&#39;\.copy$&#39;)</span>
    <span class="c1">#name_list = []</span>
    <span class="c1">#seq_list = []</span>
    <span class="c1">#for record in AlignIO.read(alignment, &#39;nexus&#39;):</span>
    <span class="c1">#    #print(record.id)</span>
    <span class="c1">#    name = extra_text.sub(&#39;&#39;, record.id)</span>
    <span class="c1">#    name_list.append(name)</span>
    <span class="c1">#    seq = str(record.seq)</span>
    <span class="c1">#    seq_list.append(seq)</span>

    <span class="c1">#assert len(name_list) == len(set(name_list)), &quot;&quot;&quot;Error: Redundant sequence</span>
    <span class="c1">#names in input alignment.&quot;&quot;&quot;</span>

    <span class="c1">#if len(seq_list) != len(set(seq_list)):</span>
    <span class="c1">#    print(&#39;\nWarning: Identical sequences in input fasta records.\n&#39;)</span>


    <span class="c1"># Use pandas to parse the input csv (spreadsheet) file.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reading input csv file into a pandas dataframe.&#39;</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Define a dictionary of relevant column labels (so I can change the title</span>
    <span class="c1"># that it looks for without changing the name that that tile is referred to</span>
    <span class="c1"># with). The input spreadsheet needs to have columns with these labels</span>
    <span class="c1"># (values).</span>
    <span class="c1">#column_header_dict = {&#39;query title&#39;: &#39;Protein name&#39;,</span>
    <span class="c1">#                      &#39;alignment name&#39;: &#39;Alignment name&#39;,</span>
    <span class="c1">#                      &#39;taxon name&#39;: &#39;Subject organism&#39;,</span>
    <span class="c1">#                      &#39;accession&#39;: &#39;Positive hit accession&#39;</span>
    <span class="c1">#                      }</span>

    <span class="c1"># Updated for AMOEBAE.</span>
    <span class="n">column_header_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;query title&#39;</span><span class="p">:</span> <span class="s1">&#39;Query title&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;alignment name&#39;</span><span class="p">:</span> <span class="s1">&#39;Alignment for sequence comparison&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;taxon name&#39;</span><span class="p">:</span> <span class="s1">&#39;Subject database species (if applicable)&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;database filename&#39;</span><span class="p">:</span> <span class="s1">&#39;Subject database file&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;positive or not&#39;</span><span class="p">:</span> <span class="s1">&#39;Collective interpretation of reverse search results&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;accession&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit accession&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;hit rank&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit rank&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;subseq coordinates&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;program&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward search method&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;evalue&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit E-value (top HSP)&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;hit length&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit length&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;percent length&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit length as a percentage of query length&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;seq&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;subseq&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit subsequence(s) that align(s) to query&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;seq descr&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit description&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;subseq descr&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit description of subsequence(s) that align(s) to query&#39;</span>
                          <span class="p">}</span>
    <span class="c1">#&#39;rank&#39;: &#39;Hit rank&#39;,</span>

    <span class="c1"># New column labels (for new columns to be appended).</span>
    <span class="c1">#new_column_label_list = [&#39;Sequence rank against HMM&#39;, </span>
    <span class="c1">#                         &#39;Sequence accession&#39;, </span>
    <span class="c1">#                         &#39;Comparison with other positive hits in the same genome&#39;, </span>
    <span class="c1">#                         &#39;Accessions for sequences that are redundant with the sequence&#39;,</span>
    <span class="c1">#                         &#39;Represents an identifiably unique paralogue&#39;]</span>
    <span class="n">new_column_label_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Does not have same ID or locus as another hit&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Meets length criteria&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">,</span> 
                             <span class="s1">&#39;Accessions for sequences that are redundant with the sequence&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Represents an identifiably unique paralogue&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Paralogue name&#39;</span><span class="p">]</span>

    <span class="c1"># Check that a column containing the name of the alignment to use is</span>
    <span class="c1"># present in the input file.</span>
    <span class="k">assert</span> <span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;alignment name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Could</span>
<span class="s2">    not identify column containing name(s) of alignment(s) to use in input csv</span>
<span class="s2">    file </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">csv_file</span>

    <span class="c1"># Initiate new dataframe with columns to be appended/joined to existing</span>
    <span class="c1"># dataframe.</span>
    <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span>

    <span class="c1"># Join constructed dataframe to input dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>

    <span class="c1"># Get sets of indexes for which summaries should be made, organized by</span>
    <span class="c1"># query title and taxon combinations as well as corresponding relevant information.</span>
    <span class="n">index_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;positive or not&#39;</span><span class="p">]]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="c1"># Ignore negative hits.</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get info from row.</span>
            <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;query title&#39;</span><span class="p">]]</span>
            <span class="n">taxon_name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;taxon name&#39;</span><span class="p">]]</span>
            <span class="c1">#acc = row[column_header_dict[&#39;accession&#39;]] + &#39;(fwdhit&#39; +\</span>
            <span class="c1">#        str(row[column_header_dict[&#39;hit rank&#39;]]) + &#39;)&#39;</span>
            <span class="n">alignment_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignmentdir</span><span class="p">,</span>\
                            <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;alignment name&#39;</span><span class="p">]])</span>
            <span class="n">evalue</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;evalue&#39;</span><span class="p">]]</span>
            <span class="n">percent_len</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;percent length&#39;</span><span class="p">]]</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;hit length&#39;</span><span class="p">]]</span>

            <span class="c1"># Get hit range.</span>
            <span class="n">hit_range</span> <span class="o">=</span>\
            <span class="n">get_hit_range_from_hsp_ranges</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;subseq coordinates&#39;</span><span class="p">]])</span>

            <span class="c1"># Get sequence using different sources for prot vs. nucl data.</span>
            <span class="n">program</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;program&#39;</span><span class="p">]]</span>
            <span class="n">description</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">actual_acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;accession&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">program</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;tblastn&#39;</span><span class="p">):</span>
                <span class="c1"># Append hit range to accession for tblastn, to distinguish</span>
                <span class="c1"># between different clusters of HSPs in the same</span>
                <span class="c1"># chromosome/scaffold.</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;accession&#39;</span><span class="p">]]</span> <span class="o">+</span>\
                    <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;..&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hit_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
                <span class="n">description</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;subseq descr&#39;</span><span class="p">]]</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;subseq&#39;</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;accession&#39;</span><span class="p">]]</span>
                <span class="n">description</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;seq descr&#39;</span><span class="p">]]</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;seq&#39;</span><span class="p">]]</span>
            <span class="n">seq_obj</span> <span class="o">=</span> <span class="n">get_seq_obj_from_srch_res_csv_info</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>

            <span class="n">sequence_filename</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;database filename&#39;</span><span class="p">]]</span>

            <span class="c1"># Integrate information into dict.</span>
            <span class="n">combo</span> <span class="o">=</span> <span class="p">(</span><span class="n">query_title</span><span class="p">,</span> <span class="n">taxon_name</span><span class="p">)</span>
            <span class="c1"># This info tuple is used later as well...</span>
            <span class="n">info_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span>
                          <span class="n">acc</span><span class="p">,</span>
                          <span class="n">seq_obj</span><span class="p">,</span>
                          <span class="n">evalue</span><span class="p">,</span> 
                          <span class="n">program</span><span class="p">,</span>
                          <span class="n">percent_len</span><span class="p">,</span>
                          <span class="n">hit_range</span><span class="p">,</span>
                          <span class="n">actual_acc</span><span class="p">,</span>
                          <span class="n">sequence_filename</span><span class="p">,</span>
                          <span class="n">length</span>
                          <span class="p">)</span>
            <span class="k">if</span> <span class="n">combo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># Initiate a new key in dict.</span>
                <span class="n">index_dict</span><span class="p">[</span><span class="n">combo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">alignment_path</span><span class="p">,</span> <span class="p">[</span><span class="n">info_tuple</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">## Ignore sequences with redundant accessions.</span>
                <span class="c1">#if acc in [x[1] for x in index_dict[combo][1]]: </span>
                <span class="c1">#    df.at[index,\</span>
                <span class="c1">#        &#39;Comparison with other positive hits in the same genome&#39;]\</span>
                <span class="c1">#        = &#39;(Accession (or coordinates) redundant with previous hit(s))&#39;</span>

                <span class="c1">## Ignore hits that are below the minimum percent length.</span>
                <span class="c1">## (Should this be done at a later stage so that it can be</span>
                <span class="c1">## determined whether it is redundant with a protein model due</span>
                <span class="c1">## to location in the genome?)</span>
                <span class="c1">#elif int(percent_len) &lt; settings.minimum_percent_length_of_query_to_be_distinct_paralogue:</span>
                <span class="c1">#    df.at[index, &#39;Comparison with other positive hits in the same genome&#39;] =\</span>
                <span class="c1">#    &#39;(Hit length is less than %s percent of query length, therefore too short to be a potential distinct paralogue)&#39;\</span>
                <span class="c1">#            % str(settings.minimum_percent_length_of_query_to_be_distinct_paralogue)</span>
                <span class="c1">## Ignore hits that are below the absolute minimum length.</span>
                <span class="c1">#...</span>

                <span class="c1">#else:</span>
                <span class="n">index_dict</span><span class="p">[</span><span class="n">combo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">alignment_path</span><span class="p">,</span> <span class="n">index_dict</span><span class="p">[</span><span class="n">combo</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>\
                        <span class="o">+</span> <span class="p">[</span><span class="n">info_tuple</span><span class="p">]]</span>


    <span class="c1"># Make the values in the &#39;Does not have same ID or locus as another</span>
    <span class="c1"># hit&#39; and &#39;Meets length criteria&#39; columns the same as for the</span>
    <span class="c1"># &#39;positive or not&#39; column to start with.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;positive or not&#39;</span><span class="p">]]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="c1"># Ignore negative hits.</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Change values in the appropriate columns to &#39;+&#39;.</span>
            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;Does not have same ID or locus as another hit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;Meets length criteria&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>


    <span class="c1"># Iterate over relevant information and feed it into paralogue_counter</span>
    <span class="c1"># module for processing, and then put the relevant results in the right place</span>
    <span class="c1"># in the dataframe.</span>
    <span class="n">total_combo_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">combo_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">index_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">combo_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Print progress.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s2">Finding redundant sequences for query title </span><span class="si">%s</span><span class="s2"> and taxon </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">            (</span><span class="si">%s</span><span class="s2"> of </span><span class="si">%s</span><span class="s2"> sets, </span><span class="si">%s</span><span class="s2"> percent complete)&quot;&quot;&quot;</span>\
            <span class="o">%</span> <span class="p">(</span><span class="n">combo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">combo_num</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">total_combo_count</span><span class="p">),</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">combo_num</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">total_combo_count</span><span class="p">))))</span>

        <span class="c1"># Sort hit info tuples into those for protein hits and those for</span>
        <span class="c1"># nucleotide hits.</span>
        <span class="n">all_tuples</span> <span class="o">=</span> <span class="n">index_dict</span><span class="p">[</span><span class="n">combo</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">prot_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nucl_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_tuples</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;tblastn&#39;</span><span class="p">):</span>
                <span class="n">nucl_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prot_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Sort the tuple lists by ascending E-value.</span>
        <span class="n">prot_tuples</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">prot_tuples</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">nucl_tuples</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nucl_tuples</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="c1"># Remove protein hits from the tuples if they have identical accessions</span>
        <span class="c1"># to higher-ranking hits.</span>
        <span class="n">reduced_prot_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hit_indexes_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prot_tuples</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">prot_tuples</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prot_tuples</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="c1"># Check whether they have the same filename and sequence ID.</span>
                    <span class="k">if</span> <span class="n">j</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="ow">and</span> <span class="n">j</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">[</span><span class="mi">7</span><span class="p">]:</span>
                        <span class="c1"># Check that the E-values are right.</span>
                        <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                            <span class="c1"># Mark the one with the lower or equivalent E-value for removal.</span>
                            <span class="n">hit_indexes_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                            <span class="c1"># Change value in column for ID or locus redundancy</span>
                            <span class="c1"># to &#39;-&#39;.</span>
                            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                <span class="s1">&#39;Does not have same ID or locus as another hit&#39;</span><span class="p">]</span>\
                                <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

                            <span class="c1"># Make a note in the spreadsheet, explaining why</span>
                            <span class="c1"># this hit was excluded.</span>
                            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span>\
                                <span class="o">=</span> <span class="s1">&#39;(This hit has the same ID as protein hit with ID: </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Remove the identified redundant tuples. </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hit_indexes_to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prot_tuples</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hit_indexes_to_remove</span><span class="p">:</span>
                    <span class="n">reduced_prot_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reduced_prot_tuples</span> <span class="o">=</span> <span class="n">prot_tuples</span>

        <span class="c1"># Remove nucleotide hits from the tuples, if they represent a gene</span>
        <span class="c1"># locus that encodes one of the protein hits, or optionally any</span>
        <span class="c1"># annotated gene.</span>
        <span class="n">reduced_nucl_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nucl_tuples_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prot_tuples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No protein hits to compare nucleotide hits to, so keep all</span>
            <span class="c1"># nucleotide hits.</span>
            <span class="n">reduced_nucl_tuples</span> <span class="o">=</span> <span class="n">nucl_tuples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Look for nucleotide hits that are redundant with protein hits.</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nucl_tuples</span><span class="p">:</span>
                <span class="c1"># Check whether there is overlap with existing gene models in the</span>
                <span class="c1"># corresponding GFF file (if tblastn hit).</span>
                <span class="c1"># Get overlapping entries (genes) from annotation file if available.</span>
                <span class="n">overlapping_genes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># Determine whether there is a relevant annotation file to</span>
                <span class="c1"># check in.</span>
                <span class="n">annotation_file</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">sequence_filename</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">db_info_csv</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
                    <span class="n">dfx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">infh</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dfx</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Filename&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sequence_filename</span><span class="p">:</span>
                            <span class="n">annotation_file</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Annotations file&#39;</span><span class="p">]</span>

                            <span class="c1"># Change the value back to None if it is NaN in the</span>
                            <span class="c1"># DataFrame.</span>
                            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">annotation_file</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
                                <span class="n">annotation_file</span> <span class="o">=</span> <span class="kc">None</span>


                <span class="c1"># If there is an annotation file available, determine whether</span>
                <span class="c1"># the hit is at the same locus in the nucleotide sequence as</span>
                <span class="c1"># the peptide sequence hit.</span>
                <span class="k">if</span> <span class="n">annotation_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Check that the type is string.</span>
                    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">annotation_file</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;str&#39;</span>

                    <span class="c1"># Join the paths.</span>
                    <span class="n">annotation_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">dbdirpath</span><span class="p">,</span>
                            <span class="n">annotation_file</span><span class="p">)</span>

                    <span class="c1"># Call function for getting IDs of overlapping genes.</span>
                    <span class="n">overlapping_genes</span> <span class="o">=</span>\
                    <span class="n">get_overlapping_genes_from_gff3</span><span class="p">(</span><span class="n">annotation_file_path</span><span class="p">,</span>
                            <span class="n">x</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>

                <span class="c1"># If there are overlapping gene loci with the tblastn hit...</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_genes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">remove_tblastn_hits_at_annotated_loci</span><span class="p">:</span>
                        <span class="c1"># If there are any overlapping annotated genes, then remove the</span>
                        <span class="c1"># nucleotide tuple and make a note. This only makes sense</span>
                        <span class="c1"># if the relevant protein sequences are also being searched</span>
                        <span class="c1"># with a similar query.</span>

                        <span class="c1"># Change value in column for ID or locus redundancy</span>
                        <span class="c1"># to &#39;-&#39;.</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                            <span class="s1">&#39;Does not have same ID or locus as another hit&#39;</span><span class="p">]</span>\
                            <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

                        <span class="c1"># Make a note in the dataframe/spreadsheet.</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                            <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span>\
                            <span class="o">=</span> <span class="s1">&#39;(This hit overlaps with the following previously annotated loci: </span><span class="si">%s</span><span class="s1">)&#39;</span>\
                                    <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">overlapping_genes</span><span class="p">)</span>

                        <span class="c1"># Mark tuple for removal.</span>
                        <span class="n">nucl_tuples_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Loop over protein hits and see if any are redundant with the</span>
                        <span class="c1"># nucleotide hit.</span>
                        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">reduced_prot_tuples</span><span class="p">:</span>
                            <span class="c1"># Add info to info text to the spreadsheet if the tblastn hit</span>
                            <span class="c1"># is redundant with a protein hit.</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overlapping_genes</span><span class="p">:</span>
                                <span class="n">prot_hit_acc</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
                                <span class="c1"># ***Note: This may not work for all gene ID/accession</span>
                                <span class="c1"># nomenclature schemes.</span>
                                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prot_hit_acc</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>

                                    <span class="c1"># Change value in column for ID or locus redundancy</span>
                                    <span class="c1"># to &#39;-&#39;.</span>
                                    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                        <span class="s1">&#39;Does not have same ID or locus as another hit&#39;</span><span class="p">]</span>\
                                        <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

                                    <span class="c1"># Make note in spreadsheet.</span>
                                    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                        <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span>\
                                        <span class="o">=</span> <span class="s1">&#39;(This hit is at the same locus as protein hit with ID: </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">prot_hit_acc</span>

                                    <span class="c1"># Mark tuple for removal, because it is redundant</span>
                                    <span class="c1"># with a peptide hit.</span>
                                    <span class="n">nucl_tuples_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                                    <span class="c1"># Break the loop.</span>
                                    <span class="k">break</span>

        <span class="c1"># Generate a reduced list of nucleotide info tuples, if there are any</span>
        <span class="c1"># to remove from the original list.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nucl_tuples_to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nucl_hit_accs_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nucl_tuples_to_remove</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nucl_tuples</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nucl_hit_accs_to_remove</span><span class="p">:</span>
                    <span class="n">reduced_nucl_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reduced_nucl_tuples</span> <span class="o">=</span> <span class="n">nucl_tuples</span>

        <span class="c1"># Check for redundancy among the tblastn hits in their locations, and</span>
        <span class="c1"># remove all but the best hit for each locus.</span>
        <span class="c1"># Since the tuples are sorted by E-value, for each tuple in the list,</span>
        <span class="c1"># any tuples further down the list that have the same filename and seq</span>
        <span class="c1"># ID and overlapping coordinates can be marked for removal.</span>
        <span class="n">further_reduced_nucl_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">more_nucl_tuples_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reduced_nucl_tuples</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_nucl_tuples</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">reduced_nucl_tuples</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="c1"># Check whether they have the same filename and sequence ID.</span>
                    <span class="k">if</span> <span class="n">j</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="ow">and</span> <span class="n">j</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">[</span><span class="mi">7</span><span class="p">]:</span>
                        <span class="c1"># Check for overlapping ranges.</span>
                        <span class="n">ir</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                        <span class="n">jr</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                        <span class="n">iset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ir</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ir</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                        <span class="n">jset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">jr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">jr</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">jset</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># Then the hits have overlapping ranges/coordinates on</span>
                            <span class="c1"># the same subject sequence.</span>
                            <span class="c1"># Check that the E-values are right.</span>
                            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                                <span class="c1"># Mark the one with the lower or equivalent E-value for removal.</span>
                                <span class="n">more_nucl_tuples_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                                <span class="c1"># Change value in column for ID or locus redundancy</span>
                                <span class="c1"># to &#39;-&#39;.</span>
                                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                    <span class="s1">&#39;Does not have same ID or locus as another hit&#39;</span><span class="p">]</span>\
                                    <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

                                <span class="c1"># Make a note in the spreadsheet, explaining why</span>
                                <span class="c1"># this hit was excluded.</span>
                                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                    <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span>\
                                    <span class="o">=</span> <span class="s1">&#39;(This hit is at the same locus as nucleotide hit with ID: </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                                <span class="k">assert</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;Chr5[17020882..17021032]&#39;</span> <span class="c1"># REMOVE THIS???</span>
        <span class="c1"># Remove the identified redundant tuples. </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">more_nucl_tuples_to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nucl_hit_indexes_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">more_nucl_tuples_to_remove</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reduced_nucl_tuples</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nucl_hit_indexes_to_remove</span><span class="p">:</span>
                    <span class="n">further_reduced_nucl_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">further_reduced_nucl_tuples</span> <span class="o">=</span> <span class="n">reduced_nucl_tuples</span>


        <span class="c1"># Ignore protein hits that are below the minimum length or percent length.</span>
        <span class="n">reduced_prot_tuples2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reduced_prot_tuples</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
            <span class="n">percent_length</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span>\
            <span class="nb">int</span><span class="p">(</span><span class="n">minimum_length_of_query_to_be_distinct_paralogue</span><span class="p">):</span>
                <span class="n">remove</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Change value in column for length criteria.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                    <span class="s1">&#39;Meets length criteria&#39;</span><span class="p">]</span>\
                    <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="c1"># Make a note in the spreadsheet.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="s1">&#39;(Hit length is less than </span><span class="si">%s</span><span class="s1">, therefore too short to be a potential distinct paralogue)&#39;</span>\
                    <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">minimum_length_of_query_to_be_distinct_paralogue</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">percent_length</span><span class="p">)</span> <span class="o">&lt;</span>\
            <span class="nb">int</span><span class="p">(</span><span class="n">minimum_percent_length_of_query_to_be_distinct_paralogue</span><span class="p">):</span>
                <span class="n">remove</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Change value in column for length criteria.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                    <span class="s1">&#39;Meets length criteria&#39;</span><span class="p">]</span>\
                    <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="c1"># Make a note in the spreadsheet.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="s1">&#39;(Hit length is less than </span><span class="si">%s</span><span class="s1"> percent of query length, therefore too short to be a potential distinct paralogue)&#39;</span>\
                    <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">minimum_percent_length_of_query_to_be_distinct_paralogue</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">remove</span><span class="p">:</span>
                <span class="n">prm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Remove the identified redundant tuples. </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reduced_prot_tuples</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prm</span><span class="p">:</span>
                    <span class="n">reduced_prot_tuples2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reduced_prot_tuples2</span> <span class="o">=</span> <span class="n">reduced_prot_tuples</span>

        <span class="c1"># Ignore nucleotide hits that are below the minimum length or percent length.</span>
        <span class="n">further_reduced_nucl_tuples2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nrm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">further_reduced_nucl_tuples</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
            <span class="n">percent_length</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span>\
            <span class="nb">int</span><span class="p">(</span><span class="n">minimum_length_of_query_to_be_distinct_paralogue</span><span class="p">):</span>
                <span class="n">remove</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Change value in column for length criteria.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                    <span class="s1">&#39;Meets length criteria&#39;</span><span class="p">]</span>\
                    <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="c1"># Make a note in the spreadsheet.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="s1">&#39;(Hit length is less than </span><span class="si">%s</span><span class="s1">, therefore too short to be a potential distinct paralogue)&#39;</span>\
                    <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">minimum_length_of_query_to_be_distinct_paralogue</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">percent_length</span><span class="p">)</span> <span class="o">&lt;</span>\
            <span class="nb">int</span><span class="p">(</span><span class="n">minimum_percent_length_of_query_to_be_distinct_paralogue</span><span class="p">):</span>
                <span class="n">remove</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Change value in column for length criteria.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                    <span class="s1">&#39;Meets length criteria&#39;</span><span class="p">]</span>\
                    <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="c1"># Make a note in the spreadsheet.</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="s1">&#39;(Hit length is less than </span><span class="si">%s</span><span class="s1"> percent of query length, therefore too short to be a potential distinct paralogue)&#39;</span>\
                    <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">minimum_percent_length_of_query_to_be_distinct_paralogue</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">remove</span><span class="p">:</span>
                <span class="n">nrm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Remove the identified redundant tuples. </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nrm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">further_reduced_nucl_tuples</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nrm</span><span class="p">:</span>
                    <span class="n">further_reduced_nucl_tuples2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">further_reduced_nucl_tuples2</span> <span class="o">=</span> <span class="n">further_reduced_nucl_tuples</span>


        <span class="c1"># Remove nucleotide hits from the tuples if they have identical accessions</span>
        <span class="c1"># to higher-ranking nucleotide hits (This should be redundant, because</span>
        <span class="c1"># it is already checked whether they are for the same locus).</span>
        <span class="n">further_reduced_nucl_tuples3</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hit_indexes_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">further_reduced_nucl_tuples2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">further_reduced_nucl_tuples2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">further_reduced_nucl_tuples2</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="c1"># Check whether they have the same filename and sequence ID</span>
                    <span class="c1"># (seq.id plus coordinates).</span>
                    <span class="k">if</span> <span class="n">j</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="ow">and</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># Check that the E-values are right.</span>
                        <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                            <span class="c1"># Mark the one with the lower or equivalent E-value for removal.</span>
                            <span class="n">hit_indexes_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                            <span class="c1"># Change value in column for length criteria.</span>
                            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                <span class="s1">&#39;Meets length criteria&#39;</span><span class="p">]</span>\
                                <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

                            <span class="c1"># Make a note in the spreadsheet, explaining why</span>
                            <span class="c1"># this hit was excluded.</span>
                            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span>\
                                <span class="o">=</span> <span class="s1">&#39;(This hit has the same ID as nucleotide hit with ID: </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Remove the identified redundant tuples. </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hit_indexes_to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">further_reduced_nucl_tuples2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hit_indexes_to_remove</span><span class="p">:</span>
                    <span class="n">further_reduced_nucl_tuples3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">further_reduced_nucl_tuples3</span> <span class="o">=</span> <span class="n">further_reduced_nucl_tuples2</span>


        <span class="c1"># Check that no accessions listed in the info tuples are identical to</span>
        <span class="c1"># each other.</span>
        <span class="n">all_accs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reduced_prot_tuples2</span> <span class="o">+</span> <span class="n">further_reduced_nucl_tuples3</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_accs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_accs</span><span class="p">))),</span> <span class="s2">&quot;&quot;&quot;Info for hits with</span>
<span class="s2">        identical accessions is present in the reduced set.&quot;&quot;&quot;</span>


        <span class="c1"># Check that explanations were noted in the spreadsheet (dataframe) for</span>
        <span class="c1"># all the tuples that were removed from the original list.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_tuples</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reduced_prot_tuples2</span>\
            <span class="o">+</span> <span class="n">further_reduced_nucl_tuples3</span><span class="p">]:</span>
                <span class="n">note</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> 
                <span class="k">assert</span> <span class="n">note</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No justification noted for not</span>
<span class="s2">                considering a hit with ID </span><span class="si">%s</span><span class="s2"> and index </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Compile a list of all reduced tuples.</span>
        <span class="n">all_reduced_tuples</span> <span class="o">=</span> <span class="n">reduced_prot_tuples2</span> <span class="o">+</span> <span class="n">further_reduced_nucl_tuples3</span>

        <span class="c1"># Compile lists of just the sequence objects.</span>
        <span class="n">ranked_prot_seq_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reduced_prot_tuples2</span><span class="p">]</span>
        <span class="n">ranked_nucl_seq_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">further_reduced_nucl_tuples3</span><span class="p">]</span>
        <span class="c1"># Concatenate the two lists, putting proteins first.</span>
        <span class="n">ranked_seq_objs</span> <span class="o">=</span> <span class="n">ranked_prot_seq_objs</span> <span class="o">+</span> <span class="n">ranked_nucl_seq_objs</span>

        <span class="c1">## Check that there is at least one sequence object in the list.</span>
        <span class="c1">#assert len(ranked_seq_objs) &gt;= 1, &quot;&quot;&quot;There must be at least one</span>
        <span class="c1">#sequence object in the list.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranked_seq_objs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Make a dict with info for each hit to be used by the</span>
            <span class="c1"># find_redun_model_recursively function (info can be accessed by</span>
            <span class="c1"># accession).</span>
            <span class="n">extra_info_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_tuples</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">extra_info_dict</span><span class="p">[</span><span class="n">acc</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

            <span class="c1"># Construct a dict of ids for true paralogues and ids for sequences that are</span>
            <span class="c1"># redundant with each.</span>
            <span class="n">redundant_gene_model_dict</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Add rank info to dict.</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">ranked_seq_objs</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">redundant_gene_model_dict</span><span class="p">[</span><span class="n">seq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[]]</span>

            <span class="c1"># get current alignment number so that it can pick up where it</span>
            <span class="c1"># started.</span>
            <span class="n">cur_ali_num</span> <span class="o">=</span> <span class="n">get_cur_ali_num</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span> 

            <span class="c1"># Define path to alignment to use.</span>
            <span class="n">alignment_path</span> <span class="o">=</span> <span class="n">index_dict</span><span class="p">[</span><span class="n">combo</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Add sequence comparison info to dict.</span>
            <span class="n">full_redundant_gene_model_dict</span> <span class="o">=</span>\
            <span class="n">find_redun_model_recursively</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">cur_ali_num</span><span class="p">,</span> <span class="n">alignment_path</span><span class="p">,</span>\
                    <span class="n">ranked_seq_objs</span><span class="p">,</span> <span class="n">redundant_gene_model_dict</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span>\
                    <span class="n">metric_value_minimum</span><span class="p">,</span> <span class="n">minimum_percent_similarity</span><span class="p">,</span>
                    <span class="n">extra_info_dict</span><span class="p">,</span> <span class="n">overlap_required</span><span class="p">)</span>

            <span class="c1"># Extract info from full redundant gene model dict, and add to</span>
            <span class="c1"># corresponding cells in dataframe.</span>
            <span class="n">key_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">unique_paralogue_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>\
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">key_num</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># Get index for row that info should be added to.</span>
                <span class="c1"># It should be the index that has results for hit with the same</span>
                <span class="c1"># accession.</span>
                <span class="n">index_in_dataframe</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Iterate over reduced info tuples for current query title and</span>
                <span class="c1"># taxon name (combo).</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">all_reduced_tuples</span><span class="p">:</span>
                    <span class="c1"># If the accession in the tuple is the same as for the</span>
                    <span class="c1"># current dict key, then use the index from that tuple.</span>
                    <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                        <span class="n">index_in_dataframe</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Determine from dict whether the hit represents the first hit</span>
                <span class="c1"># for an identifiably unique paralogous gene locus.</span>
                <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;No&#39;</span>
                <span class="k">if</span> <span class="s1">&#39;represents a unique (paralogous) gene locus&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;Yes&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;uncertain whether this represents a unique (paralogous) gene locus&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;Uncertain&#39;</span>

                <span class="c1"># Define dataframe values using info from dict.</span>
                <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Forward search method&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;tblastn&#39;</span><span class="p">):</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> <span class="o">=</span>\
                    <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                <span class="c1">#print(df.loc[index_in_dataframe, &#39;Comparison with other positive hits in the same genome&#39;])</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Accessions for sequences that are redundant with the sequence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Represents an identifiably unique paralogue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique</span>

                <span class="c1"># Assign paralogue name to &quot;Paralogue name&quot; column, if it is</span>
                <span class="c1"># unique.</span>
                <span class="k">if</span> <span class="n">unique</span> <span class="o">==</span> <span class="s1">&#39;Yes&#39;</span><span class="p">:</span>
                    <span class="n">unique_paralogue_num</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Paralogue name&#39;</span><span class="p">]</span> <span class="o">=</span>\
                    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;taxon name&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>\
                    <span class="o">+</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">combo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">unique_paralogue_num</span><span class="p">)</span>

                <span class="c1"># Check that a note was made for the current index (row) in the</span>
                <span class="c1"># dataframe.</span>
                <span class="n">note</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index_in_dataframe</span><span class="p">,</span> <span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">note</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No note made for hit with ID </span><span class="si">%s</span><span class="s2"> and index </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span>\
                        <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_redundant_gene_model_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">index_in_dataframe</span><span class="p">))</span>                


        <span class="c1"># Check that explanations were noted in the spreadsheet (dataframe) for</span>
        <span class="c1"># all the tuples list processed with the recursive function to check</span>
        <span class="c1"># for redundancy.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_tuples</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reduced_prot_tuples2</span>\
            <span class="o">+</span> <span class="n">further_reduced_nucl_tuples2</span><span class="p">]:</span>
                <span class="n">note</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;Comparison with other positive hits in the same genome&#39;</span><span class="p">]</span> 
                <span class="k">assert</span> <span class="n">note</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No note made for hit with ID </span><span class="si">%s</span><span class="s2"> and index </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>


    <span class="c1"># Change column headers in dataframe so that this function can be called</span>
    <span class="c1"># multiple times with the same input spreadsheet to compare results when</span>
    <span class="c1"># using different parameters.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)])</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="s1">&#39; (&#39;</span> <span class="o">+</span> <span class="n">paralogue_count_id</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_column_label_list</span><span class="p">]</span>

    <span class="c1"># Write modified dataframe to output file path.</span>
    <span class="n">output_fp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">outfp</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#output_fp = os.path.join(outdir, os.path.basename(csv_file).rsplit(&#39;.&#39;,</span>
        <span class="c1">#    1)[0] + &#39;_&#39; + paralogue_count_id + &#39;.csv&#39;)</span>
        <span class="n">output_fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">csv_file</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">paralogue_count_id</span> <span class="o">+</span> <span class="s1">&#39;.csv&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">output_fp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_fp</span> <span class="o">=</span> <span class="n">outfp</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing dataframe to csv file.&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_fp</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#print(&#39;\nResults written to file:\n&#39; + output_fp)</span>


    <span class="c1"># Visualize all comparisons to evaluate whether metric adequately</span>
    <span class="c1"># distinguished between sequences.</span>

    <span class="c1"># Get filepath for relevant output file. </span>
    <span class="n">outputfile</span> <span class="o">=</span> <span class="n">get_all_comparison_output_filepath</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>

    <span class="c1"># Return final output filepath for printing.</span>
    <span class="k">return</span> <span class="n">output_fp</span></div>


<div class="viewcode-block" id="add_alignment_column"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.add_alignment_column">[docs]</a><span class="k">def</span> <span class="nf">add_alignment_column</span><span class="p">(</span><span class="n">incsv</span><span class="p">,</span> <span class="n">outcsv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a column to the input csv spreadsheet which lists the alignment file</span>
<span class="sd">    name to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define output filepath.</span>
    <span class="k">if</span> <span class="n">outcsv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outcsv</span> <span class="o">=</span> <span class="n">incsv</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_with_ali_col.csv&#39;</span>


    <span class="c1"># Loop over rows, and make a dictionary of alignment file names for each</span>
    <span class="c1"># query title.</span>

    <span class="c1"># Define dict for interpreting headers.</span>
    <span class="n">column_header_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;query title&#39;</span><span class="p">:</span> <span class="s1">&#39;Query title&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;alignment name&#39;</span><span class="p">:</span> <span class="s1">&#39;Alignment for sequence comparison&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;query filename&#39;</span><span class="p">:</span> <span class="s1">&#39;Query file&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;taxon name&#39;</span><span class="p">:</span> <span class="s1">&#39;Subject database species (if applicable)&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;database filename&#39;</span><span class="p">:</span> <span class="s1">&#39;Subject database file&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;positive or not&#39;</span><span class="p">:</span> <span class="s1">&#39;Collective interpretation of reverse search results&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;accession&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit accession&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;program&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward search method&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;seq&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;subseq&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit subsequence(s) that align(s) to query&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;seq descr&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit description&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;subseq descr&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit description of subsequence(s) that align(s) to query&#39;</span>
                          <span class="p">}</span>
    <span class="c1"># Use pandas to parse the input csv (spreadsheet) file.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">incsv</span><span class="p">)</span>

    <span class="c1"># Loop over rows and construct dict with query titles as keys and</span>
    <span class="c1"># corresponding alignment to use for sequence comparison as values.</span>
    <span class="n">complete_query_title_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">query_title_alignment_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="c1">#if row[column_header_dict[&#39;positive or not&#39;]] == &#39;+&#39;:</span>
        <span class="c1">#    query_title = row[column_header_dict[&#39;query title&#39;]]</span>
        <span class="c1">#    query_file = row[column_header_dict[&#39;query filename&#39;]]</span>
        <span class="c1">#    complete_query_title_list.append(query_title)</span>
        <span class="c1">#    if query_file.endswith(&#39;.afaa&#39;) or query_file.endswith(&#39;.afna&#39;):</span>
        <span class="c1">#        if query_title not in query_title_alignment_dict.keys():</span>
        <span class="c1">#            query_title_alignment_dict[query_title] = [query_file]</span>
        <span class="c1">#        else:</span>
        <span class="c1">#            if not query_file in query_title_alignment_dict[query_title]:</span>
        <span class="c1">#                query_title_alignment_dict[query_title] = query_title_alignment_dict[query_title] + [query_file]</span>

        <span class="c1">#    # TEMPORARY!!:</span>
        <span class="c1">#    #elif query_title in [&#39;AP5_mu&#39;, &#39;TTRAY1&#39;, &#39;AP3_sigma&#39;, &#39;COPI_beta&#39;,&#39;ClathrinHC&#39;]:</span>
        <span class="c1">#    #        query_title_alignment_dict[query_title] = [query_file]</span>
        <span class="c1">#    #if query_title == &#39;COPI_alpha&#39;:</span>
        <span class="c1">#    #        query_title_alignment_dict[query_title] = [&#39;COPI_Alpha_3.afaa&#39;]</span>
        <span class="c1">#    elif query_title in [&#39;AP5_sigma&#39;]:</span>
        <span class="c1">#            query_title_alignment_dict[query_title] = [query_file]</span>

        <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;query title&#39;</span><span class="p">]]</span>
        <span class="n">query_file</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;query filename&#39;</span><span class="p">]]</span>
        <span class="n">complete_query_title_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query_title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">query_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.afaa&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">query_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.afna&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">query_title</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">query_title_alignment_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">query_file</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">query_file</span> <span class="ow">in</span> <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]:</span>
                    <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">query_file</span><span class="p">]</span>

    
    <span class="c1"># Check that an alignment file name was assigned to each query title.</span>
    <span class="n">titles_without_alignments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">query_title</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">complete_query_title_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">query_title</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">query_title_alignment_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">titles_without_alignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query_title</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">titles_without_alignments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No alignment file names</span>
<span class="s2">    could be found to use for the following query titles:</span>
<span class="s2">        </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">titles_without_alignments</span><span class="p">))</span>

    <span class="c1"># Check that one and only one alignment file name has been assigned to each</span>
    <span class="c1"># query title.</span>
    <span class="k">for</span> <span class="n">query_title</span> <span class="ow">in</span> <span class="n">query_title_alignment_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not</span>
<span class="s2">        identify an alignment file to use for query title: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">query_title</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Identified</span>
<span class="s2">        more than one potential alignment file to use for query title </span><span class="si">%s</span><span class="s2">:</span>
<span class="s2">            </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span>\
        <span class="o">%</span> <span class="p">(</span><span class="n">query_title</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]))</span>
    

    <span class="c1"># Use the dict to add a column to the dataframe.</span>

    <span class="c1"># New column labels (for new columns to be appended).</span>
    <span class="n">new_column_label_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;alignment name&#39;</span><span class="p">]]</span>

    <span class="c1"># Initiate new dataframe with columns to be appended/joined to existing</span>
    <span class="c1"># dataframe.</span>
    <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span>

    <span class="c1"># Join constructed dataframe to input dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>


    <span class="c1"># Update the new column with alignment names.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;positive or not&#39;</span><span class="p">]]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;query title&#39;</span><span class="p">]]</span>
            <span class="n">alignment_to_use</span> <span class="o">=</span> <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;alignment name&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alignment_to_use</span>

    <span class="c1"># Write updated dataframe to output csv file.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outcsv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">outcsv</span></div>


<div class="viewcode-block" id="add_model_column"><a class="viewcode-back" href="../module_paralogue_counter.html#module_paralogue_counter.add_model_column">[docs]</a><span class="k">def</span> <span class="nf">add_model_column</span><span class="p">(</span><span class="n">incsv</span><span class="p">,</span> <span class="n">outcsv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a column to the input csv spreadsheet which lists the alignment file</span>
<span class="sd">    name to use.</span>

<span class="sd">    ***Very similar to the add_alignment_to_column function defined above.</span>
<span class="sd">    ***Not yet customized for purpose!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define output filepath.</span>
    <span class="k">if</span> <span class="n">outcsv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outcsv</span> <span class="o">=</span> <span class="n">incsv</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_with_ali_col.csv&#39;</span>


    <span class="c1"># Loop over rows, and make a dictionary of alignment file names for each</span>
    <span class="c1"># query title.</span>

    <span class="c1"># Define dict for interpreting headers.</span>
    <span class="n">column_header_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;query title&#39;</span><span class="p">:</span> <span class="s1">&#39;Query title&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;alignment name&#39;</span><span class="p">:</span> <span class="s1">&#39;Alignment for sequence comparison&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;query filename&#39;</span><span class="p">:</span> <span class="s1">&#39;Query file&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;taxon name&#39;</span><span class="p">:</span> <span class="s1">&#39;Subject database species (if applicable)&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;database filename&#39;</span><span class="p">:</span> <span class="s1">&#39;Subject database file&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;positive or not&#39;</span><span class="p">:</span> <span class="s1">&#39;Collective interpretation of reverse search results&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;accession&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit accession&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;program&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward search method&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;seq&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;subseq&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit subsequence(s) that align(s) to query&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;seq descr&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit description&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;subseq descr&#39;</span><span class="p">:</span> <span class="s1">&#39;Forward hit description of subsequence(s) that align(s) to query&#39;</span>
                          <span class="p">}</span>
    <span class="c1"># Use pandas to parse the input csv (spreadsheet) file.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">incsv</span><span class="p">)</span>

    <span class="c1"># Loop over rows and construct dict.</span>
    <span class="n">complete_query_title_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">query_title_alignment_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;positive or not&#39;</span><span class="p">]]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;query title&#39;</span><span class="p">]]</span>
            <span class="n">query_file</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;query filename&#39;</span><span class="p">]]</span>
            <span class="n">complete_query_title_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query_title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">query_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.afaa&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">query_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.afna&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">query_title</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">query_title_alignment_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">query_file</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">query_file</span> <span class="ow">in</span> <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]:</span>
                        <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">query_file</span><span class="p">]</span>

            <span class="c1">## TEMPORARY!!:</span>
            <span class="c1">#elif query_title in [&#39;AP5_mu&#39;, &#39;TTRAY1&#39;, &#39;AP3_sigma&#39;, &#39;COPI_beta&#39;,&#39;ClathrinHC&#39;]:</span>
            <span class="c1">#        query_title_alignment_dict[query_title] = [query_file]</span>

    
    <span class="c1"># Check that an alignment file name was assigned to each query title.</span>
    <span class="n">titles_without_alignments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">query_title</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">complete_query_title_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">query_title</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">query_title_alignment_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">titles_without_alignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query_title</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">titles_without_alignments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No alignment file names</span>
<span class="s2">    could be found to use for the following query titles:</span>
<span class="s2">        </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">titles_without_alignments</span><span class="p">))</span>

    <span class="c1"># Check that one and only one alignment file name has been assigned to each</span>
    <span class="c1"># query title.</span>
    <span class="k">for</span> <span class="n">query_title</span> <span class="ow">in</span> <span class="n">query_title_alignment_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not</span>
<span class="s2">        identify an alignment file to use for query title: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">query_title</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Identified</span>
<span class="s2">        more than one potential alignment file to use for query title </span><span class="si">%s</span><span class="s2">:</span>
<span class="s2">            </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span>\
        <span class="o">%</span> <span class="p">(</span><span class="n">query_title</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]))</span>
    

    <span class="c1"># Use the dict to add a column to the dataframe.</span>

    <span class="c1"># New column labels (for new columns to be appended).</span>
    <span class="n">new_column_label_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;alignment name&#39;</span><span class="p">]]</span>

    <span class="c1"># Initiate new dataframe with columns to be appended/joined to existing</span>
    <span class="c1"># dataframe.</span>
    <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span>

    <span class="c1"># Join constructed dataframe to input dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>


    <span class="c1"># Update the new column with alignment names.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;positive or not&#39;</span><span class="p">]]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;query title&#39;</span><span class="p">]]</span>
            <span class="n">alignment_to_use</span> <span class="o">=</span> <span class="n">query_title_alignment_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">column_header_dict</span><span class="p">[</span><span class="s1">&#39;alignment name&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alignment_to_use</span>

    <span class="c1"># Write updated dataframe to output csv file.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outcsv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">outcsv</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Lael D. Barlow.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>