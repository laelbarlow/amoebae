
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>module_amoebae_search &#8212; amoebae 0.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for module_amoebae_search</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright 2018 Lael D. Barlow</span>
<span class="c1"># </span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1"># </span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># </span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># </span>
<span class="sd">&quot;&quot;&quot;Module for functions for amoebae script that are for performing</span>
<span class="sd">similarity searches and parsing the output.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Import built-in modules.</span>
<span class="c1">#import argparse</span>
<span class="c1">#import sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">settings</span>
<span class="c1">#import shutil</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="c1">#import time</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="c1">#import copy</span>

<span class="c1"># Import modules from installed libraries/packages.</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">SeqIO</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="k">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="k">import</span> <span class="n">SeqRecord</span>
<span class="c1">#from Bio import AlignIO</span>
<span class="c1">#from Bio.Alphabet import IUPAC, Gapped</span>

<span class="c1">#from Bio import SearchIO</span>

<span class="c1"># Import SearchIO and suppress experimental warning</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">BiopythonExperimentalWarning</span>
<span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">BiopythonExperimentalWarning</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">SearchIO</span>

<span class="kn">import</span> <span class="nn">module_amoebae</span>
<span class="kn">from</span> <span class="nn">module_amoebae_srchresfile</span> <span class="k">import</span> <span class="n">SrchResFile</span>
<span class="kn">import</span> <span class="nn">module_amoebae_column_header_lists</span> 
<span class="kn">from</span> <span class="nn">module_amoebae_run_searches</span> <span class="k">import</span> <span class="n">get_query_list_from_file</span><span class="p">,</span>\
<span class="n">get_db_list_from_file</span><span class="p">,</span> <span class="n">get_out_query_list_path</span><span class="p">,</span> <span class="n">get_out_db_list_path</span><span class="p">,</span>\
<span class="n">determine_search_method</span><span class="p">,</span> <span class="n">search_result_filepath</span><span class="p">,</span> <span class="n">run_any_search</span><span class="p">,</span>\
<span class="n">run_all_searches</span><span class="p">,</span> <span class="n">get_out_hmm_path</span><span class="p">,</span> <span class="n">get_query_subdir</span>
<span class="kn">from</span> <span class="nn">module_search_scaffolds</span> <span class="k">import</span> <span class="n">split_tblastn_hits_into_separate_genes</span><span class="p">,</span>\
<span class="n">get_hit_seq_record_and_coord</span><span class="p">,</span> <span class="n">get_cluster_range</span>


<div class="viewcode-block" id="intersect"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.intersect">[docs]</a><span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; return the intersection of two lists &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="p">))</span></div>

<span class="c1">#from get_datatype import get_dbtype</span>



<span class="c1"># Define functions to be used in amoebae.</span>


<span class="c1"># ********</span>
<span class="c1"># Try to avoid running redundant reverse searches if fwd hits are retrieved by</span>
<span class="c1"># multiple queries.</span>

<span class="c1"># Hits in forward searches will always be single sequences, not profiles, so</span>
<span class="c1"># can assume that all reverse searches will have single fasta sequences as</span>
<span class="c1"># queries. This is important, because when setting up to do reverse searches,</span>
<span class="c1"># a non-redundant list of queries should be used. Also, is if faster to search</span>
<span class="c1"># with a multiple-sequence fasta query?</span>

<span class="c1"># What if I want to add stuff like HHpred? Would be best to add that so I can</span>
<span class="c1"># run in parallel with other methods. I think it would be fairly straight</span>
<span class="c1"># forward to add in the option to use hhsuite.</span>

<span class="c1">#def get_out_hmm_path(new_afa_path):</span>
<span class="c1">#    &quot;&quot;&quot;Define an hmm file path for a given aligned fasta file path.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    new_exten = None</span>
<span class="c1">#    old_exten = new_afa_path.rsplit(&#39;.&#39;, 1)[1]</span>
<span class="c1">#    if old_exten == &#39;afaa&#39;:</span>
<span class="c1">#        new_exten = &#39;hmm&#39;</span>
<span class="c1">#    elif old_exten == &#39;afna&#39;:</span>
<span class="c1">#        new_exten = &#39;nhmm&#39;</span>
<span class="c1">#</span>
<span class="c1">#    # Check that it worked.</span>
<span class="c1">#    assert new_exten is not None, &quot;&quot;&quot;Error: HMM extension could not be</span>
<span class="c1">#    determined for input file: %s&quot;&quot;&quot; % query_file</span>
<span class="c1">#</span>
<span class="c1">#    # Get new path.</span>
<span class="c1">#    hmm_file_path = new_afa_path.rsplit(&#39;.&#39;, 1)[0] + &#39;.&#39; + new_exten</span>
<span class="c1">#</span>
<span class="c1">#    # Return the new path.</span>
<span class="c1">#    return hmm_file_path</span>


<span class="c1">#def determine_search_method(query_exten, db_exten):</span>
<span class="c1">#    &quot;&quot;&quot;Determine which similarity search method to use based on the filename</span>
<span class="c1">#    extensions of the query and database files.</span>
<span class="c1">#</span>
<span class="c1">#    Eventually integrate hhsuite for HMM-HMM comparison.</span>
<span class="c1">#</span>
<span class="c1">#    Assuming blastp rather than phmmer for now.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    # Import default methods, for cases where several could be used, from the</span>
<span class="c1">#    # settings module.</span>
<span class="c1">#    #faa_in_faa = settings.faa_in_faa # phmmer, blastp.</span>
<span class="c1">#</span>
<span class="c1">#    # Decide on method.</span>
<span class="c1">#    method = None</span>
<span class="c1">#</span>
<span class="c1">#    if query_exten == &#39;faa&#39;: </span>
<span class="c1">#        if db_exten == &#39;faa&#39;:</span>
<span class="c1">#            method = &#39;blastp&#39;</span>
<span class="c1">#        elif db_exten == &#39;fna&#39;:</span>
<span class="c1">#            method = &#39;tblastn&#39;</span>
<span class="c1">#        elif db_exten == &#39;hmms&#39;:</span>
<span class="c1">#            pass</span>
<span class="c1">#</span>
<span class="c1">#    elif query_exten == &#39;fna&#39;: </span>
<span class="c1">#        if db_exten == &#39;faa&#39;:</span>
<span class="c1">#            method = &#39;blastx&#39;</span>
<span class="c1">#        elif db_exten == &#39;fna&#39;:</span>
<span class="c1">#            method = &#39;blastn&#39;</span>
<span class="c1">#        elif db_exten == &#39;hmms&#39;:</span>
<span class="c1">#            pass</span>
<span class="c1">#</span>
<span class="c1">#    elif query_exten == &#39;afaa&#39;: </span>
<span class="c1">#        if db_exten == &#39;faa&#39;:</span>
<span class="c1">#            method = &#39;hmmsearch&#39;</span>
<span class="c1">#        elif db_exten == &#39;fna&#39;:</span>
<span class="c1">#            pass</span>
<span class="c1">#        elif db_exten == &#39;hmms&#39;:</span>
<span class="c1">#            method = &#39;hmmscan&#39;</span>
<span class="c1">#</span>
<span class="c1">#    elif query_exten == &#39;afna&#39;: </span>
<span class="c1">#        if db_exten == &#39;faa&#39;:</span>
<span class="c1">#            pass</span>
<span class="c1">#        elif db_exten == &#39;fna&#39;:</span>
<span class="c1">#            method = &#39;nhmmer&#39;</span>
<span class="c1">#        elif db_exten == &#39;hmms&#39;:</span>
<span class="c1">#            pass</span>
<span class="c1">#</span>
<span class="c1">#    assert method is not None, &quot;&quot;&quot;Error: Could not determine which similarity</span>
<span class="c1">#    searching method to apply for query with extension &#39;%s&#39; and database with</span>
<span class="c1">#    extension &#39;%s&#39;&quot;&quot;&quot; % (query_exten, db_exten)</span>
<span class="c1">#</span>
<span class="c1">#    # Return chosen method.</span>
<span class="c1">#    return method</span>


<div class="viewcode-block" id="get_search_software_version"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_search_software_version">[docs]</a><span class="k">def</span> <span class="nf">get_search_software_version</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses output from running the -h option to find what version a given</span>
<span class="sd">    program is.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find out version.</span>
    <span class="n">version</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;blast&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
        <span class="n">blast_vers_output</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="n">method</span><span class="p">,</span> <span class="s2">&quot;-version&quot;</span><span class="p">])</span>
        <span class="n">version</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">blast_vers_output</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;b</span><span class="se">\&#39;</span><span class="s1">blast&#39;</span><span class="p">,</span>\
                <span class="s1">&#39;blast&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;+</span><span class="se">\\</span><span class="s1">nP&#39;</span><span class="p">,</span> <span class="s1">&#39;+</span><span class="se">\n</span><span class="s1">P&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\</span>
<span class="s1"> &#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1">#else:</span>
    <span class="c1">#    version = &#39;SearchMethodHere&#39;</span>
    
    <span class="c1"># Check that it worked.</span>
    <span class="k">assert</span> <span class="n">version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Version of software used (</span><span class="si">%s</span><span class="s2">) could not be</span>
<span class="s2">    determined.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">method</span>

    <span class="c1"># Return string specifying software version.</span>
    <span class="k">return</span> <span class="n">version</span></div>


<span class="c1">#def run_any_search(queryfile, dbfile, outfile):</span>
<span class="c1">#    &quot;&quot;&quot;Run similarity search.</span>
<span class="c1">#</span>
<span class="c1">#    Import info from settings.py to specify options for running external</span>
<span class="c1">#    software? For example, number of threads.</span>
<span class="c1">#</span>
<span class="c1">#    ***Need to refactor functions in the module_nhmmer_search module?</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    # Determine method to use based on the input file types.</span>
<span class="c1">#    query_exten = queryfile.rsplit(&#39;.&#39;, 1)[1]</span>
<span class="c1">#    dbfile_exten = dbfile.rsplit(&#39;.&#39;, 1)[1]</span>
<span class="c1">#    method = determine_search_method(query_exten, dbfile_exten)</span>
<span class="c1">#</span>
<span class="c1">#    # Get version number for software.</span>
<span class="c1">#    #version = &#39;version&#39;</span>
<span class="c1">#    #version = get_search_software_version(method)</span>
<span class="c1">#</span>
<span class="c1">#    # Get relevant settings.</span>
<span class="c1">#    # Get cutoffs for recording hits.</span>
<span class="c1">#    blast_evalcut = str(settings.blast_report_evalue_cutoff)</span>
<span class="c1">#    hmmer_evalcut = str(settings.hmmer_report_evalue_cutoff)</span>
<span class="c1">#    hmmer_scorecut = str(settings.hmmer_report_score_cutoff)</span>
<span class="c1">#    # Get number of threads to use.</span>
<span class="c1">#    num_threads = str(settings.num_threads_similarity_searching)</span>
<span class="c1">#</span>
<span class="c1">#    # Construct search command.</span>
<span class="c1">#    run_command = []</span>
<span class="c1">#    if method == &#39;blastp&#39;:</span>
<span class="c1">#        run_command = [method, &#39;-query&#39;, queryfile, &#39;-db&#39;, dbfile, &#39;-out&#39;,</span>
<span class="c1">#                outfile, &#39;-num_threads&#39;, num_threads, &#39;-outfmt&#39;, &#39;5&#39;, &#39;-evalue&#39;,</span>
<span class="c1">#                blast_evalcut]</span>
<span class="c1">#    elif method == &#39;tblastn&#39;:</span>
<span class="c1">#        run_command = [method, &#39;-query&#39;, queryfile, &#39;-db&#39;, dbfile, &#39;-out&#39;,</span>
<span class="c1">#                outfile, &#39;-num_threads&#39;, num_threads, &#39;-outfmt&#39;, &#39;5&#39;, &#39;-evalue&#39;,</span>
<span class="c1">#                blast_evalcut]</span>
<span class="c1">#    elif method == &#39;blastx&#39;:</span>
<span class="c1">#        run_command = [method, &#39;-query&#39;, queryfile, &#39;-db&#39;, dbfile, &#39;-out&#39;,</span>
<span class="c1">#                outfile, &#39;-num_threads&#39;, num_threads, &#39;-outfmt&#39;, &#39;5&#39;, &#39;-evalue&#39;,</span>
<span class="c1">#                blast_evalcut]</span>
<span class="c1">#    elif method == &#39;blastn&#39;:</span>
<span class="c1">#        run_command = [method, &#39;-query&#39;, queryfile, &#39;-db&#39;, dbfile, &#39;-out&#39;,</span>
<span class="c1">#                outfile, &#39;-num_threads&#39;, num_threads, &#39;-outfmt&#39;, &#39;5&#39;, &#39;-evalue&#39;,</span>
<span class="c1">#                blast_evalcut]</span>
<span class="c1">#    elif method == &#39;hmmsearch&#39;:</span>
<span class="c1">#        # Use HMM file rather than &#39;.afaa&#39; file.</span>
<span class="c1">#        actual_queryfile = get_out_hmm_path(queryfile)</span>
<span class="c1">#        #run_command = [method, &quot;-T&quot;, hmmer_scorecut, &quot;--cpu&quot;, num_threads,</span>
<span class="c1">#        #        &#39;--tblout&#39;, outfile, actual_queryfile, dbfile]</span>
<span class="c1">#        run_command = [method, &quot;-T&quot;, hmmer_scorecut, &quot;--cpu&quot;, num_threads,</span>
<span class="c1">#                &#39;-o&#39;, outfile, actual_queryfile, dbfile]</span>
<span class="c1">#    elif method == &#39;hmmscan&#39;:</span>
<span class="c1">#        #run_command = [method, &quot;-T&quot;, hmmer_scorecut, &quot;--cpu&quot;, num_threads,</span>
<span class="c1">#        #        &#39;--tblout&#39;, outfile, queryfile, dbfile]</span>
<span class="c1">#        run_command = [method, &quot;-T&quot;, hmmer_scorecut, &quot;--cpu&quot;, num_threads,</span>
<span class="c1">#                &#39;-o&#39;, outfile, queryfile, dbfile]</span>
<span class="c1">#    elif method == &#39;nhmmer&#39;:</span>
<span class="c1">#        # Use HMM file rather than &#39;.afna&#39; file.</span>
<span class="c1">#        actual_queryfile = get_out_hmm_path(queryfile)</span>
<span class="c1">#        #run_command = [method, &quot;-T&quot;, hmmer_scorecut, &quot;--cpu&quot;, num_threads,</span>
<span class="c1">#        #        &#39;--tblout&#39;, outfile, actual_queryfile, dbfile]</span>
<span class="c1">#        run_command = [method, &quot;-T&quot;, hmmer_scorecut, &quot;--cpu&quot;, num_threads,</span>
<span class="c1">#                &#39;-o&#39;, outfile, actual_queryfile, dbfile]</span>
<span class="c1">#</span>
<span class="c1">#    # Run command.</span>
<span class="c1">#    subprocess.call(run_command)</span>
<span class="c1">#</span>
<span class="c1">#    # Return string with command used to run search.</span>
<span class="c1">#    #search_descr =  method + &#39; (&#39; + version + &#39;)&#39; + &#39; run with command:\n\t&#39; +\</span>
<span class="c1">#    #        &#39; &#39;.join(run_command) + &#39;\n&#39;</span>
<span class="c1">#    search_descr = &#39; &#39;.join(run_command)</span>
<span class="c1">#    return search_descr</span>


<span class="c1">#def get_query_list_from_file(infp):</span>
<span class="c1">#    &quot;&quot;&quot;Get query list from file.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    query_list = []</span>
<span class="c1">#    with open(infp) as infh:</span>
<span class="c1">#        for i in infh:</span>
<span class="c1">#            if not i.startswith(&#39;#&#39;) and not i.startswith(&#39;\n&#39;):</span>
<span class="c1">#                query_list.append(i.strip())</span>
<span class="c1">#    return query_list</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#def get_db_list_from_file(infp):</span>
<span class="c1">#    &quot;&quot;&quot;Get database list from file.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    db_list = []</span>
<span class="c1">#    with open(infp) as infh:</span>
<span class="c1">#        for i in infh:</span>
<span class="c1">#            if not i.startswith(&#39;#&#39;) and not i.startswith(&#39;\n&#39;):</span>
<span class="c1">#                db_list.append(i.strip())</span>
<span class="c1">#    return db_list</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#def get_out_query_list_path(outdir):</span>
<span class="c1">#    &quot;&quot;&quot;Takes an output directory that search results are written to, and</span>
<span class="c1">#    returns a path for a file to write query file list to.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    return os.path.join(outdir, &#39;0_queries.txt&#39;)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#def get_out_db_list_path(outdir):</span>
<span class="c1">#    &quot;&quot;&quot;Takes an output directory that search results are written to, and</span>
<span class="c1">#    returns a path for a file to write database file list to.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    return os.path.join(outdir, &#39;0_databases.txt&#39;)</span>


<span class="c1">#def run_all_searches(query_file_list, db_file_list, outdir):</span>
<span class="c1">#    &quot;&quot;&quot;Search with every query file in a given list into every database file in</span>
<span class="c1">#    another given list using appropriate methods.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    # Get query and database directories from settings.</span>
<span class="c1">#    query_dir = settings.querydirpath</span>
<span class="c1">#    db_dir = settings.dbdirpath</span>
<span class="c1">#</span>
<span class="c1">#    # Write a query file list file to output directory.</span>
<span class="c1">#    out_query_file = get_out_query_list_path(outdir)</span>
<span class="c1">#    with open(out_query_file, &#39;w&#39;) as o:</span>
<span class="c1">#        for q in query_file_list:</span>
<span class="c1">#            o.write(q + &#39;\n&#39;)</span>
<span class="c1">#</span>
<span class="c1">#    # Write a database file list file to output directory.</span>
<span class="c1">#    out_db_file = get_out_db_list_path(outdir)</span>
<span class="c1">#    with open(out_db_file, &#39;w&#39;) as o:</span>
<span class="c1">#        for d in db_file_list:</span>
<span class="c1">#            o.write(d + &#39;\n&#39;)</span>
<span class="c1">#</span>
<span class="c1">#    # Create a log file.</span>
<span class="c1">#    logfile = os.path.join(outdir, &#39;0_search_log.txt&#39;)</span>
<span class="c1">#</span>
<span class="c1">#    # Loop over each query-database pair.</span>
<span class="c1">#    with open(logfile, &#39;w&#39;) as o:</span>
<span class="c1">#        srch_num = 0</span>
<span class="c1">#        # Loop over query files.</span>
<span class="c1">#        for q in query_file_list:</span>
<span class="c1">#            # Loop over database files.</span>
<span class="c1">#            for d in db_file_list:</span>
<span class="c1">#                # Temporary &#39;if&#39; statement???</span>
<span class="c1">#                if q.rsplit(&#39;.&#39;, 1)[1] == &#39;afaa&#39; and d.rsplit(&#39;.&#39;, 1)[1] == &#39;fna&#39;:</span>
<span class="c1">#                    warning_text = &quot;&quot;&quot;\nWARNING: Not searching with profile query %s</span>
<span class="c1">#                    in nucleotide data %s\n\n&quot;&quot;&quot; % (q, d)</span>
<span class="c1">#                    print(warning_text)</span>
<span class="c1">#                    o.write(warning_text)</span>
<span class="c1">#                else:</span>
<span class="c1">#                    srch_num += 1</span>
<span class="c1">#</span>
<span class="c1">#                    # Get name of output file.</span>
<span class="c1">#                    #print(outdir)</span>
<span class="c1">#                    outfile = search_result_filepath(q, d, outdir)</span>
<span class="c1">#                    #print(outfile)</span>
<span class="c1">#</span>
<span class="c1">#                    # Get full filepaths, and verify existence.</span>
<span class="c1">#                    qfull = None</span>
<span class="c1">#                    if os.path.isfile(q):</span>
<span class="c1">#                        qfull = q</span>
<span class="c1">#                    else:</span>
<span class="c1">#                        qfull = os.path.join(query_dir, q)</span>
<span class="c1">#                    assert os.path.isfile(qfull), &quot;&quot;&quot;Specified query file path is</span>
<span class="c1">#                    not a file: %s&quot;&quot;&quot; % qfull</span>
<span class="c1">#</span>
<span class="c1">#                    dfull = None</span>
<span class="c1">#                    if os.path.isfile(d):</span>
<span class="c1">#                        dfull = d</span>
<span class="c1">#                    else:</span>
<span class="c1">#                        dfull = os.path.join(db_dir, d)</span>
<span class="c1">#                    assert os.path.isfile(dfull), &quot;&quot;&quot;Specified database file path</span>
<span class="c1">#                    is not a file: %s&quot;&quot;&quot; % dfull</span>
<span class="c1">#</span>
<span class="c1">#                    # Run the similarity search and get a description of the search</span>
<span class="c1">#                    # command (write to a log file?).</span>
<span class="c1">#                    command_descr = run_any_search(qfull, dfull, outfile)</span>
<span class="c1">#</span>
<span class="c1">#                    # Write description of search to log file.</span>
<span class="c1">#                    o.write(command_descr + &#39;\n&#39;)</span>


<div class="viewcode-block" id="get_search_output_file_type"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_search_output_file_type">[docs]</a><span class="k">def</span> <span class="nf">get_search_output_file_type</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a search output file and return the name of the program that was</span>
<span class="sd">    used to generate it (and perhaps the format style).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="o">...</span></div>


<div class="viewcode-block" id="fwd_search_results_to_csv"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.fwd_search_results_to_csv">[docs]</a><span class="k">def</span> <span class="nf">fwd_search_results_to_csv</span><span class="p">(</span><span class="n">search_outdir</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse forward search output files and add a summary of the results to</span>
<span class="sd">    a csv file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get list of search filenams (start with numbers in order).</span>
    <span class="n">outfiles</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">search_outdir</span><span class="p">,</span> <span class="s1">&#39;*out.txt&#39;</span><span class="p">))</span>

    <span class="c1"># Loop through files and extract the relevant info for writing to the csv</span>
    <span class="c1"># file. </span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">outfiles</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="c1"># Get file type (name of program that was used to generate it).</span>
            <span class="n">outfiletype</span> <span class="o">=</span> <span class="n">get_search_output_file_type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

            <span class="c1"># Parse file according to its format.</span>
            <span class="k">if</span> <span class="n">outfiletype</span> <span class="o">==</span> <span class="s1">&#39;blast&#39;</span> <span class="ow">or</span> <span class="n">outfiletype</span> <span class="o">==</span> <span class="s1">&#39;hmmer&#39;</span><span class="p">:</span>
                <span class="c1"># Use the SearchIO module to parse.</span>
                <span class="n">search_obj</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>

                <span class="c1"># Loop through forward search hits, and write info to csv file.</span>
                <span class="c1"># ***Use the pandas library....</span>

            <span class="c1"># Only blast and hmmer working for now... (later hhpred).</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span></div>


<span class="c1">#def search_result_filepath(query_filename, db_filename, dirpath):</span>
<span class="c1">#    &quot;&quot;&quot;Returns a filepath for a search result file given a directory path, query</span>
<span class="c1">#    filename, and database filename. This is for both naming and identifying</span>
<span class="c1">#    filepaths after searches have been performed. </span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    outfile = os.path.join(dirpath, os.path.basename(query_filename).rsplit(&#39;.&#39;, 1)[0] + &#39;__&#39; +\</span>
<span class="c1">#            db_filename.rsplit(&#39;.&#39;, 1)[0] + &#39;_srch_out.txt&#39;)</span>
<span class="c1">#    return outfile</span>


<span class="c1">#def get_srch_file_info(search_result_path):</span>
<span class="c1">#    &quot;&quot;&quot;Returns the format string necessary for the SearchIO module to parse a</span>
<span class="c1">#    given file.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    # Define regular expressions that will only match any line in a file if it</span>
<span class="c1">#    # is of a certain format. See the SearchIO documentation here:</span>
<span class="c1">#    # http://biopython.org/DIST/docs/api/Bio.SearchIO-module.html</span>
<span class="c1">#    fmt_expr_dict = {&#39;blast-xml&#39;: [re.compile(r&#39;^&lt;!DOCTYPE BlastOutput&#39;)],</span>
<span class="c1">#                     &#39;hmmer3-tab&#39;: [re.compile(r&#39;^# Option settings: hmmsearch --tblout&#39;)],</span>
<span class="c1">#                     &#39;hmmer3-text&#39;: [re.compile(r&#39;^# HMMER &#39;)]</span>
<span class="c1">#                     }</span>
<span class="c1">#    </span>
<span class="c1">#    # See if any of the regular expressions match the file.</span>
<span class="c1">#    ident_fmt = None</span>
<span class="c1">#    with open(search_result_path) as srh:</span>
<span class="c1">#        for line in srh:</span>
<span class="c1">#            for fmt in fmt_expr_dict.keys():</span>
<span class="c1">#                for r in fmt_expr_dict[fmt]:</span>
<span class="c1">#                    if r.search(line) is not None:</span>
<span class="c1">#                        ident_fmt = fmt</span>
<span class="c1">#                        break</span>
<span class="c1">#                if ident_fmt is not None:</span>
<span class="c1">#                    break</span>
<span class="c1">#</span>
<span class="c1">#    # Check that a format was found.</span>
<span class="c1">#    assert ident_fmt is not None, &quot;&quot;&quot;Error: Could not identify format for</span>
<span class="c1">#    search result file: %s&quot;&quot;&quot; % search_result_path</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    # Get program name (without version).</span>
<span class="c1">#    #possible_progs = [&#39;blastp&#39;,</span>
<span class="c1">#    #                  &#39;tblastn&#39;,</span>
<span class="c1">#    #                  &#39;blastx&#39;,</span>
<span class="c1">#    #                  &#39;blastn&#39;,</span>
<span class="c1">#    #                  &#39;phmmer&#39;,</span>
<span class="c1">#    #                  &#39;hmmsearch&#39;,</span>
<span class="c1">#    #                  &#39;nhmmer&#39;,</span>
<span class="c1">#    #                  &#39;hmmscan&#39;</span>
<span class="c1">#    #                  ]</span>
<span class="c1">#    #ident_prog = None</span>
<span class="c1">#    #for p in possible_progs:</span>
<span class="c1">#    #    if p in ident_fmt:</span>
<span class="c1">#    #        ident_prog = p</span>
<span class="c1">#    ident_prog = None</span>
<span class="c1">#    with open(search_result_path) as srh:</span>
<span class="c1">#        ident_prog = SearchIO.read(srh, ident_fmt).program</span>
<span class="c1">#    assert ident_prog is not None, &quot;&quot;&quot;Could not identify program name from file</span>
<span class="c1">#    format type.&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    ## Define regular expressions that will only match any line in a file if it</span>
<span class="c1">#    ## was generated using a certain program.</span>
<span class="c1">#    #prog_expr_dict = {&#39;blastp&#39;: [re.compile(r&#39;^&lt;!DOCTYPE BlastOutput&#39;)],</span>
<span class="c1">#    #                 &#39;hmmsearch&#39;: [re.compile(r&#39;^# Option settings: hmmsearch --tblout&#39;)]</span>
<span class="c1">#    #                 }</span>
<span class="c1">#</span>
<span class="c1">#    ## See if any of the regular expressions match the file.</span>
<span class="c1">#    #ident_prog = None</span>
<span class="c1">#    #with open(search_result_path) as srh:</span>
<span class="c1">#    #    for line in srh:</span>
<span class="c1">#    #        for prog in prog_expr_dict.keys():</span>
<span class="c1">#    #            for r in prog_expr_dict[prog]:</span>
<span class="c1">#    #                if r.search(line) is not None:</span>
<span class="c1">#    #                    ident_prog = prog</span>
<span class="c1">#    #                    break</span>
<span class="c1">#    #            if ident_prog is not None:</span>
<span class="c1">#    #                break</span>
<span class="c1">#</span>
<span class="c1">#    ## Check that the program name was found.</span>
<span class="c1">#    #assert ident_prog is not None, &quot;&quot;&quot;Error: Could not identify name of program</span>
<span class="c1">#    #used to generate search result file: %s&quot;&quot;&quot; % search_result_path</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    # Define regular expressions that will only match any line in a file if it</span>
<span class="c1">#    # was generated using a certain program.</span>
<span class="c1">#    #prog_vers_expr_dict = {&#39;blast_vers&#39;: [re.compile(r&#39;  &lt;BlastOutput_version&gt;.+&lt;/BlastOutput_version&gt;&#39;)],</span>
<span class="c1">#    #                       &#39;hmmer_vers&#39;: [re.compile(r&#39;# Version:.+&#39;)]</span>
<span class="c1">#    #                      }</span>
<span class="c1">#</span>
<span class="c1">#    # Decide which dict key to use based on identified program version, and</span>
<span class="c1">#    # then identify version in file.</span>
<span class="c1">#    ident_vers = None</span>
<span class="c1">#    #vers_key = None</span>
<span class="c1">#    with open(search_result_path) as srh:</span>
<span class="c1">#        ident_vers = SearchIO.read(srh, ident_fmt).version</span>
<span class="c1">#</span>
<span class="c1">#    #        vers_key = &#39;blast-vers&#39;</span>
<span class="c1">#    #        for line in srh:</span>
<span class="c1">#    #            if prog_vers_expr_dict[vers_key].match(line):</span>
<span class="c1">#    #                ident_vers =\</span>
<span class="c1">#    #                str(prog_vers_expr_dict[vers_key].match(line)).split(&#39;&lt;&#39;)[0].split(&#39;&gt;&#39;)[1]</span>
<span class="c1">#    #                if r.search(line) is not None:</span>
<span class="c1">#    #                    ident_vers = prog_vers_</span>
<span class="c1">#    #                    break</span>
<span class="c1">#    #            if ident_vers is not None:</span>
<span class="c1">#    #                break</span>
<span class="c1">#           </span>
<span class="c1">#    #    elif &#39;hmm&#39; in ident_prog:</span>
<span class="c1">#    #        vers_key = &#39;hmmer-vers&#39;</span>
<span class="c1">#    #        for line in srh:</span>
<span class="c1">#    #            for r in prog_vers_expr_dict[vers_key]:</span>
<span class="c1">#    #                if r.search(line) is not None:</span>
<span class="c1">#    #                    ident_vers = ...</span>
<span class="c1">#    #                    break</span>
<span class="c1">#    #            if ident_vers is not None:</span>
<span class="c1">#    #                break</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    # Check that it worked.</span>
<span class="c1">#    #assert vers_key is not None, &quot;&quot;&quot;Could not determine which key to use for</span>
<span class="c1">#    #the prog_vers_expr_dict.&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    # Check that the program version was found.</span>
<span class="c1">#    assert ident_vers is not None, &quot;&quot;&quot;Error: Could not identify name of program</span>
<span class="c1">#    used to generate search result file: %s&quot;&quot;&quot; % search_result_path</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    # Return a list defining the input file format.</span>
<span class="c1">#    return [ident_prog, ident_vers, ident_fmt]</span>


<div class="viewcode-block" id="get_corr_evalue"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_corr_evalue">[docs]</a><span class="k">def</span> <span class="nf">get_corr_evalue</span><span class="p">(</span><span class="n">evalue</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">evalue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">evalue</span> <span class="o">=</span> <span class="mf">1e-300</span>
    <span class="k">return</span> <span class="n">evalue</span></div>


<div class="viewcode-block" id="get_redun_hits_in_dbs"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_redun_hits_in_dbs">[docs]</a><span class="k">def</span> <span class="nf">get_redun_hits_in_dbs</span><span class="p">(</span><span class="n">query_title</span><span class="p">,</span> <span class="n">query_file_list</span><span class="p">,</span> <span class="n">db_file_list</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">,</span>
        <span class="n">outdir</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds all items (sequences or profiles) in each given database file</span>
<span class="sd">    (fasta or hmm databases) that may be positive hits for query title (e.g.,</span>
<span class="sd">    &#39;VAMP7&#39; or &#39;R-SNAREs&#39;) for each given query file (sequence or profile) and</span>
<span class="sd">    appends a record of these hits to a given spreadsheet file path for later</span>
<span class="sd">    manual annotation to distinguish positive(redundant) hits from negative</span>
<span class="sd">    hits. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make an output spreadsheet file if it does not already exist.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">csv_file</span><span class="p">):</span>
        <span class="c1"># Define string for header line in output spreadseheet.</span>
        <span class="n">header_line</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;Query Title&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Query File&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Database File&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Search Method&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Positive/redundant (+) or negative (-) hit for queries with query title (edit this column)&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Hit Number&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;E-value&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Order of magnitude of E-value difference compared to top hit&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Length as percent of top hit sequence length&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Accession&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Description&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                <span class="p">])</span>

        <span class="c1"># Write header line to spreadsheet.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvh</span><span class="p">:</span>
            <span class="n">csvh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header_line</span><span class="p">)</span>

    <span class="c1"># Use another function to run searches and write results to outputdir.</span>
    <span class="n">run_all_searches</span><span class="p">(</span><span class="n">query_file_list</span><span class="p">,</span> <span class="n">db_file_list</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span>

    <span class="c1"># Manage assignment of query title(s).</span>
    <span class="n">find_query_titles</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">query_title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">find_query_titles</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Parse search results and write summary to output.</span>
    <span class="c1"># ***The first part of this code block could perhaps be abstracted to</span>
    <span class="c1"># another function, because it will be needed as the first step in</span>
    <span class="c1"># interpreting results of forward and reverse searches as well.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="c1"># Loop over query file names.</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">query_file_list</span><span class="p">:</span>
            <span class="c1"># Define query title to use.</span>
            <span class="k">if</span> <span class="n">find_query_titles</span><span class="p">:</span>
                <span class="n">query_title</span> <span class="o">=</span> <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_query_title_from_csv</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="c1"># Loop over database file names.</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">db_file_list</span><span class="p">:</span>
                <span class="c1"># Find relevant result file in output directory.</span>
                <span class="n">search_result_path</span> <span class="o">=</span> <span class="n">search_result_filepath</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span>

                <span class="c1"># Determine file format of search result file.</span>
                <span class="c1"># For certain formats the search method is required, so may</span>
                <span class="c1"># need to figure out how to get that info later (see</span>
                <span class="c1"># http://biopython.org/DIST/docs/api/Bio.SearchIO-module.html)</span>
                <span class="c1">#srch_file_prog_vers_fmt = module_amoebae_srchresfile.get_srch_file_info(search_result_path)</span>
                <span class="c1">#srch_file_prog = srch_file_prog_vers_fmt[0]</span>
                <span class="c1">#srch_file_prog_vers = srch_file_prog_vers_fmt[1]</span>
                <span class="c1">#srch_file_format = srch_file_prog_vers_fmt[2]</span>

                <span class="n">parsed_file_obj</span> <span class="o">=</span> <span class="n">SrchResFile</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">)</span>
                <span class="n">srch_file_prog</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">program</span>
                <span class="n">srch_file_prog_vers</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">version</span>
                <span class="n">srch_file_format</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">format</span>

                <span class="c1"># Loop over hits (objects) in search result file.</span>
                <span class="n">hit_num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">top_hit_evalue</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_evalue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">top_hit_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_sequence</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">,</span> <span class="n">srch_file_format</span><span class="p">):</span> 
                    <span class="n">hit_num</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Get E-value difference between current hit and top hit</span>
                    <span class="c1"># top HSPs.</span>
                    <span class="n">e_top</span> <span class="o">=</span> <span class="n">top_hit_evalue</span>
                    <span class="n">e_cur</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_evalue</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span>
                    <span class="n">evaldiff</span> <span class="o">=</span> <span class="n">get_evaldiff</span><span class="p">(</span><span class="n">get_corr_evalue</span><span class="p">(</span><span class="n">e_top</span><span class="p">),</span>\
                            <span class="n">get_corr_evalue</span><span class="p">(</span><span class="n">e_cur</span><span class="p">))</span>

                    <span class="c1"># Get hit length as a percentage of the top hit sequence</span>
                    <span class="c1"># length.</span>
                    <span class="n">cur_hit_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_sequence</span><span class="p">(</span><span class="n">hit_num</span><span class="p">))</span>
                    <span class="n">percent_len</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">cur_hit_len</span> <span class="o">/</span> <span class="n">top_hit_len</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

                    <span class="c1"># Append line with relevant info to spreadsheet.</span>
                    <span class="n">line_to_write</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">query_title</span><span class="p">,</span> 
                                      <span class="n">q</span><span class="p">,</span>
                                      <span class="n">d</span><span class="p">,</span> 
                                      <span class="n">srch_file_prog</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">srch_file_prog_vers</span><span class="p">,</span>
                                      <span class="s1">&#39;-&#39;</span><span class="p">,</span> 
                                      <span class="nb">str</span><span class="p">(</span><span class="n">hit_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> 
                                      <span class="nb">str</span><span class="p">(</span><span class="n">e_cur</span><span class="p">),</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="n">evaldiff</span><span class="p">),</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="n">percent_len</span><span class="p">),</span>
                                      <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_id</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">,</span>
                                      <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_description</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span>
                                      <span class="p">])</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line_to_write</span><span class="p">)</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># Remove output directory?</span>
    <span class="c1">#os.remove(...)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;DONE!&#39;</span><span class="p">)</span>

    <span class="c1"># Return path to main output file.</span>
    <span class="k">return</span> <span class="n">csv_file</span> </div>


<div class="viewcode-block" id="get_query_len"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_query_len">[docs]</a><span class="k">def</span> <span class="nf">get_query_len</span><span class="p">(</span><span class="n">query_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a query filename, gets the full path, get the query type, and</span>
<span class="sd">    returns the query length (assumes fasta, because even for HMMer searches</span>
<span class="sd">    the query listed will be .afaa).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">query_length</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Get full path.</span>
    <span class="n">query_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">querydirpath</span><span class="p">,</span> <span class="n">query_filename</span><span class="p">)</span>

    <span class="c1"># Get query length.</span>
    <span class="n">query_length</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">query_path</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
        <span class="n">query_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">break</span>

    <span class="c1"># Check that it worked.</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">query_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not determine query length for</span>
<span class="s2">    query file: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">query_filename</span>

    <span class="c1"># Return length.</span>
    <span class="k">return</span> <span class="n">query_length</span></div>


<div class="viewcode-block" id="get_subsequences_matching_query"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_subsequences_matching_query">[docs]</a><span class="k">def</span> <span class="nf">get_subsequences_matching_query</span><span class="p">(</span><span class="n">hit_obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a SearchIO hit object, and returns a list with the first element</span>
<span class="sd">    being a string representing the coordinates of the query to which the</span>
<span class="sd">    subject sequence aligns, and the second being the corresponding subject</span>
<span class="sd">    subsequence(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ***Eventually add more sophisticated approach similar to</span>
    <span class="c1"># search_scaffolds.py, so that multiple HSPs can be represented.</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">hit_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">query_range</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>\
            <span class="nb">str</span><span class="p">(</span><span class="n">hit_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hit</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)]</span></div>


<div class="viewcode-block" id="get_hit_obj_for_hsp_cluster"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_hit_obj_for_hsp_cluster">[docs]</a><span class="k">def</span> <span class="nf">get_hit_obj_for_hsp_cluster</span><span class="p">(</span><span class="n">query_res_obj</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a SearchIO QueryResult object and a list of HSPs, and return the</span>
<span class="sd">    Hit object from the QueryResult object that contains the HSPs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Search for hits that contain the HSPs.</span>
    <span class="n">hit_obj</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">query_res_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_id</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hit_id</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hsp</span><span class="o">.</span><span class="n">hit_description</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hit_description</span><span class="p">:</span>
                    <span class="n">hit_obj</span> <span class="o">=</span> <span class="n">hit</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Check that a hit was found.</span>
    <span class="k">assert</span> <span class="n">hit_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify a Hit object that</span>
<span class="s2">    contains the given list of HSPs.&quot;&quot;&quot;</span>

    <span class="c1"># Return the Hit object.</span>
    <span class="k">return</span> <span class="n">hit_obj</span></div>


<div class="viewcode-block" id="get_rows_for_fwd_srch_df"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_rows_for_fwd_srch_df">[docs]</a><span class="k">def</span> <span class="nf">get_rows_for_fwd_srch_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">search_result_path</span><span class="p">,</span> <span class="n">column_label_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses search result file and adds a corresponding row to an output</span>
<span class="sd">    pandas dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parse given search output file.</span>
    <span class="n">parsed_file_obj</span> <span class="o">=</span> <span class="n">SrchResFile</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">)</span>
    <span class="n">srch_file_prog</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">program</span>
    <span class="n">srch_file_prog_vers</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">version</span>
    <span class="n">srch_file_format</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">format</span>

    <span class="c1"># Extract some initial info.</span>
    <span class="n">query_len</span> <span class="o">=</span> <span class="n">get_query_len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">query_res_obj</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">,</span>\
            <span class="n">srch_file_format</span><span class="p">)</span>

    <span class="c1"># Determine the number of hits in the search result file.</span>
    <span class="n">num_hits</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">num_hits</span>

    <span class="c1">## Modify the Bio.SearchIO query result object if the search program was</span>
    <span class="c1">## tblastn, such that HSPs are grouped as separate hits if they likely</span>
    <span class="c1">## represent separate genes. ???</span>
    <span class="c1">##hit_list = query_res_obj.hits</span>
    <span class="c1">#if query_res_obj.program == &#39;tblastn&#39; and num_hits &gt; 0:</span>
    <span class="c1">#    query_res_obj = split_tblastn_hits_into_separate_genes(query_res_obj, settings.max_gap)</span>
    <span class="c1">#    #hit_list = split_tblastn_hits_into_separate_genes(query_res_obj, settings.max_gap)</span>
        
    <span class="c1"># Define a sub-dataframe to populate and return.</span>
    <span class="n">subdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">column_label_list</span><span class="p">)</span> <span class="c1"># Define query title to use.</span>
    <span class="n">query_title</span> <span class="o">=</span> <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_query_title_from_csv</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="c1"># Initiate dataframe for a new row to append to dataframe</span>
    <span class="c1"># for output.</span>
    <span class="n">new_row_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">column_label_list</span><span class="p">)</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_label_list</span><span class="p">)</span>
    <span class="c1">#new_row_df.loc[0] = [&#39;not???&#39;] * len(column_label_list) # Temp</span>

    <span class="c1"># Fill in info to row.</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Query title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_title</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Query file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Query species (if applicable)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_query_taxon_from_csv</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="c1"># Get &quot;taxon&quot; from query filename.</span>
    <span class="n">taxon</span> <span class="o">=</span> <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_query_taxon_from_filename</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="c1"># Use query &quot;taxon&quot; to look up the database, if any, that</span>
    <span class="c1"># the query came from (in the query info csv file).</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Query database name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_db_filename_for_query_from_db_csv</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>

    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Query accession (if applicable)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_res_obj</span><span class="o">.</span><span class="n">id</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Query description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_res_obj</span><span class="o">.</span><span class="n">description</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Query length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_len</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Subject database species (if applicable)&#39;</span><span class="p">]</span> <span class="o">=</span>\
        <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_species_for_db_filename</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="c1">### PROBLEM?</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Subject database file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward search method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">srch_file_prog</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">srch_file_prog_vers</span>


    <span class="k">if</span> <span class="n">num_hits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># No hits to record.</span>
        <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit rank&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>

        <span class="c1"># Append row dataframe to dataframe for output.</span>
        <span class="n">subdf</span> <span class="o">=</span> <span class="n">subdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row_df</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">num_hits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># ***Note: TBLASTN results are parsed very differently from results of</span>
        <span class="c1"># searches into protein databases, because a single subject sequence</span>
        <span class="c1"># (chromosome, scaffold, etc) may contain HSPs that represent different</span>
        <span class="c1"># genes. To account for this, the code below allows these to be</span>
        <span class="c1"># recorded as separate hits in the forward search summary.</span>
        <span class="k">if</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">program</span> <span class="o">==</span> <span class="s1">&#39;tblastn&#39;</span><span class="p">:</span>
            <span class="c1"># Get list of lists of HSPs corresponding to each potential gene in</span>
            <span class="c1"># the subject sequences.</span>
            <span class="n">max_gap</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">max_gap</span>
            <span class="n">hsp_clusters</span> <span class="o">=</span> <span class="n">split_tblastn_hits_into_separate_genes</span><span class="p">(</span><span class="n">query_res_obj</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span>

            <span class="n">hit_num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># These lines are problematic...:</span>
            <span class="n">top_hit_evalue</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_evalue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># CHANGE!!!</span>
            <span class="n">top_hit_score</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># CHANGE!!!</span>
            <span class="n">top_hit_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_sequence</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># CHANGE!!!</span>
            <span class="c1"># Iterate over clusters of HSPs.</span>
            <span class="c1">#for hit in hit_list: </span>
            <span class="c1">#print(&#39;\n\tProcessing clusters of HSPs within hits&#39;)</span>
            <span class="k">for</span> <span class="n">clusterplus</span> <span class="ow">in</span> <span class="n">hsp_clusters</span><span class="p">:</span> 
                <span class="n">cluster</span> <span class="o">=</span> <span class="n">clusterplus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#row_num += 1</span>
                <span class="n">hit_num</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># Get SearchIO Hit object from QueryResult object that</span>
                <span class="c1"># corresponds to the HSPs in the cluster.</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">get_hit_obj_for_hsp_cluster</span><span class="p">(</span><span class="n">query_res_obj</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>

                <span class="c1"># Print message about the cluster.</span>
                <span class="c1">#print(&#39;\t\tCluster &#39; + str(hit_num + 1) + &#39;: &#39; + str(len(cluster)) +\</span>
                <span class="c1">#&#39; HSPs in subject sequence &#39; + hit.id + &#39; &#39; + hit.description)</span>

                <span class="c1"># Get score difference between current hit and top hit.</span>
                <span class="n">score_cur</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">bitscore</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">])</span>
                <span class="n">scorediff</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">score_cur</span> <span class="o">-</span> <span class="n">top_hit_score</span><span class="p">))</span>

                <span class="c1"># Get E-value difference between current hit and top hit</span>
                <span class="c1"># top HSPs.</span>
                <span class="n">e_top</span> <span class="o">=</span> <span class="n">top_hit_evalue</span>
                <span class="n">e_cur</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">evalue</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">])</span>
                <span class="n">evaldiff</span> <span class="o">=</span> <span class="n">get_evaldiff</span><span class="p">(</span><span class="n">get_corr_evalue</span><span class="p">(</span><span class="n">e_top</span><span class="p">),</span> <span class="n">get_corr_evalue</span><span class="p">(</span><span class="n">e_cur</span><span class="p">))</span>

                <span class="c1"># Get a sequence record.</span>
                <span class="n">hit_seq_record_and_coord</span> <span class="o">=</span> <span class="n">get_hit_seq_record_and_coord</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
                <span class="n">hit_seq</span> <span class="o">=</span> <span class="n">hit_seq_record_and_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 

                <span class="c1"># Get hit length as a percentage of the top hit sequence</span>
                <span class="c1"># length.</span>
                <span class="n">cur_hit_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hit_seq</span><span class="p">)</span>
                <span class="n">percent_len</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">cur_hit_len</span> <span class="o">/</span> <span class="n">top_hit_len</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit rank&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit_num</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">score_cur</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit score difference from top hit score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scorediff</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit E-value (top HSP)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_cur</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit E-value (top HSP) order of magnitude difference compared to top hit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">evaldiff</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_hit_len</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit length as a percentage of query length&#39;</span><span class="p">]</span> <span class="o">=</span>\
                        <span class="nb">round</span><span class="p">((</span><span class="n">cur_hit_len</span><span class="o">/</span><span class="n">query_len</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
                <span class="c1">#new_row_df.loc[0][&#39;Forward hit accession&#39;] = hit.id + &#39;_(fwdhit&#39; + str(hit_num + 1) + &#39;)&#39; </span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit accession&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">description</span>


                <span class="c1"># Need to handle nucleotide and protein sequences</span>
                <span class="c1"># differently!</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

                <span class="c1"># Get subsequence(s) to use for reverse search.</span>
                <span class="c1">#range_and_seq = get_subsequences_matching_query(hit)</span>
                <span class="c1">#new_row_df.loc[0][&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;] =\</span>
                <span class="c1">#range_and_seq[0] </span>
                <span class="c1">#new_row_df.loc[0][&#39;Forward hit subsequence(s) that align(s) to query&#39;] = range_and_seq[1]</span>

                <span class="n">subseq_and_coord</span> <span class="o">=</span> <span class="n">hit_seq_record_and_coord</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="nb">str</span><span class="p">(</span><span class="n">subseq_and_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit description of subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>\
                    <span class="o">=</span> <span class="n">subseq_and_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">description</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>\
                <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">subseq_and_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>

                <span class="c1"># Fill in info about how close the hit is to the ends of the</span>
                <span class="c1"># subject sequence (searching in nucleotide data, do nothing</span>
                <span class="c1"># otherwise).</span>
                <span class="n">cluster_range</span> <span class="o">=</span> <span class="n">get_cluster_range</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
                <span class="n">subject_seq_len</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">seq_len</span>
                <span class="n">proximity</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">cluster_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subject_seq_len</span> <span class="o">-</span> <span class="n">cluster_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Proximity (bp) to end of subject sequence (if searching in nucleotide sequences)&#39;</span><span class="p">]</span>\
                <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">proximity</span><span class="p">)</span>


                <span class="c1"># Decide whether the E-value is low enough to meet the</span>
                <span class="c1"># cutoff.</span>
                <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="k">if</span> <span class="n">e_cur</span> <span class="o">&lt;=</span> <span class="n">settings</span><span class="o">.</span><span class="n">evalue_cutoff</span><span class="p">:</span>
                    <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit based on E-value criterion&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decis</span>

                <span class="c1"># Make sure that all the info was identified and added to</span>
                <span class="c1"># the row.</span>
                <span class="c1">#assert not &#39;???&#39; in list(new_row_df.loc[0]), &quot;&quot;&quot;Could not find</span>
                <span class="c1">#all information.&quot;&quot;&quot;</span>


                <span class="c1"># Append row dataframe to dataframe for output.</span>
                <span class="n">subdf</span> <span class="o">=</span> <span class="n">subdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row_df</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Loop over hits in query_res_obj...</span>
            <span class="n">hit_num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">top_hit_evalue</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_evalue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">top_hit_score</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">top_hit_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_sequence</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="c1">#for hit in hit_list: </span>
            <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">query_res_obj</span><span class="p">:</span> 
                <span class="c1">#row_num += 1</span>
                <span class="n">hit_num</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># Get score difference between current hit and top hit.</span>
                <span class="n">score_cur</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_score</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span>
                <span class="n">scorediff</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">score_cur</span> <span class="o">-</span> <span class="n">top_hit_score</span><span class="p">))</span>

                <span class="c1"># Get E-value difference between current hit and top hit</span>
                <span class="c1"># top HSPs.</span>
                <span class="n">e_top</span> <span class="o">=</span> <span class="n">top_hit_evalue</span>
                <span class="n">e_cur</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_evalue</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span>
                <span class="n">evaldiff</span> <span class="o">=</span> <span class="n">get_evaldiff</span><span class="p">(</span><span class="n">get_corr_evalue</span><span class="p">(</span><span class="n">e_top</span><span class="p">),</span> <span class="n">get_corr_evalue</span><span class="p">(</span><span class="n">e_cur</span><span class="p">))</span>

                <span class="c1"># Get hit length as a percentage of the top hit sequence</span>
                <span class="c1"># length.</span>
                <span class="n">hit_seq</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_sequence</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span> 
                <span class="n">cur_hit_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hit_seq</span><span class="p">)</span>
                <span class="n">percent_len</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">cur_hit_len</span> <span class="o">/</span> <span class="n">top_hit_len</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit rank&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit_num</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">score_cur</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit score difference from top hit score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scorediff</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit E-value (top HSP)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_cur</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit E-value (top HSP) order of magnitude difference compared to top hit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">evaldiff</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_hit_len</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit length as a percentage of query length&#39;</span><span class="p">]</span> <span class="o">=</span>\
                        <span class="nb">round</span><span class="p">((</span><span class="n">cur_hit_len</span><span class="o">/</span><span class="n">query_len</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit accession&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_id</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_description</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span>


                <span class="c1"># Need to handle nucleotide and protein sequences</span>
                <span class="c1"># differently!</span>
                <span class="k">if</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">program</span> <span class="o">==</span> <span class="s1">&#39;tblastn&#39;</span><span class="p">:</span>
                    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">hit_seq</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>

                <span class="c1"># Get subsequence(s) to use for reverse search.</span>
                <span class="c1">#range_and_seq = get_subsequences_matching_query(hit)</span>
                <span class="c1">#new_row_df.loc[0][&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;] =\</span>
                <span class="c1">#range_and_seq[0] </span>
                <span class="c1">#new_row_df.loc[0][&#39;Forward hit subsequence(s) that align(s) to query&#39;] = range_and_seq[1]</span>

                <span class="n">subseq_and_coord</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_subsequence_and_coord</span><span class="p">(</span><span class="n">hit_num</span><span class="p">)</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="nb">str</span><span class="p">(</span><span class="n">subseq_and_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit description of subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>\
                    <span class="o">=</span> <span class="n">subseq_and_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">description</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Forward hit subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>\
                <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">subseq_and_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>

                <span class="c1"># Decide whether the E-value is low enough to meet the</span>
                <span class="c1"># cutoff.</span>
                <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="k">if</span> <span class="n">e_cur</span> <span class="o">&lt;=</span> <span class="n">settings</span><span class="o">.</span><span class="n">evalue_cutoff</span><span class="p">:</span>
                    <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
                <span class="n">new_row_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit based on E-value criterion&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decis</span>

                <span class="c1"># Make sure that all the info was identified and added to</span>
                <span class="c1"># the row.</span>
                <span class="c1">#assert not &#39;???&#39; in list(new_row_df.loc[0]), &quot;&quot;&quot;Could not find</span>
                <span class="c1">#all information.&quot;&quot;&quot;</span>


                <span class="c1"># Append row dataframe to dataframe for output.</span>
                <span class="n">subdf</span> <span class="o">=</span> <span class="n">subdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row_df</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Return populated sub-dataframe to append to full dataframe.</span>
    <span class="k">return</span> <span class="n">subdf</span></div>


<div class="viewcode-block" id="write_fwd_srch_res_to_csv"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.write_fwd_srch_res_to_csv">[docs]</a><span class="k">def</span> <span class="nf">write_fwd_srch_res_to_csv</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">query_file_list</span><span class="p">,</span> <span class="n">db_file_list</span><span class="p">,</span>
        <span class="n">csv_file</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse output of a forward search (from running the fwd_srch command of</span>
<span class="sd">    amoebae) and append rows to input csv with information for interpreting</span>
<span class="sd">    the forward results. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get database info spreadsheet path from settings module.</span>
    <span class="n">db_info_csv</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">db_info_csv</span>

    <span class="c1"># Define string for header line in output spreadseheet.</span>
    <span class="c1"># ***If this is changed, then make sure to change the corresponding code</span>
    <span class="c1"># for filling in data into the rows (below).</span>
    <span class="n">column_label_list</span> <span class="o">=</span> <span class="n">module_amoebae_column_header_lists</span><span class="o">.</span><span class="n">fwd_column_label_list</span>

    <span class="c1"># Make an output spreadsheet file if it does not already exist.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">csv_file</span><span class="p">):</span>
        <span class="c1">## Write header line to spreadsheet.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvh</span><span class="p">:</span>
            <span class="n">csvh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">column_label_list</span><span class="p">))</span>


    <span class="c1"># Get data from input file.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span> <span class="c1">#, index_col=0)</span>

    <span class="c1"># Check that the headers match up the main spreadsheet and</span>
    <span class="c1"># the row to be appended.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span> <span class="o">==</span>\
    <span class="nb">len</span><span class="p">(</span><span class="n">column_label_list</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Unexpected number of column</span>
<span class="s2">    headers in input spreadsheet.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">column_label_list</span><span class="p">),</span>\
    <span class="sd">&quot;&quot;&quot;Input spreadsheet has different column header names than</span>
<span class="sd">    expected.&quot;&quot;&quot;</span>

    <span class="n">num_searches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_file_list</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">db_file_list</span><span class="p">)</span>

    <span class="c1"># Parse search results and write summary to output.</span>
    <span class="c1">#row_num = -1</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span> 
        <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Loop over query file names.</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">query_file_list</span><span class="p">:</span>
            <span class="c1"># Define query title to use.</span>
            <span class="c1">#query_title = module_amoebae.get_query_title_from_csv(q)</span>
            <span class="c1"># Loop over database file names.</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">db_file_list</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Result &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_searches</span><span class="p">))</span>
                <span class="c1"># Temporary &#39;if&#39; statement???</span>
                <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;afaa&#39;</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fna&#39;</span><span class="p">:</span>
                    <span class="n">warning_text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s2">WARNING: Assuming that did not search</span>
<span class="s2">                    with profile query </span><span class="si">%s</span><span class="s2"> in nucleotide data </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">warning_text</span><span class="p">)</span>
                    <span class="c1">#o.write(warning_text)</span>

                <span class="c1">## TEMPORARY elif statement:</span>
                <span class="c1">#elif d.startswith(&#39;Zmays&#39;):</span>
                <span class="c1">#    print(&#39;Skipping Zea mays result to save time&#39;)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Find relevant result file in output directory.</span>
                    <span class="n">search_result_path</span> <span class="o">=</span> <span class="n">search_result_filepath</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span>

                    <span class="c1"># Print activity.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Extracting information from search result file &#39;</span> <span class="o">+</span>\
                            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">))</span>

                    <span class="c1"># Determine file format of search result file.</span>
                    <span class="c1"># For certain formats the search method is required, so may</span>
                    <span class="c1"># need to figure out how to get that info later (see</span>
                    <span class="c1"># http://biopython.org/DIST/docs/api/Bio.SearchIO-module.html)</span>
                    <span class="n">parsed_file_obj</span> <span class="o">=</span> <span class="n">SrchResFile</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">)</span>
                    <span class="n">srch_file_prog</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">program</span>
                    <span class="n">srch_file_prog_vers</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">version</span>
                    <span class="n">srch_file_format</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">format</span>

                    <span class="c1"># Get rows to add to forward search dataframe from info from</span>
                    <span class="c1"># the search output file.</span>
                    <span class="c1">#subdf = get_rows_for_fwd_srch_df(df, q, d, search_result_path, srch_file_prog,</span>
                    <span class="c1">#        srch_file_prog_vers, srch_file_format,</span>
                    <span class="c1">#        column_label_list)</span>
                    <span class="n">subdf</span> <span class="o">=</span> <span class="n">get_rows_for_fwd_srch_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">search_result_path</span><span class="p">,</span>
                            <span class="n">column_label_list</span><span class="p">)</span>

                    <span class="c1"># Append sub-dataframe to full dataframe.</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subdf</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Write updated dataframe to output spreadsheet.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing dataframe to csv file&#39;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">csv_file</span> <span class="o">+</span> <span class="s1">&#39;_out.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Return main output path.</span>
    <span class="k">return</span> <span class="n">csv_file</span> </div>


<span class="c1">#def get_query_subdir(outdir):</span>
<span class="c1">#    &quot;&quot;&quot;Takes a reverse-search output directory and returns a path for a reverse</span>
<span class="c1">#    search query subdirectory.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    return os.path.join(outdir, &#39;0_rev_srch_queries&#39;)</span>


<div class="viewcode-block" id="get_rev_query_path_from_fwd_srch_row"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_rev_query_path_from_fwd_srch_row">[docs]</a><span class="k">def</span> <span class="nf">get_rev_query_path_from_fwd_srch_row</span><span class="p">(</span><span class="n">query_subdir</span><span class="p">,</span> <span class="n">df_row</span><span class="p">,</span> <span class="n">aasubseq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path for a directory containing reverse search queries (or to</span>
<span class="sd">    write such files to), and a row from a forward search summary csv parsed</span>
<span class="sd">    with pandas, and returns a path for the corresponding reverse search query</span>
<span class="sd">    file to be written or read.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Only use the first 50 characters of the coordinates string.</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">df_row</span><span class="p">[</span><span class="s1">&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span>
    <span class="c1"># Unless using the full amino acid sequence.</span>
    <span class="k">if</span> <span class="n">df_row</span><span class="p">[</span><span class="s1">&#39;Subject database file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;faa&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aasubseq</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;full&#39;</span>

    <span class="n">acc</span> <span class="o">=</span> <span class="n">df_row</span><span class="p">[</span><span class="s1">&#39;Forward hit accession&#39;</span><span class="p">]</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="c1">#acc = acc.replace(&#39;:&#39;, &#39;_&#39;)</span>
    <span class="c1">#acc = acc.replace(&#39;+&#39;, &#39;_&#39;)</span>

    <span class="c1"># Define the reverse search query filepath.</span>
    <span class="n">rev_query_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">query_subdir</span><span class="p">,</span>
            <span class="n">acc</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span>\
            <span class="n">description</span>\
            <span class="o">+</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">df_row</span><span class="p">[</span><span class="s1">&#39;Subject database file&#39;</span><span class="p">])</span>

    <span class="c1"># Change filename extension to .faa if .fna, because reverse searches only</span>
    <span class="c1"># performed with amino acid sequences. TEMPORARY, because need to</span>
    <span class="c1"># accomodate hhsearch, etc in the future.</span>
    <span class="n">rev_query_path</span> <span class="o">=</span> <span class="n">rev_query_path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.faa&#39;</span>

    <span class="k">return</span> <span class="n">rev_query_path</span></div>


<div class="viewcode-block" id="get_rev_queries"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_rev_queries">[docs]</a><span class="k">def</span> <span class="nf">get_rev_queries</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">query_subdir</span><span class="p">,</span> <span class="n">aasubseq</span><span class="p">,</span> <span class="n">nafullseq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a summary of forward search results, extract sequences to use as</span>
<span class="sd">    reverse search queries, write them to output files in a given directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read spreadsheet with forward search results.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>

    <span class="c1"># Loop over forward search hits, and select appropriate ones to write to</span>
    <span class="c1"># query files.</span>
    <span class="n">reverse_search_query_filepaths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">already_written_query_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="c1"># Only consider forward search hits that meet the E-value cutoff.</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit based on E-value criterion&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="c1"># Treat hits that are individual fasta sequences different than</span>
            <span class="c1"># hits that are profiles.</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Subject database file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.faa&#39;</span><span class="p">)</span>\
                    <span class="ow">or</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Subject database file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.fna&#39;</span><span class="p">):</span> 
                <span class="c1"># Then hit is a single fasta sequence.</span>

                <span class="c1"># Determine whether prot or nucl.</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_dbtype_from_file_exten</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Subject database file&#39;</span><span class="p">])</span>

                <span class="c1"># Determine alphabet to use.</span>
                <span class="c1">#?</span>

                <span class="c1"># Assign attributes from csv file differently depending on</span>
                <span class="c1"># whether the full sequence or a subsequence is to be used for</span>
                <span class="c1"># reverse search.</span>
                <span class="n">sequence</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">description</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">outexten</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;prot&#39;</span><span class="p">:</span>
                    <span class="c1">#outexten = &#39;.faa&#39;</span>
                    <span class="k">if</span> <span class="n">aasubseq</span><span class="p">:</span>
                        <span class="n">description</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>
                        <span class="n">sequence</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>
                    <span class="c1"># By default, use full sequence.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">description</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit description&#39;</span><span class="p">]</span>
                        <span class="n">sequence</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">]</span>

                <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;nucl&#39;</span><span class="p">:</span>
                    <span class="c1">#outexten = &#39;.fna&#39;</span>
                    <span class="k">if</span> <span class="n">nafullseq</span><span class="p">:</span>
                        <span class="n">description</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit description&#39;</span><span class="p">]</span>
                        <span class="n">sequence</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">]</span>
                    <span class="c1"># By default, use identified subsequence.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">description</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>
                        <span class="n">sequence</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>

                <span class="c1"># Check that it worked.</span>
                <span class="k">assert</span> <span class="n">sequence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not find which sequence</span>
<span class="s2">                to use for reverse search query.&quot;&quot;&quot;</span>
                <span class="k">assert</span> <span class="n">description</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not find which</span>
<span class="s2">                description to use for reverse search query.&quot;&quot;&quot;</span>

                <span class="c1"># Long sequence descriptions may be problematic, because used</span>
                <span class="c1"># in output filenames...</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">description</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Sequence description is</span>
<span class="s2">                really long.&quot;&quot;&quot;</span>
                
                <span class="c1"># Check whether sequence already added to reverse search</span>
                <span class="c1"># queries.</span>
                <span class="c1">#seq_ident_string = row[&#39;Subject database file&#39;] + row[&#39;Forward hit accession&#39;] + description</span>
                <span class="n">seq_ident_string</span> <span class="o">=</span>\
                <span class="n">get_rev_query_path_from_fwd_srch_row</span><span class="p">(</span><span class="n">query_subdir</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span>
                        <span class="n">aasubseq</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">seq_ident_string</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">already_written_query_list</span><span class="p">:</span>
                    <span class="c1"># Initiate sequence object to write to reverse search query</span>
                    <span class="c1"># file.</span>
                    <span class="n">row_seq_obj</span> <span class="o">=</span> <span class="n">SeqRecord</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="n">sequence</span><span class="p">))</span>
                    <span class="n">row_seq_obj</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit accession&#39;</span><span class="p">]</span>
                    <span class="n">row_seq_obj</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>

                    <span class="c1"># Define reverse search query file path (use description as</span>
                    <span class="c1"># name).</span>
                    <span class="c1"># (Use the &#39;Forward hit description&#39; and &#39;Forward hit</span>
                    <span class="c1"># description of sequence portion that aligns to query&#39; as</span>
                    <span class="c1"># applicable to determine which reverse search result needs</span>
                    <span class="c1"># to be summarized in which row of the spreadsheet for the</span>
                    <span class="c1"># sum_rev_srch command).</span>

                    <span class="c1"># Make sure there are no slash characters in the sequence</span>
                    <span class="c1"># description before using it to name a file (no longer</span>
                    <span class="c1"># necessary, because the description is no longer used to</span>
                    <span class="c1"># name the file).</span>
                    <span class="c1">#print(description)</span>
                    <span class="c1">#assert &#39;/&#39; not in description, &quot;&quot;&quot;Can&#39;t use sequence</span>
                    <span class="c1">#description to name query file, because it has a slash</span>
                    <span class="c1">#character in it.&quot;&quot;&quot;</span>

                    <span class="c1">#description = description.replace(&#39;__&#39;, &#39;_&#39;)</span>

                    <span class="c1"># Make sure there are no instances of &#39;__&#39; in the sequence</span>
                    <span class="c1"># description before using it to name a file (because that</span>
                    <span class="c1"># will be used to parse the description out).</span>
                    <span class="c1">#assert &#39;__&#39; not in description, &quot;&quot;&quot;Can&#39;t use sequence</span>
                    <span class="c1">#description to name query file, because it has a &#39;__&#39;</span>
                    <span class="c1">#(double underscore) in it.&quot;&quot;&quot;</span>

                    <span class="c1"># Define output filepath.</span>
                    <span class="c1">#rev_query_path = os.path.join(query_subdir,</span>
                    <span class="c1">#        row[&#39;Forward hit accession&#39;] + &#39;__&#39; +\</span>
                    <span class="c1">#        row[&#39;Forward hit coordinates of subsequence(s) that align(s) to query&#39;]\</span>
                    <span class="c1">#        + &#39;__&#39; + row[&#39;Subject database file&#39;])</span>
                    <span class="n">rev_query_path</span> <span class="o">=</span>\
                    <span class="n">get_rev_query_path_from_fwd_srch_row</span><span class="p">(</span><span class="n">query_subdir</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span>
                            <span class="n">aasubseq</span><span class="p">)</span>

                    <span class="c1"># Add query filepath to list for searching with.</span>
                    <span class="n">reverse_search_query_filepaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rev_query_path</span><span class="p">)</span>

                    <span class="c1"># Write sequence to filepath.</span>
                    <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">row_seq_obj</span><span class="p">,</span> <span class="n">rev_query_path</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>

                    <span class="c1"># Add query identity to list of those queries already used.</span>
                    <span class="n">already_written_query_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq_ident_string</span><span class="p">)</span>


            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Database consisted of profiles of some sort...</span>
                <span class="n">x</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">assert</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Can&#39;t handle forward search hits in profile</span>
<span class="s2">                databases yet...&quot;&quot;&quot;</span>

    <span class="c1"># Check that the list of queries written is nonredundant.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">already_written_query_list</span><span class="p">)</span> <span class="o">==</span>\
    <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">already_written_query_list</span><span class="p">)),</span> <span class="s2">&quot;&quot;&quot;Redundant queries written to</span>
<span class="s2">    reverse search query dir.&quot;&quot;&quot;</span>

    <span class="c1"># Return reverse search query filepath list (absolute file paths).</span>
    <span class="k">return</span> <span class="n">reverse_search_query_filepaths</span></div>


<div class="viewcode-block" id="get_csv_with_rev_path"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_csv_with_rev_path">[docs]</a><span class="k">def</span> <span class="nf">get_csv_with_rev_path</span><span class="p">(</span><span class="n">csv_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a csv file path and returns the name for a new version of the</span>
<span class="sd">    file, after addition of columns with info about reverse search results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">csv_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_1.csv&#39;</span></div>


<div class="viewcode-block" id="get_redun_hit_dict"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_redun_hit_dict">[docs]</a><span class="k">def</span> <span class="nf">get_redun_hit_dict</span><span class="p">(</span><span class="n">redun_hit_csv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a csv file listing redundant hits, and returns a nested dictionary</span>
<span class="sd">    with the structure:</span>
<span class="sd">    Query title &gt; query filename &gt; database filename &gt; [redun hit accs]</span>

<span class="sd">    Only works with information from searches into sequence data, not profile</span>
<span class="sd">    databases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load csv as a pandas dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">redun_hit_csv</span><span class="p">)</span>

    <span class="c1"># Construct dictionary.</span>
    <span class="n">redun_hit_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="c1"># Define information to use.</span>
        <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Query Title&#39;</span><span class="p">]</span>
        <span class="c1">#query_file = row[&#39;Query File&#39;]</span>
        <span class="n">db_file</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Database File&#39;</span><span class="p">]</span>
        <span class="n">decis</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit for queries with query title (edit this column)&#39;</span><span class="p">]</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Accession&#39;</span><span class="p">]</span>

        <span class="c1"># Make an empty list to begin with.</span>
        <span class="k">if</span> <span class="n">query_title</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">redun_hit_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">redun_hit_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#if query_file not in redun_hit_dict[query_title].keys():</span>
        <span class="c1">#    redun_hit_dict[query_title][query_file] = {}</span>
        <span class="c1">#if db_file not in redun_hit_dict[query_title][query_file].keys():</span>
        <span class="c1">#    redun_hit_dict[query_title][query_file][db_file] = []</span>
        <span class="k">if</span> <span class="n">db_file</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">redun_hit_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">redun_hit_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">][</span><span class="n">db_file</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Update dictionary if the row corresponds to a redundant hit.</span>
        <span class="k">if</span> <span class="n">decis</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="c1"># Otherwise just add accession to list.</span>
            <span class="c1">#redun_hit_dict[query_title][query_file][db_file] =\</span>
            <span class="c1">#    redun_hit_dict[query_title][query_file][db_file] + [acc]</span>
            <span class="n">redun_hit_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">][</span><span class="n">db_file</span><span class="p">]</span> <span class="o">=</span>\
                <span class="n">redun_hit_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">][</span><span class="n">db_file</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">acc</span><span class="p">]</span>

    <span class="c1"># Return the constructed dict.</span>
    <span class="k">return</span> <span class="n">redun_hit_dict</span></div>


<div class="viewcode-block" id="get_evaldiff"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.get_evaldiff">[docs]</a><span class="k">def</span> <span class="nf">get_evaldiff</span><span class="p">(</span><span class="n">evalue1</span><span class="p">,</span> <span class="n">evalue2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return absolute value of the order of magnitude evalue difference for</span>
<span class="sd">    two given E-values.  &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">evalue1</span><span class="p">),</span><span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">evalue2</span><span class="p">),</span><span class="mi">10</span><span class="p">)))</span></div>


<div class="viewcode-block" id="write_rev_srch_res_to_csv"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.write_rev_srch_res_to_csv">[docs]</a><span class="k">def</span> <span class="nf">write_rev_srch_res_to_csv</span><span class="p">(</span><span class="n">rev_srch_id</span><span class="p">,</span> <span class="n">outdir</span><span class="p">,</span> <span class="n">query_file_list</span><span class="p">,</span> <span class="n">db_file</span><span class="p">,</span>
        <span class="n">csv_file</span><span class="p">,</span> <span class="n">redun_hit_csv</span><span class="p">,</span> <span class="n">min_evaldiff</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">aasubseq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse output of a forward search (from running the fwd_srch command of</span>
<span class="sd">    amoebae) and append rows to input csv with information for interpreting</span>
<span class="sd">    the forward results. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">redun_hit_dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">redun_hit_csv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Get redundant hit dict from from input redundant hit csv file.</span>
        <span class="n">redun_hit_dict</span> <span class="o">=</span> <span class="n">get_redun_hit_dict</span><span class="p">(</span><span class="n">redun_hit_csv</span><span class="p">)</span>

    <span class="c1"># Get database info spreadsheet path from settings module.</span>
    <span class="n">db_info_csv</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">db_info_csv</span>

    <span class="c1"># Get same list of header titles that the sum_fwd_srch command makes (for</span>
    <span class="c1"># parsing).</span>
    <span class="n">fwd_column_label_list</span> <span class="o">=</span> <span class="n">module_amoebae_column_header_lists</span><span class="o">.</span><span class="n">fwd_column_label_list</span> 

    <span class="c1">## Make an output spreadsheet file if it does not already exist.</span>
    <span class="c1">#if not os.path.isfile(csv_file):</span>
    <span class="c1">#    ## Write header line to spreadsheet.</span>
    <span class="c1">#    with open(csv_file, &#39;w&#39;) as csvh:</span>
    <span class="c1">#        csvh.write(&#39;,&#39;.join(column_label_list))</span>


    <span class="c1"># Get data from input file.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Reading input csv file into a pandas dataframe.&#39;</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span> <span class="c1">#, index_col=0)</span>

    <span class="c1">## Check that the headers match up the main spreadsheet and</span>
    <span class="c1">## the row to be appended.</span>
    <span class="c1">#assert len(list(new_row_df.columns)) ==\</span>
    <span class="c1">#len(column_label_list), &quot;&quot;&quot;Unexpected number of column</span>
    <span class="c1">#headers in input spreadsheet.&quot;&quot;&quot;</span>
    <span class="c1">#assert set(new_row_df.columns) == set(column_label_list),\</span>
    <span class="c1">#&quot;&quot;&quot;Input spreadsheet has different column header names than</span>
    <span class="c1">#expected.&quot;&quot;&quot;</span>

    <span class="c1"># Define a list of new column headers to be appended.</span>
    <span class="n">new_column_label_list</span> <span class="o">=</span> <span class="n">module_amoebae_column_header_lists</span><span class="o">.</span><span class="n">rev_column_label_list</span>

    <span class="c1"># Initiate new dataframe with columns to be appended/joined to spreadsheet.</span>
    <span class="c1">#num_rows = len(list(df.index))</span>
    <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span> 

    <span class="c1"># Get a copy of all the original column headers, which may include some for</span>
    <span class="c1"># previous reverse search information.</span>
    <span class="c1">#original_csv_col_headers = df.columns.copy()</span>

    <span class="c1"># Join constructed dataframe to input dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>

    <span class="n">num_rev_srchs</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Query title&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="c1"># Iterate over rows in input spreadsheet with forward search results, and</span>
    <span class="c1"># determine which reverse search data needs to be found, and update the row</span>
    <span class="c1"># by adding this information.</span>
    <span class="n">row_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">row_num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Check that a reverse search needed to be done for this row.</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit based on E-value criterion&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Prevent analyzing reverse searches when the forward hit rank is over</span>
        <span class="c1"># a certain number.</span>
        <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit rank&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">settings</span><span class="o">.</span><span class="n">max_num_reverse_searches_per_database</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">Parsing reverse search &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">row_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of &#39;</span> <span class="o">+</span>\
                    <span class="nb">str</span><span class="p">(</span><span class="n">num_rev_srchs</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span>\
                    <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">row_num</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">num_rev_srchs</span><span class="p">))</span> <span class="o">+</span>\
                    <span class="s1">&#39;</span><span class="si">% c</span><span class="s1">omplete for this reverse search db)&#39;</span><span class="p">)</span>
        
            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Reverse search database name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">db_file</span>

            <span class="c1"># Get query info.</span>
            <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Query title&#39;</span><span class="p">]</span>
            <span class="n">query_file</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Query file&#39;</span><span class="p">]</span>

            <span class="c1"># Get species for db_file.</span>
            <span class="n">db_file_sp</span> <span class="o">=</span> <span class="n">module_amoebae</span><span class="o">.</span><span class="n">get_species_for_db_filename</span><span class="p">(</span><span class="n">db_file</span><span class="p">)</span>
            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Reverse search species (if applicable)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">db_file_sp</span>


            <span class="c1">## ***Assume that if no redun_hit_csv is provided, then hmmscan was</span>
            <span class="c1">## used.</span>
            <span class="c1">#hmmscan_used = False</span>
            <span class="c1">#if redun_hit_csv is None:</span>
            <span class="c1">#    hmmscan_used = True</span>

            <span class="c1">## Check that a redundant hit csv file was provided.</span>
            <span class="c1">#assert redun_hit_csv is not None, &quot;&quot;&quot;Must provide a path to a</span>
            <span class="c1">#csv file that lists redundant hits in this case.&quot;&quot;&quot;</span>

            <span class="c1"># Get redundant hit list.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">query_title</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">query_file</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">db_file</span><span class="p">)</span>

            <span class="n">redun_hit_list</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">redun_hit_csv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#redun_hit_list =\</span>
                <span class="c1">#redun_hit_dict[query_title][query_file][db_file]</span>
                <span class="n">redun_hit_list</span> <span class="o">=</span>\
                <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">redun_hit_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">][</span><span class="n">db_file</span><span class="p">]))</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Redundant hit list applied&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">redun_hit_list</span>

            <span class="c1"># Get corresponding query file path.</span>
            <span class="n">query_subdir</span> <span class="o">=</span> <span class="n">get_query_subdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>
            <span class="n">corresp_query_path</span> <span class="o">=</span>\
            <span class="n">get_rev_query_path_from_fwd_srch_row</span><span class="p">(</span><span class="n">query_subdir</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">aasubseq</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">corresp_query_path</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Could not figure out</span>
<span class="s2">            where the corresponding reverse search query is for a row. Expected</span>
<span class="s2">            file does not exist: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">corresp_query_path</span>

            <span class="c1"># Get corresponding reverse search result file path.</span>
            <span class="n">search_result_path</span> <span class="o">=</span> <span class="n">search_result_filepath</span><span class="p">(</span><span class="n">corresp_query_path</span><span class="p">,</span>
                    <span class="n">db_file</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">))</span>

            <span class="c1"># Determine file format of search result file.</span>
            <span class="c1"># For certain formats the search method is required, so may</span>
            <span class="c1"># need to figure out how to get that info later (see</span>
            <span class="c1"># http://biopython.org/DIST/docs/api/Bio.SearchIO-module.html)</span>
            <span class="n">parsed_file_obj</span> <span class="o">=</span> <span class="n">SrchResFile</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">)</span>
            <span class="n">srch_file_prog</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">program</span>
            <span class="n">srch_file_prog_vers</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">version</span>
            <span class="n">srch_file_format</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">format</span>


            <span class="c1">## Loop over hits (objects) in reverse search result file, extract</span>
            <span class="c1">## the necessary information, add it to the dataframe.</span>

            <span class="c1"># ***This needs to be customized for different search programs...</span>

            <span class="c1">#hit_num = 0</span>
            <span class="c1">#top_hit_evalue = None</span>
            <span class="c1">#top_hit_score = None</span>
            <span class="c1">#top_hit_len = None</span>

            <span class="c1"># Get top hit and first negative/nonredun hit (if present) by parsing</span>
            <span class="c1"># search result file.</span>
            <span class="c1">#top_hit_obj = None</span>
            <span class="n">top_hit_acc</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">first_neg_hit_rank</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">query_res_obj</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">search_result_path</span><span class="p">,</span>\
                    <span class="n">srch_file_format</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_res_obj</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">top_hit_acc</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">first_neg_hit_rank</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">redun_hit_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
                    <span class="n">first_neg_hit_rank</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">rank_of_first_nonredun_hit</span><span class="p">(</span><span class="n">redun_hit_list</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_res_obj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">first_neg_hit_rank</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># (the first rank is 0)</span>

                    <span class="c1"># Assume that the top reverse search hit matches the</span>
                    <span class="c1"># original query.</span>
                    <span class="n">redun_hit_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">top_hit_acc</span><span class="p">]</span>

            <span class="c1">#if len(query_res_obj) &gt;= 1:</span>
            <span class="c1">#    hit_num = 0</span>
            <span class="c1">#    for hit in query_res_obj: </span>
            <span class="c1">#        hit_num += 1</span>
            <span class="c1">#        if hit_num == 1:</span>
            <span class="c1">#            top_hit_obj = hit</span>
            <span class="c1">#        if hit.id not in redun_hit_list:</span>
            <span class="c1">#            first_neg_hit_obj = hit</span>
            <span class="c1">#            break</span>

            <span class="c1"># Extract info from hits, if any, and interpret. </span>

            <span class="k">if</span> <span class="n">top_hit_acc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Then there is at least one reverse search hit. </span>
                <span class="c1"># Fill in info for top hit.</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Top reverse hit description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_description</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Top reverse search hit E-value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_evalue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Top reverse search hit score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">top_hit_acc</span> <span class="ow">in</span> <span class="n">redun_hit_list</span><span class="p">:</span>
                    <span class="c1"># Then potential positive.</span>

                    <span class="k">if</span> <span class="n">first_neg_hit_rank</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Then there is at least one non-redundant hit.</span>
                        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;First non-redundant hit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_description</span><span class="p">(</span><span class="n">first_neg_hit_rank</span><span class="p">)</span>
                        <span class="n">evaldiff</span> <span class="o">=</span>\
                            <span class="n">get_evaldiff</span><span class="p">(</span><span class="n">get_corr_evalue</span><span class="p">(</span><span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_evalue</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>\
                                    <span class="n">get_corr_evalue</span><span class="p">(</span><span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_evalue</span><span class="p">(</span><span class="n">first_neg_hit_rank</span><span class="p">)))</span>
                        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Order of magnitude E-value difference between top hit and first non-redundant hit&#39;</span><span class="p">]</span> <span class="o">=</span>\
                                <span class="n">evaldiff</span>
                        <span class="n">scorediff</span> <span class="o">=</span>\
                            <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_score</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">parsed_file_obj</span><span class="o">.</span><span class="n">hit_score</span><span class="p">(</span><span class="n">first_neg_hit_rank</span><span class="p">)</span>
                        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Difference in score between top hit and first non-redundant hit&#39;</span><span class="p">]</span> <span class="o">=</span>\
                                <span class="n">scorediff</span>
                        <span class="c1"># Determine whether the criteria are met.</span>
                        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">evaldiff</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">min_evaldiff</span><span class="p">):</span>
                            <span class="c1"># Result is positive.</span>
                            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Note&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;The order of magnitude difference is greater than or equal to </span><span class="si">%s</span><span class="s1">&#39;</span>\
                                    <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">min_evaldiff</span><span class="p">)</span>
                            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive (+) or negative (-) hit based on reverse search criteria&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Then there are no non-redundant hits. </span>
                        <span class="c1"># Result is positive.</span>
                        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Note&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;All reverse search hits are redundant with the original query&#39;</span>
                        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive (+) or negative (-) hit based on reverse search criteria&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Then definitely not positive.</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Note&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Top reverse search hit is not the original query&#39;</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive (+) or negative (-) hit based on reverse search criteria&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Then there are no reverse search hits.</span>
                <span class="c1"># Result is negative.</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Note&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No hits in reverse search&#39;</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive (+) or negative (-) hit based on reverse search criteria&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>



            <span class="c1"># ...</span>
            <span class="c1"># Update row in dataframe with new information.</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>


    <span class="c1"># ...</span>
    <span class="c1"># For end of function:</span>

    <span class="c1"># Give the newly added columns unique names so that they do not get</span>
    <span class="c1"># confused with other similar sets of columns for other reverse search</span>
    <span class="c1"># results.</span>
    <span class="c1">#df.columns = fwd_column_label_list + [x + &#39; (&#39; + rev_srch_id + &#39;)&#39; for x in new_column_label_list]</span>
    <span class="c1">#print(&#39;df.columns slice:&#39;)</span>
    <span class="c1">#print(str(list(df.columns[0:-len(new_column_label_list)])))</span>
    <span class="c1">#print(&#39;altered column headers:&#39;)</span>
    <span class="c1">#print(str([x + &#39; (&#39; + rev_srch_id + &#39;)&#39; for x in new_column_label_list]))</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)])</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="s1">&#39; (&#39;</span> <span class="o">+</span> <span class="n">rev_srch_id</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_column_label_list</span><span class="p">]</span>

    <span class="c1"># Write joined to output path.</span>
    <span class="n">final_outfp</span> <span class="o">=</span> <span class="n">get_csv_with_rev_path</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">final_outfp</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Return main output path.</span>
    <span class="k">return</span> <span class="n">final_outfp</span> </div>


<div class="viewcode-block" id="write_interp_csv"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.write_interp_csv">[docs]</a><span class="k">def</span> <span class="nf">write_interp_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">outfp</span><span class="p">,</span> <span class="n">fwd_evalue_cutoff</span><span class="p">,</span> <span class="n">rev_evalue_cutoff</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a csv file and write a new one with an additional column with</span>
<span class="sd">    interpretation of which forward search results are positive based on all</span>
<span class="sd">    the reverse search results performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the csv file into a pandas dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>

    <span class="c1"># Compile a list of headers for columns that contain relevant +/-</span>
    <span class="c1"># information, and E-values.</span>
    <span class="n">relev_col_headers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fwd_evalue_header</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="n">rev_evalue_headers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="c1"># Record if the column has +/- info.</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Positive (+) or negative (-) hit based on reverse search criteria&#39;</span><span class="p">):</span>
            <span class="n">relev_col_headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># Record if the column contains forward search E-values.</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;Forward hit E-value (top HSP)&#39;</span><span class="p">:</span>
            <span class="n">fwd_evalue_header</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1"># Record if the column contains reverse search E-values.</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Top reverse search hit E-value&#39;</span><span class="p">):</span>
            <span class="n">rev_evalue_headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">relev_col_headers</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify columns</span>
<span class="s2">    containing relevant information in input spreadsheet: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">csv_file</span>
    <span class="k">assert</span> <span class="n">fwd_evalue_header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify column</span>
<span class="s2">    containing forward search E-values in input spreadsheet: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">csv_file</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rev_evalue_headers</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify columns</span>
<span class="s2">    containing reverse search E-values in input spreadsheet: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">csv_file</span>

    <span class="c1"># Define a list of new column headers to be appended.</span>
    <span class="n">new_column_label_list</span> <span class="o">=</span> <span class="n">module_amoebae_column_header_lists</span><span class="o">.</span><span class="n">interp_column_label_list</span>

    <span class="c1"># Initiate new dataframe with columns to be appended/joined to spreadsheet.</span>
    <span class="c1">#num_rows = len(list(df.index))</span>
    <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span> 

    <span class="c1"># Join constructed dataframe to input dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>

    <span class="c1"># Iterate over rows in input spreadsheet with forward search results, and</span>
    <span class="c1"># determine which reverse search data needs to be found, and update the row</span>
    <span class="c1"># by adding this information.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
        <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">relev_col_headers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">header</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">fwd_evalue_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">decis</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">fwd_evalue_header</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">fwd_evalue_cutoff</span><span class="p">):</span>
                    <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">if</span> <span class="n">rev_evalue_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">decis</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">rev_evalue_headers</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">header</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">rev_evalue_cutoff</span><span class="p">):</span>
                        <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                        <span class="k">break</span>

        <span class="c1"># Check that a decision could be made.</span>
        <span class="k">assert</span> <span class="n">decis</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">or</span> <span class="n">decis</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not determine whether the</span>
<span class="s2">        results are positive or negative for row number </span><span class="si">%s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Record decision in dataframe.</span>
        <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;Collective interpretation of reverse search results&#39;</span><span class="p">]</span> <span class="o">=</span>\
        <span class="n">decis</span>

    <span class="c1"># Write new dataframe to output csv file.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outfp</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="write_fwd_srch_interp_csv"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.write_fwd_srch_interp_csv">[docs]</a><span class="k">def</span> <span class="nf">write_fwd_srch_interp_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">outfp</span><span class="p">,</span> <span class="n">score_cutoff</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a csv file and write a new one with an additional column with</span>
<span class="sd">    interpretation of which forward search results are positive based on all</span>
<span class="sd">    the reverse search results performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the csv file into a pandas dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>

    <span class="c1">## Compile a list of headers for columns that contain relevant +/-</span>
    <span class="c1">## information.</span>
    <span class="c1">#relev_col_headers = []</span>
    <span class="c1">#for i in df.columns:</span>
    <span class="c1">#    if i.startswith(&#39;Positive (+) or negative (-) hit based on reverse search criteria&#39;):</span>
    <span class="c1">#        relev_col_headers.append(i)</span>
    <span class="c1">#assert len(relev_col_headers) &gt;= 1, &quot;&quot;&quot;Could not identify columns</span>
    <span class="c1">#containing relevant information in input spreadsheet: %s&quot;&quot;&quot; % csv_file</span>

    <span class="c1"># Define a list of new column headers to be appended.</span>
    <span class="n">new_column_label_list</span> <span class="o">=</span> <span class="n">module_amoebae_column_header_lists</span><span class="o">.</span><span class="n">interp_column_label_list</span>

    <span class="c1"># Initiate new dataframe with columns to be appended/joined to spreadsheet.</span>
    <span class="c1">#num_rows = len(list(df.index))</span>
    <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span> 

    <span class="c1"># Join constructed dataframe to input dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>

    <span class="c1"># Iterate over rows in input spreadsheet with forward search results, and</span>
    <span class="c1"># determine which reverse search data needs to be found, and update the row</span>
    <span class="c1"># by adding this information.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">decis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit score&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit score&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">score_cutoff</span><span class="p">):</span>
            <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">decis</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

        <span class="c1"># Check that a decision could be made.</span>
        <span class="k">assert</span> <span class="n">decis</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">or</span> <span class="n">decis</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not determine whether the</span>
<span class="s2">        results are positive or negative for row number </span><span class="si">%s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Record decision in dataframe.</span>
        <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;Collective interpretation of reverse search results&#39;</span><span class="p">]</span> <span class="o">=</span>\
        <span class="n">decis</span>

    <span class="c1"># Write new dataframe to output csv file.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outfp</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>




<div class="viewcode-block" id="write_redun_hit_interp_csv"><a class="viewcode-back" href="../module_amoebae_search.html#module_amoebae_search.write_redun_hit_interp_csv">[docs]</a><span class="k">def</span> <span class="nf">write_redun_hit_interp_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">outfp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a csv file and write a new one with an additional column with</span>
<span class="sd">    interpretation of which forward search results redundant for the query.</span>

<span class="sd">    ***This currently very inefficient.</span>

<span class="sd">    ***Currently assumes that different query titles refer to</span>
<span class="sd">    non-overlapping/non-nested sets of related proteins.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the csv file into a pandas dataframe.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>

    <span class="c1">## Compile a list of headers for columns that contain relevant +/-</span>
    <span class="c1">## information.</span>
    <span class="c1">#relev_col_headers = []</span>
    <span class="c1">#for i in df.columns:</span>
    <span class="c1">#    if i.startswith(&#39;Positive (+) or negative (-) hit based on reverse search criteria&#39;):</span>
    <span class="c1">#        relev_col_headers.append(i)</span>
    <span class="c1">#assert len(relev_col_headers) &gt;= 1, &quot;&quot;&quot;Could not identify columns</span>
    <span class="c1">#containing relevant information in input spreadsheet: %s&quot;&quot;&quot; % csv_file</span>

    <span class="c1">## Define a list of new column headers to be appended.</span>
    <span class="c1">#new_column_label_list = [&#39;interp&#39;]</span>

    <span class="c1">## Initiate new dataframe with columns to be appended/joined to spreadsheet.</span>
    <span class="c1">##num_rows = len(list(df.index))</span>
    <span class="c1">#df_new_cols = pd.DataFrame(columns=new_column_label_list, index=df.index)</span>

    <span class="c1">## Set default value of all fields to &#39;-&#39;.</span>
    <span class="c1">#for index, row in df_new_cols.iterrows():</span>
    <span class="c1">#    df_new_cols.loc[index] = [] + [&#39;-&#39;] * len(new_column_label_list) </span>

    <span class="c1">## Join constructed dataframe to input dataframe.</span>
    <span class="c1">#df = df.join(df_new_cols)</span>

    <span class="c1"># Iterate over rows and decide whether it is redun or not.</span>
    <span class="n">combos_for_which_neg_found</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>

        <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Query Title&#39;</span><span class="p">]</span>
        <span class="n">query_file</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Query File&#39;</span><span class="p">]</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Accession&#39;</span><span class="p">]</span>
        <span class="n">hit_rank</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Hit Number&#39;</span><span class="p">]</span>
        <span class="n">combo</span> <span class="o">=</span> <span class="p">(</span><span class="n">query_title</span><span class="p">,</span> <span class="n">query_file</span><span class="p">)</span>
        <span class="c1">#print(&#39; &#39;.join([query_title, query_file, str(hit_rank), acc]))</span>

        <span class="k">if</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">combos_for_which_neg_found</span><span class="p">:</span>
            <span class="c1"># A higher-ranking hit in the same search was non-redundant, so</span>
            <span class="c1"># this one is non-redundant as well.</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Look for evidence that the hit is non-redundant.</span>
            <span class="k">for</span> <span class="n">index2</span><span class="p">,</span> <span class="n">row2</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">query_title2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Query Title&#39;</span><span class="p">]</span>
                <span class="n">query_file2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Query File&#39;</span><span class="p">]</span>
                <span class="n">acc2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Accession&#39;</span><span class="p">]</span>
                <span class="n">hit_rank2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Hit Number&#39;</span><span class="p">]</span>
                <span class="c1">#combo2 = (query_title2, query_file2)</span>
                <span class="k">if</span> <span class="n">query_title2</span> <span class="o">!=</span> <span class="n">query_title</span> <span class="ow">and</span> <span class="n">acc2</span> <span class="o">==</span> <span class="n">acc</span> <span class="ow">and</span> <span class="n">hit_rank2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1">#print(&#39;\t&#39; + &#39; &#39;.join([query_title2, query_file2, str(hit_rank2), acc2]))</span>
                    <span class="n">interp</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                    <span class="n">combos_for_which_neg_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
                    <span class="k">break</span>
     
        <span class="c1"># Record whether redundant or not.</span>
        <span class="c1">#df.at[index, &#39;interp&#39;] = interp</span>
        <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;Positive/redundant (+) or negative (-) hit for queries with query title (edit this column)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp</span>

    <span class="c1"># Deal with hits that are now listed as redundant for more than one query</span>
    <span class="c1"># title.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Query Title&#39;</span><span class="p">]</span>
        <span class="n">query_file</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Query File&#39;</span><span class="p">]</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Accession&#39;</span><span class="p">]</span>
        <span class="n">hit_rank</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Hit Number&#39;</span><span class="p">]</span>
        <span class="n">evalue</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;E-value&#39;</span><span class="p">]</span>
        <span class="n">redun</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit for queries with query title (edit this column)&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">redun</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span> 
            <span class="c1"># Loop over all rows, and determine whether the current hit is</span>
            <span class="c1"># retrieved by another query title with a better e-value.</span>
            <span class="k">for</span> <span class="n">index2</span><span class="p">,</span> <span class="n">row2</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">query_title2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Query Title&#39;</span><span class="p">]</span>
                <span class="n">query_file2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Query File&#39;</span><span class="p">]</span>
                <span class="n">acc2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Accession&#39;</span><span class="p">]</span>
                <span class="n">hit_rank2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Hit Number&#39;</span><span class="p">]</span>
                <span class="n">evalue2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;E-value&#39;</span><span class="p">]</span>
                <span class="n">redun2</span> <span class="o">=</span> <span class="n">row2</span><span class="p">[</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit for queries with query title (edit this column)&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">acc2</span> <span class="o">==</span> <span class="n">acc</span> <span class="ow">and</span> <span class="n">query_title2</span> <span class="o">!=</span> <span class="n">query_title</span> <span class="ow">and</span> <span class="n">redun2</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">evalue2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">evalue</span><span class="p">):</span>
                        <span class="n">redun</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">acc</span> <span class="o">+</span> <span class="s1">&#39; is redundant for query title &#39;</span> <span class="o">+</span>\
                                <span class="n">query_title2</span> <span class="o">+</span> <span class="s1">&#39; not for query title &#39;</span> <span class="o">+</span>\
                                <span class="n">query_title</span> <span class="o">+</span> <span class="s1">&#39; (E-values of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">evalue2</span><span class="p">)</span>\
                                <span class="o">+</span> <span class="s1">&#39; and &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">evalue</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; respectively).&#39;</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>

            <span class="c1"># Change the decision if necessary.</span>
            <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;Positive/redundant (+) or negative (-) hit for queries with query title (edit this column)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">redun</span>


    <span class="c1"># Check that the lists of redundant accessions are mutually exclusive sets.</span>
    <span class="c1"># Generate dict of accession lists for each query_title.</span>
    <span class="n">query_title_acc_list_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">query_title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Query Title&#39;</span><span class="p">]</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Accession&#39;</span><span class="p">]</span>
        <span class="n">redun</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit for queries with query title (edit this column)&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">redun</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query_title</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">query_title_acc_list_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">query_title_acc_list_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">acc</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">query_title_acc_list_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_title_acc_list_dict</span><span class="p">[</span><span class="n">query_title</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">acc</span><span class="p">]</span>
    <span class="c1"># Check that the lists of redundant accessions in the dict are non-overlapping.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">query_title_acc_list_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="n">query_title_acc_list_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">key2</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect</span><span class="p">(</span><span class="n">query_title_acc_list_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">query_title_acc_list_dict</span><span class="p">[</span><span class="n">key2</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Redundant</span>
<span class="s2">                    accession lists overlap.&quot;&quot;&quot;</span>


    <span class="c1"># Write new dataframe to output csv file.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outfp</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>




</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Lael D. Barlow.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>