
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>search_alignment_space &#8212; amoebae 0.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for search_alignment_space</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright 2018 Lael D. Barlow</span>
<span class="c1"># </span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1"># </span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># </span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># </span>

<span class="sd">&quot;&quot;&quot;Contains functions for searching for alignments that support given tree</span>
<span class="sd">topologies (comparing alternative topologies).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">settings</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">statistics</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">shuffle</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">module_amoebae_trim_nex</span> <span class="k">import</span> <span class="n">trim_nex</span>
<span class="kn">from</span> <span class="nn">module_paralogue_counter</span> <span class="k">import</span> <span class="n">get_seq_obj_from_srch_res_csv_info</span>
<span class="kn">import</span> <span class="nn">module_amoebae_column_header_lists</span>
<span class="kn">from</span> <span class="nn">module_amoebae_phylo_clas</span> <span class="k">import</span> <span class="n">ModelInfoFromCSV</span><span class="p">,</span>\
<span class="n">get_clade_name_from_model</span><span class="p">,</span> <span class="n">code_names_in_ali</span><span class="p">,</span> <span class="n">quote_tree</span><span class="p">,</span> <span class="n">code_tree</span><span class="p">,</span>\
<span class="n">uncode_tree</span><span class="p">,</span> <span class="n">uncode_tree_obj</span>
<span class="kn">from</span> <span class="nn">module_paralogue_counter</span> <span class="k">import</span> <span class="n">add_seq_to_alignment3</span>
<span class="kn">from</span> <span class="nn">module_amoebae_select_seqs</span> <span class="k">import</span> <span class="n">get_ml_tree_branch_lengths</span>

<span class="c1"># Import functions for working with sequences, alignments, and trees.</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">AlignIO</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">SeqIO</span>
<span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="k">import</span> <span class="n">IUPAC</span><span class="p">,</span> <span class="n">Gapped</span>
<span class="kn">from</span> <span class="nn">module_afa_to_nex</span> <span class="k">import</span> <span class="n">delete_extra_mesquite_lines</span><span class="p">,</span> <span class="n">afa_to_nex</span><span class="p">,</span> <span class="n">nex_to_afa</span><span class="p">,</span> <span class="n">nex_to_phylip</span>
<span class="kn">from</span> <span class="nn">Bio.Align</span> <span class="k">import</span> <span class="n">MultipleSeqAlignment</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="k">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="k">import</span> <span class="n">SeqRecord</span>
<span class="kn">from</span> <span class="nn">ete3</span> <span class="k">import</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">AttrFace</span><span class="p">,</span> <span class="n">TreeStyle</span><span class="p">,</span> <span class="n">NodeStyle</span><span class="p">,</span> <span class="n">TextFace</span>

<span class="c1"># Define classes.</span>

<div class="viewcode-block" id="TaxonomicInfo"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.TaxonomicInfo">[docs]</a><span class="k">class</span> <span class="nc">TaxonomicInfo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Class for storing taxonomic info.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">superbranch</span><span class="p">,</span> <span class="n">supergroup</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">species</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">superbranch</span> <span class="o">=</span> <span class="n">superbranch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supergroup</span> <span class="o">=</span> <span class="n">supergroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">=</span> <span class="n">group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span></div>

<span class="c1"># Define functions.</span>

<div class="viewcode-block" id="get_taxa_represented_in_clade"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_taxa_represented_in_clade">[docs]</a><span class="k">def</span> <span class="nf">get_taxa_represented_in_clade</span><span class="p">(</span><span class="n">clade</span><span class="p">,</span> <span class="n">ml_tree_info_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a list of taxonomic terms currently represented in the clade.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">taxa_represented</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span>\
    <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">][</span><span class="s1">&#39;seq names by descending length&#39;</span><span class="p">]:</span>
        <span class="c1"># Get species name from sequence name.</span>
        <span class="c1">#species_name = seqname.replace(&#39;__&#39;, &#39; &#39;).replace(&#39;_&#39;, &#39; &#39;).split(&#39; &#39;, 1)[1]</span>
        <span class="n">species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>
        <span class="c1"># Get taxonomic information for species name from info csv file.</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
        <span class="c1"># Add taxon names to taxa represented.</span>
        <span class="n">taxa_represented</span> <span class="o">=</span> <span class="n">taxa_represented</span>\
                <span class="o">+</span> <span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">supergroup</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">taxa_represented</span></div>


<div class="viewcode-block" id="get_species_name_from_seq_id"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_species_name_from_seq_id">[docs]</a><span class="k">def</span> <span class="nf">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a fasta sequence id/header/taxon name for one of the sequences in</span>
<span class="sd">    an alignment or FASTA file, and return the species name that it contains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#species_name = seq_id.replace(&#39;__&#39;, &#39; &#39;).replace(&#39;_&#39;, &#39; &#39;).split(&#39; &#39;, 1)[1]</span>
    <span class="c1">#print(&#39;WARNING: Remember to update parsing of species names for new trees.&#39;)</span>
    <span class="c1"># For parsing new sequence ids:</span>
    <span class="n">species_name</span> <span class="o">=</span> <span class="n">seq_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">species_name</span></div>


<div class="viewcode-block" id="get_names_of_dispensable_seqs_in_clade"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_names_of_dispensable_seqs_in_clade">[docs]</a><span class="k">def</span> <span class="nf">get_names_of_dispensable_seqs_in_clade</span><span class="p">(</span><span class="n">clade</span><span class="p">,</span>
                                           <span class="n">ml_tree_info_dict</span><span class="p">,</span>
                                           <span class="n">essential_taxa</span><span class="p">,</span>
                                           <span class="n">taxa_represented</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a clade name and a dictionary of info for the tree that it came</span>
<span class="sd">    from, and determine which ones are dispensable taxonomically.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate list of names for dispensable sequences.</span>
    <span class="n">names_of_dispensable_seqs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over all the sequence names in the clade.</span>
    <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span>\
    <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">][</span><span class="s1">&#39;seq names by descending length&#39;</span><span class="p">]:</span>
        <span class="c1"># Get species name from sequence name.</span>
        <span class="n">species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

        <span class="c1"># Get taxonomic information for species name from info csv file.</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
        <span class="n">ti_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">supergroup</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>

        <span class="c1"># Determine whether any of the taxonomy terms are in the essential</span>
        <span class="c1"># list.</span>
        <span class="n">seq_is_essential</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">essential_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ti_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">essential_taxa</span><span class="p">:</span>
                <span class="n">essential_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Check whether any of the terms appear in the taxa_represented list</span>
        <span class="c1"># only once (if so then the sequence is essential).</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">essential_terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">taxa_represented</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">seq_is_essential</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Add to list if not essential.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seq_is_essential</span><span class="p">:</span>
            <span class="n">names_of_dispensable_seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

    <span class="c1"># Return list of sequence names for dispensable sequences.</span>
    <span class="k">return</span> <span class="n">names_of_dispensable_seqs</span></div>


<div class="viewcode-block" id="new_seq_in_clade_dispensable"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.new_seq_in_clade_dispensable">[docs]</a><span class="k">def</span> <span class="nf">new_seq_in_clade_dispensable</span><span class="p">(</span><span class="n">essential_taxa</span><span class="p">,</span>
                                 <span class="n">clade</span><span class="p">,</span>
                                 <span class="n">additional_seq_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a list of essential taxonomic terms, a list of taxa represented in</span>
<span class="sd">    a clade with an added sequence (including from the added sequence), and the</span>
<span class="sd">    sequence ID of the sequence that was added. Return true if the additional</span>
<span class="sd">    sequences is taxonomically dispensable to the clade.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate variable for determining whether the added sequence is</span>
    <span class="c1"># dispensable.</span>
    <span class="n">new_seq_dispensable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Iterate over all the sequence names in the clade.</span>
    <span class="n">taxonomic_terms_in_clade</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">clade</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]:</span>
        <span class="c1"># Get species name from sequence name.</span>
        <span class="n">species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

        <span class="c1"># Get taxonomic information for species name from info csv file.</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
        <span class="n">ti_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">supergroup</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>

        <span class="c1"># Add to list of taxa represented.</span>
        <span class="n">taxonomic_terms_in_clade</span> <span class="o">=</span> <span class="n">taxonomic_terms_in_clade</span> <span class="o">+</span> <span class="n">ti_list</span>

    <span class="c1"># Get species name from sequence name.</span>
    <span class="n">added_species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">additional_seq_id</span><span class="p">)</span>

    <span class="c1"># Get taxonomic information for species name from info csv file.</span>
    <span class="n">added_species_ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">added_species_name</span><span class="p">)</span>
    <span class="n">added_species_ti_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">supergroup</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>

    <span class="c1"># Determine whether any of the taxonomy terms for the added species are</span>
    <span class="c1"># in the essential list.</span>
    <span class="n">essential_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">added_species_ti_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">essential_taxa</span><span class="p">:</span>
            <span class="n">essential_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Check whether any of the terms appear in the taxa_represented list</span>
    <span class="c1"># only once (if so then the sequence is essential).</span>
    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">essential_terms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">taxonomic_terms_in_clade</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_seq_dispensable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>

    <span class="c1"># Return result.</span>
    <span class="k">return</span> <span class="n">new_seq_dispensable</span> </div>


<div class="viewcode-block" id="get_new_type_seqs_dict"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_new_type_seqs_dict">[docs]</a><span class="k">def</span> <span class="nf">get_new_type_seqs_dict</span><span class="p">(</span><span class="n">seqname</span><span class="p">,</span> <span class="n">ml_tree_info_dict</span><span class="p">,</span> <span class="n">type_seqs_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a type sequence name dictionary and a sequence name, and return a</span>
<span class="sd">    new dictionary with the sequence replaced with another sequence if</span>
<span class="sd">    necessary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy the input dict.</span>
    <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="n">type_seqs_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Determine whether the seqname is one of the type seqnames in the dict.</span>
    <span class="n">is_type_seq</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">type_seqs_dict2</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">seqname</span> <span class="o">==</span> <span class="n">type_seqs_dict2</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
            <span class="n">is_type_seq</span> <span class="o">=</span> <span class="kc">True</span>
    
            <span class="c1"># If it is a type seq, then replace it with another sequence name.</span>
            <span class="c1"># Identify an alternative type sequence for the same</span>
            <span class="c1"># (current) clade.</span>
            <span class="k">for</span> <span class="n">seqname2</span> <span class="ow">in</span>\
            <span class="nb">reversed</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span>\
            <span class="p">[</span><span class="s1">&#39;seq names by descending length&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">seqname2</span> <span class="o">!=</span> <span class="n">seqname</span><span class="p">:</span>
                    <span class="c1"># Change type seq for clade to a different sequence.</span>
                    <span class="n">type_seqs_dict2</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span> <span class="o">=</span> <span class="n">seqname2</span>
    
    <span class="c1"># Return the new dict.</span>
    <span class="k">return</span> <span class="n">type_seqs_dict2</span></div>


<div class="viewcode-block" id="reduce_alignment"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.reduce_alignment">[docs]</a><span class="k">def</span> <span class="nf">reduce_alignment</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">,</span> <span class="n">output_alignment_file</span><span class="p">,</span> <span class="n">removal_name_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take file path for an existing alignment and an output alignment, and</span>
<span class="sd">    a list of sequence names for removal. Write the reduced alignment to the</span>
<span class="sd">    output path in nexus format. Note: This function assumes that the names in</span>
<span class="sd">    the removal lit and the alignment are all either coded or uncoded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that at least one sequence name listed for removal.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">removal_name_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Remove extra mesquite lines if present.</span>
    <span class="n">delete_extra_mesquite_lines</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">)</span>

    <span class="c1"># Get list of names of sequences in alignment.</span>
    <span class="n">names_in_alignment</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)]</span>

    <span class="c1"># Check number of sequences in input alignment.</span>
    <span class="n">num_seqs1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_in_alignment</span><span class="p">)</span>

    <span class="c1"># Check that all the sequences listed for removal are actually in the input</span>
    <span class="c1"># alignment.</span>
    <span class="c1">#names_in_alignment = [x.replace(&#39;-&#39;, &#39;_&#39;) for x in names_in_alignment]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">removal_name_list</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names_in_alignment</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Sequence </span><span class="si">%s</span><span class="s2"> cannot be identified</span>
<span class="s2">        in the alignment </span><span class="si">%s</span><span class="s2"> and therefore cannot be removed.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">))</span>
        <span class="c1"># If this happens, then maybe there are characters that are in the</span>
        <span class="c1"># alignment that were changed or removed when parsing the resulting</span>
        <span class="c1"># tree (&#39;.&#39; or &#39;-&#39; ?). This shouldn&#39;t be a problem with the new trees.</span>
    <span class="c1">#assert\</span>
    <span class="c1">#len(list(set(removal_name_list).intersection(set(names_in_alignment))))\</span>
    <span class="c1">#== len(removal_name_list)</span>

    <span class="c1"># Make a copy of the input alignment file with the listed sequences</span>
    <span class="c1"># removed.</span>
    <span class="n">coded_seqs_to_not_remove_from_dataset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_alignment_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
        <span class="c1">#print(&#39;number of seqs in original alignment&#39;)</span>
        <span class="c1">#print(len(alignment))</span>
        <span class="n">alignment2</span> <span class="o">=</span> <span class="n">MultipleSeqAlignment</span><span class="p">([])</span>
        <span class="c1">#print(&#39;number of seqs in alignment2:&#39;)</span>
        <span class="c1">#print(len(alignment2))</span>
        <span class="c1">#print(&#39;Removing sequences from alignment.&#39;)</span>
        <span class="c1">#ali_len = len(alignment)</span>
        <span class="n">removed_a_seq</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">inum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alignment</span><span class="p">:</span>
            <span class="n">inum</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removal_name_list</span><span class="p">:</span>
                <span class="n">alignment2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alignment</span><span class="p">[</span><span class="n">inum</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">removed_a_seq</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">assert</span> <span class="n">removed_a_seq</span>

        <span class="n">alignment3</span> <span class="o">=</span>\
        <span class="n">MultipleSeqAlignment</span><span class="p">(</span><span class="n">alignment2</span><span class="p">[:,:])</span>
        <span class="c1">#print(&#39;number of seqs in alignment3:&#39;)</span>
        <span class="c1">#print(len(alignment3))</span>

        <span class="c1"># Get list of sequences in new alignment.</span>
        <span class="n">ids_in_alignment3</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alignment3</span><span class="p">:</span>
            <span class="n">ids_in_alignment3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="c1"># Write reduced alignment.</span>
        <span class="c1">#print(&#39;Writing modified alignment file:\n\t%s&#39; % o.name)</span>
        <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">alignment3</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>

    <span class="c1"># Check that number of sequences in new alignment is one less than in the</span>
    <span class="c1"># input alignment.</span>
    <span class="n">num_seqs2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">output_alignment_file</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">num_seqs2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">num_seqs1</span></div>


<div class="viewcode-block" id="modify_alignment_in_x_way"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.modify_alignment_in_x_way">[docs]</a><span class="k">def</span> <span class="nf">modify_alignment_in_x_way</span><span class="p">(</span><span class="n">previous_ali_tree_tuple</span><span class="p">,</span> <span class="n">mod_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modify an alignment (and associated tree) and return a tuple with all</span>
<span class="sd">    the same type of elements as the input tuple, except for the new</span>
<span class="sd">    alignment (and associated tree).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Unpack objects from input tuple.</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">positions_attempted_to_remove</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">subs_model</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">type_seqs_dict</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">ml_tree_info_dict</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">seqs</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">seqs_attempted_to_remove</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">seqs_attempted_to_add</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
    <span class="n">essential_taxa</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>

    <span class="c1"># Check that the stop variable was not set to True in the last iteration.</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">stop</span>

    <span class="c1"># Define the current iteration number (for naming output files).</span>
    <span class="n">iteration2</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Define path to new alignment file.</span>
    <span class="n">alignment2</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iteration2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span>

    <span class="c1"># Determine number of sequences in input alignment.</span>
    <span class="n">seqnames_in_alignment</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)]</span>
    <span class="n">num_seqs_in_alignment</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqnames_in_alignment</span><span class="p">)</span>

    <span class="c1"># Define path to new tree file.</span>
    <span class="n">tree2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignment2</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_newick.tre&#39;</span><span class="p">)</span>

    <span class="c1"># Determine number of sequences represented in the input tree.</span>
    <span class="n">seqnames_in_tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
    <span class="n">num_seqs_in_tree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqnames_in_tree</span><span class="p">)</span>

    <span class="c1"># Check that number of sequences in alignment and tree are the same.</span>
    <span class="k">assert</span> <span class="n">num_seqs_in_alignment</span> <span class="o">==</span> <span class="n">num_seqs_in_tree</span>

    <span class="c1">## Check that the sequence names in the alignment and the tree are the same.</span>
    <span class="c1">#print(&#39;Name in alignment\tName in tree&#39;)</span>
    <span class="c1">#for i, j in zip(sorted(seqnames_in_alignment), sorted(seqnames_in_tree)):</span>
    <span class="c1">#    print(i + &#39;\t&#39; + j)</span>
    <span class="c1">#    assert i == j, &quot;&quot;&quot;These sequence names should be the same.&quot;&quot;&quot;</span>

    <span class="c1"># Define output path for annotated tree image file.</span>
    <span class="n">annotated_tree_outpath2</span> <span class="o">=</span>\
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignment2</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_annotated_result.png&#39;</span><span class="p">)</span>

    <span class="c1"># Define output directory path.</span>
    <span class="n">outputdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">alignment2</span><span class="p">)</span>

    <span class="c1"># Initiate variable for new type sequence dictionary.</span>
    <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#############################################</span>
    <span class="c1">#############################################</span>
    <span class="c1"># This code is can be modified depending on what type of modification is</span>
    <span class="c1"># needed:</span>

    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;remove_seqs&#39;</span><span class="p">:</span>
        <span class="c1"># Check that essential taxa were specified.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">essential_taxa</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No essential taxa are specified.&quot;&quot;&quot;</span>

        <span class="c1"># Determine what sequence to remove.</span>

        <span class="c1"># Set variables that won&#39;t be modified.</span>
        <span class="n">subs_model2</span> <span class="o">=</span> <span class="n">subs_model</span>
        <span class="n">positions_attempted_to_remove2</span> <span class="o">=</span> <span class="n">positions_attempted_to_remove</span>
        <span class="n">seqs_attempted_to_add2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_add</span>

        <span class="c1"># Initiate variables that will be modified later.</span>
        <span class="n">seqs_attempted_to_remove2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_remove</span>

        <span class="c1"># Determine the clade with the worst support.</span>
        <span class="c1">#clades_by_ascending_ratio = sorted(branch_length_info_dict.keys(),\</span>
        <span class="c1">#        key=lambda x: branch_length_info_dict[x][&#39;stem/branch ratio&#39;])</span>
        <span class="n">clade_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">clade_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">)</span>
        <span class="n">clades_by_ascending_support_measure</span> <span class="o">=</span>\
        <span class="nb">sorted</span><span class="p">(</span><span class="n">clade_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;alrt support&#39;</span><span class="p">])</span>

        <span class="n">removed_a_sequence</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clades_by_ascending_support_measure</span><span class="p">:</span>
            <span class="c1"># Make a list of taxonomic terms currently represented in the clade.</span>
            <span class="n">taxa_represented</span> <span class="o">=</span> <span class="n">get_taxa_represented_in_clade</span><span class="p">(</span><span class="n">clade</span><span class="p">,</span> <span class="n">ml_tree_info_dict</span><span class="p">)</span>

            <span class="c1"># Determine which seqs in the clade are dispensable, considering their</span>
            <span class="c1"># taxonomic placement.</span>
            <span class="n">names_of_dispensable_seqs_in_clade</span> <span class="o">=</span>\
            <span class="n">get_names_of_dispensable_seqs_in_clade</span><span class="p">(</span><span class="n">clade</span><span class="p">,</span>
                                                   <span class="n">ml_tree_info_dict</span><span class="p">,</span>
                                                   <span class="n">essential_taxa</span><span class="p">,</span>
                                                   <span class="n">taxa_represented</span><span class="p">)</span> 
            <span class="c1">## Get list of sequence names in clade by descending order of branch</span>
            <span class="c1">## length (from the root of the clade).</span>
            <span class="c1">#seqnames = ml_tree_info_dict[clade][&#39;seq names by descending length&#39;]</span>

            <span class="c1"># Remove sequence names from the list that have already been removed</span>
            <span class="c1"># (and did not improve the tree).</span>
            <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="n">seqs_attempted_to_remove</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="n">names_of_dispensable_seqs_in_clade</span><span class="p">:</span>
                    <span class="n">names_of_dispensable_seqs_in_clade</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

            <span class="c1"># Iterate over sequence names in descending order of branch length.</span>
            <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="n">names_of_dispensable_seqs_in_clade</span><span class="p">:</span>
                <span class="c1"># Try removing the corresponding sequence from the</span>
                <span class="c1"># tree, and see whether it improves the branch length</span>
                <span class="c1"># ratios.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">removing sequence </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">seqname</span><span class="p">)</span>

                <span class="c1"># If the sequence is a type sequence, then you have to</span>
                <span class="c1"># choose another sequence in the clade as a replacement</span>
                <span class="c1"># type sequence.</span>
                <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="n">get_new_type_seqs_dict</span><span class="p">(</span><span class="n">seqname</span><span class="p">,</span>
                                                         <span class="n">ml_tree_info_dict</span><span class="p">,</span>
                                                         <span class="n">type_seqs_dict</span><span class="p">)</span>

                <span class="c1"># Remove seq from alignment.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Writing reduced alignment to &#39;</span> <span class="o">+</span>\
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment2</span><span class="p">))</span>
                <span class="n">reduce_alignment</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">,</span> <span class="p">[</span><span class="n">seqname</span><span class="p">])</span>


                <span class="c1"># Code alignment (get table file).???</span>

                <span class="c1"># Remove seq from parsed tree object, and</span>
                <span class="c1"># use that as a constraint tree.</span>
                <span class="c1"># Copy tree.</span>
                <span class="c1">#t2 = t1.copy()</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Get a list of all node objects with the same name as the</span>
                <span class="c1"># sequence of interest.</span>
                <span class="n">seq_nodes</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">seqname</span><span class="p">)</span>

                <span class="c1"># Check that only one such node was found.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

                <span class="c1"># Remove the node from the new tree object.</span>
                <span class="n">node_to_remove</span> <span class="o">=</span> <span class="n">seq_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">t2_len_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span>
                <span class="n">node_to_remove</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

                <span class="c1"># Check that a node was actually removed.</span>
                <span class="n">t2_len_after</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span>
                <span class="k">assert</span> <span class="n">t2_len_before</span> <span class="o">==</span> <span class="n">t2_len_after</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Write modified tree to a file.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Writing annotated tree to &#39;</span> <span class="o">+</span>\
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree2</span><span class="p">))</span>
                <span class="n">t2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">tree2</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>

                <span class="c1"># Add sequence name to list of sequences that have been removed. </span>
                <span class="n">seqs_attempted_to_remove2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

                <span class="c1"># Break the loop so that only one sequence gets removed per</span>
                <span class="c1"># iteration.</span>
                <span class="n">removed_a_sequence</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="c1"># Break this loop too, if a sequence was removed.</span>
            <span class="k">if</span> <span class="n">removed_a_sequence</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Check that a sequence was removed, if not then stop iterating.</span>
        <span class="k">if</span> <span class="n">removed_a_sequence</span><span class="p">:</span>
            <span class="c1"># Check that the output alignment has one less sequence than the</span>
            <span class="c1"># input alignment.</span>
            <span class="n">num_seqs_in_new_alignment</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment2</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">num_seqs_in_new_alignment</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">num_seqs_in_alignment</span>
            <span class="c1"># Check that the output tree has one less sequence than the input</span>
            <span class="c1"># tree.</span>
            <span class="n">num_seqs_in_new_tree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree2</span><span class="p">)</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()))</span>
            <span class="k">assert</span> <span class="n">num_seqs_in_new_tree</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">num_seqs_in_tree</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find a sequence to remove.&#39;</span><span class="p">)</span>
            <span class="c1"># Stop iterative calling of modify_seq_in_x_way function (at least</span>
            <span class="c1"># with the current modification type).</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>


    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;add_seqs&#39;</span><span class="p">:</span>
        <span class="c1"># Check that a file with sequences to try adding was specified.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No sequences provided as input.&quot;&quot;&quot;</span>

        <span class="c1"># Determine what sequence to add.</span>

        <span class="c1"># Set variables that won&#39;t be modified.</span>
        <span class="n">subs_model2</span> <span class="o">=</span> <span class="n">subs_model</span>
        <span class="n">positions_attempted_to_remove2</span> <span class="o">=</span> <span class="n">positions_attempted_to_remove</span>
        <span class="n">seqs_attempted_to_remove2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_remove</span>
        <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="n">type_seqs_dict</span>

        <span class="c1"># Initiate variables that will be modified later.</span>
        <span class="n">seqs_attempted_to_add2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_add</span>

        <span class="c1"># Initiate variable to indicate whether a sequence was found to add or</span>
        <span class="c1"># not.</span>
        <span class="n">added_a_sequence</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Initiate variable to indicate whether the new tree and alignment are</span>
        <span class="c1"># usable (if the added sequence was placed into a clade of interest or</span>
        <span class="c1"># not).</span>
        <span class="n">ali_and_tree_usable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Initiate a variable to indicate whether the added sequence adds an</span>
        <span class="c1"># essential taxon that was missing in the clade before (if it does,</span>
        <span class="c1"># then even if the resulting tree yields lower support then it still</span>
        <span class="c1"># might be considered better).</span>
        <span class="n">added_seq_adds_essential_taxon</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Determine which sequences, if any, could be added to the tree.</span>
        <span class="n">seqnames_in_tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
        <span class="n">all_seqnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seqs</span><span class="p">]</span> 
        <span class="n">seqnames_to_be_added</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="n">all_seqnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seqname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seqs_attempted_to_add2</span> <span class="o">+</span> <span class="n">seqnames_in_tree</span><span class="p">:</span>
                <span class="n">seqnames_to_be_added</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

        <span class="c1"># Make a list of taxonomic terms currently represented in the clade.</span>
        <span class="c1">#taxa_represented = get_taxa_represented_in_clade(clade, ml_tree_info_dict)</span>
        <span class="c1"># *** ToDo: Add functionality to add sequences with taxonomic terms in</span>
        <span class="c1"># the essential taxa list that are missing in the taxa_represented</span>
        <span class="c1"># list.</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqnames_to_be_added</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find a sequence to add.&#39;</span><span class="p">)</span>
            <span class="c1"># Stop iterative calling of modify_seq_in_x_way function (at least</span>
            <span class="c1"># with the current modification type).</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Select one of the sequences randomly from the list of candidates.</span>
            <span class="n">shuffle</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span>
            <span class="n">seq_to_add</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">seqs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">seqnames_to_be_added</span><span class="p">:</span>
                    <span class="n">seq_to_add</span> <span class="o">=</span> <span class="n">seq</span>
                    <span class="k">break</span>
            <span class="k">assert</span> <span class="n">seq_to_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Adding sequence &#39;</span> <span class="o">+</span> <span class="n">seq_to_add</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

           <span class="c1"># Add to list of sequences added to to the tree.</span>
            <span class="n">seqs_attempted_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq_to_add</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>

            <span class="c1"># Add sequence to alignment.</span>
            <span class="n">add_seq_to_alignment3</span><span class="p">(</span><span class="n">seq_to_add</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">)</span>

            <span class="c1"># Use the previous tree as a constraint tree...</span>
            <span class="c1">#constraint_tree_fp = get_constraint_tree_fp(alignment)</span>
            <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">tree</span>

            <span class="c1">## Temp.</span>
            <span class="c1">#print(&#39;\n\nConstraint trees identified by modify_alignment_in_x_way&#39;) </span>
            <span class="c1">#print(tree)</span>
            <span class="c1">#print(get_constraint_tree_fp(alignment))</span>
            <span class="c1">#print(&#39;\n\n&#39;)</span>


            <span class="c1">#with open(constraint_tree_fp) as infh:</span>
            <span class="c1">#    for i in infh:</span>
            <span class="c1">#        print(i)</span>

            <span class="c1"># Call function to run IQtree (specifying option to input a</span>
            <span class="c1"># constraint tree and run ML search with the -g option instead of</span>
            <span class="c1"># using the -te, --alrt, and --abayes options.</span>
            <span class="n">place_seq</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ml_placement_tree_path</span> <span class="o">=</span>\
            <span class="n">run_tree_for_branch_lengths_and_supports_for_topology</span><span class="p">(</span>
                                                          <span class="n">constraint_tree_fp</span><span class="p">,</span>
                                                          <span class="n">alignment2</span><span class="p">,</span>
                                                          <span class="n">subs_model</span><span class="p">,</span>
                                                          <span class="n">outputdir</span><span class="p">,</span>
                                                          <span class="n">place_seq</span><span class="p">)</span>

            <span class="c1"># Indicate that a new tree was produced.</span>
            <span class="n">added_a_sequence</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Confirm that the sequence went into one of the clades of</span>
            <span class="c1"># interest.</span>

            <span class="c1"># Parse tree using ete3.</span>
            <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">ml_placement_tree_path</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1">## Convert names in tree back to original names.</span>
            <span class="c1">#uncode_tree_obj(t1, outtablefp)</span>

            <span class="c1">## Define name for tree without branch lengths.</span>
            <span class="c1">#simple_tree = tree_file_path.rsplit(&#39;_&#39;, 1)[0] + &#39;_TEMP2&#39; </span>

            <span class="c1">## Write simple tree to a new file </span>
            <span class="c1">#t1.write(format=9, outfile=simple_tree)</span>

            <span class="c1">## Parse simple tree.</span>
            <span class="c1">#t2 = Tree(simple_tree)</span>

            <span class="c1"># Print simple tree.</span>
            <span class="c1">#print(&#39;ML tree:&#39;)</span>
            <span class="c1">#print(t1)</span>


            <span class="c1"># Make a copy of the tree object.</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Get list of &quot;type&quot; sequences from input.</span>
            <span class="n">type_seq_list</span> <span class="o">=</span> <span class="n">type_seqs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="c1"># For each &quot;type&quot; sequence, traverse all nodes and find the node with</span>
            <span class="c1"># the largest number of child nodes that are leaf (terminal) nodes,</span>
            <span class="c1"># containing the &quot;type&quot; sequence of interest, but not containing any of</span>
            <span class="c1"># the other &quot;type&quot; sequences.</span>
            <span class="n">ts_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                <span class="n">ts_num</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="n">ts</span>
                    <span class="c1"># Root on another &quot;type&quot; sequence for the first type sequence in</span>
                    <span class="c1"># the list to get whole clade, then root the tree on the ancestor</span>
                    <span class="c1"># node of that first clade.</span>

                    <span class="c1"># Get a node name for a node corresponding to a different</span>
                    <span class="c1"># &quot;type&quot; sequence.</span>
                    <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ts</span><span class="p">:</span>
                            <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="k">break</span>

                    <span class="c1"># Get node corresponding to a different &quot;type&quot; sequence.</span>
                    <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_type_seq_node_name</span><span class="p">:</span>
                            <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                            <span class="k">break</span>

                    <span class="c1"># Root on the other &quot;type&quot; sequence node.</span>
                    <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">other_type_seq_node</span><span class="p">)</span>

                    <span class="c1">#print(&#39;\n\n\nTree rooted on a type sequence other than the first type sequence.&#39;)</span>
                    <span class="c1">#print(t2)</span>

                <span class="k">elif</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># Root on the first &quot;type&quot; sequence node for all subsequent</span>
                    <span class="c1"># clades.</span>
                    <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                        <span class="n">leaf_list</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_type_seq_node_name</span><span class="p">:</span>
                                <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                                <span class="k">break</span>
                    <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">first_type_seq_node</span><span class="p">)</span>
                    <span class="c1">#print(&#39;\n\n\nTree re-rooted on first type sequence:&#39;)</span>
                    <span class="c1">#print(t2)</span>


                <span class="c1"># Make a copy of the tree topology to work with for each run</span>
                <span class="c1"># through this loop.</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Make a list of nodes that contain type seq, but not any others. #</span>
                <span class="c1"># SEPARATE</span>
                <span class="n">nodes_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="c1"># Search in nodes that contain the type sequence.</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts</span><span class="p">):</span>
                        <span class="c1"># Search in nodes that don&#39;t contain other type sequences.</span>
                        <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">for</span> <span class="n">ts2</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">ts2</span> <span class="o">==</span> <span class="n">ts</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts2</span><span class="p">):</span>
                                    <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_other_type_seqs</span><span class="p">:</span>
                            <span class="c1"># Add nodes of interest to list.</span>
                            <span class="n">nodes_of_interest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># find the node with the most child leaf nodes.</span>
                <span class="c1">#node_num = 0</span>
                <span class="c1">#for node in nodes_of_interest:</span>
                <span class="c1">#    node_num += 1 </span>
                <span class="c1">#    print(&#39;Node &#39; + str(node_num) + &#39; Number of leaves:  &#39; + str(len(node.get_leaves())))</span>
                <span class="c1">#    print(node)</span>
                <span class="n">node_w_most_leaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                        <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
                <span class="c1">#print(&#39;\n\nClade defined by sequence &#39; + ts + &#39;:&#39;)</span>
                <span class="c1">#print(node_w_most_leaves)</span>

                <span class="c1">#name_of_additional_seq = record.description</span>
                <span class="n">name_of_additional_seq</span> <span class="o">=</span> <span class="n">seq_to_add</span><span class="o">.</span><span class="n">id</span> <span class="c1">#record.id # + &#39; &#39; + record.description</span>

                <span class="c1">#print(&#39;\n\n\n&#39;)</span>
                <span class="c1">#print(name_of_additional_seq)</span>
                <span class="c1">#print(&#39;\n\n\n&#39;)</span>
                <span class="c1">#for i in [x.name for x in node_w_most_leaves.get_leaves()]:</span>
                <span class="c1">#    print(i)</span>
                <span class="c1">#print(&#39;\n\n\n&#39;)</span>

                <span class="k">if</span> <span class="n">name_of_additional_seq</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]:</span>
                    <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="n">ts</span>
                    <span class="c1">#print(&#39;%s is in this clade.&#39; % name_of_additional_seq)</span>

                    <span class="c1">## Make a list of taxonomic terms currently represented in the clade.</span>
                    <span class="c1">#taxa_represented = get_taxa_represented_in_clade(node_w_most_leaves,</span>
                    <span class="c1">#                                                 ml_tree_info_dict)</span>

                    <span class="c1">## Get clade name for type seq name from type seqs dict.</span>
                    <span class="c1">#clade_name = None</span>
                    <span class="c1">#for c in type_seqs_dict.keys():</span>
                    <span class="c1">#    if type_seqs_dict[c] ==\</span>
                    <span class="c1">#    ts_that_additional_seq_was_placed_in:</span>
                    <span class="c1">#        clade_name = c</span>
                    <span class="c1">#        break</span>
                    <span class="c1">#assert clade_name is not None</span>

                    <span class="c1"># Determine which seqs in the clade are dispensable, considering their</span>
                    <span class="c1"># taxonomic placement.</span>
                    <span class="c1">#names_of_dispensable_seqs_in_clade =\</span>
                    <span class="c1">#get_names_of_dispensable_seqs_in_clade(clade_name,</span>
                    <span class="c1">#                                       ml_tree_info_dict,</span>
                    <span class="c1">#                                       essential_taxa,</span>
                    <span class="c1">#                                       taxa_represented) </span>
                    <span class="n">additional_seq_dispensable</span> <span class="o">=</span>\
                    <span class="n">new_seq_in_clade_dispensable</span><span class="p">(</span><span class="n">essential_taxa</span><span class="p">,</span>
                                                 <span class="n">node_w_most_leaves</span><span class="p">,</span>
                                                 <span class="n">seq_to_add</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

                    <span class="c1"># Determine whether the additional sequence is dispensable</span>
                    <span class="c1"># or not in the new clade.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">additional_seq_dispensable</span><span class="p">:</span>
                        <span class="n">added_seq_adds_essential_taxon</span> <span class="o">=</span> <span class="kc">True</span>
                    
                    <span class="c1"># Break the loop, because no other clades need to be</span>
                    <span class="c1"># considered after the relevant clade has been identified.</span>
                    <span class="k">break</span>

            <span class="c1"># If the sequence could not be placed in any of the clades of interest,</span>
            <span class="c1"># then set the name of the type sequence to a string &#39;None&#39;.</span>
            <span class="k">if</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>

            <span class="c1"># If the sequence was placed in a clade of interest, then the tree</span>
            <span class="c1"># is usable.</span>
            <span class="k">if</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ali_and_tree_usable</span> <span class="o">=</span> <span class="kc">True</span> 

            <span class="c1"># Temp:</span>
            <span class="c1"># Check that the clade that the additional sequence was placed in was</span>
            <span class="c1"># identified.</span>
            <span class="k">assert</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Sequence was</span>
<span class="s2">            not placed in any of the clades of interest: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">record</span><span class="o">.</span><span class="n">description</span>

            <span class="c1"># Define path to constraint tree for further analysis (to find</span>
            <span class="c1"># abayes and alrt support with the -te option in IQ-tree).</span>

            <span class="c1"># </span>

            <span class="c1"># Write modified tree to a file.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Writing annotated tree to &#39;</span> <span class="o">+</span>\
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree2</span><span class="p">))</span>
            <span class="n">t1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">tree2</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>


        <span class="c1"># *** This check may be redundant.</span>
        <span class="c1"># Check that a sequence was added, if not then stop iterating.</span>
        <span class="k">if</span> <span class="n">added_a_sequence</span> <span class="ow">and</span> <span class="n">ali_and_tree_usable</span><span class="p">:</span>
            <span class="c1"># Check that the output alignment has one more sequence than the</span>
            <span class="c1"># input alignment.</span>
            <span class="n">num_seqs_in_new_alignment</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment2</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">num_seqs_in_new_alignment</span> <span class="o">==</span> <span class="n">num_seqs_in_alignment</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Check that the output tree has one less sequence than the input</span>
            <span class="c1"># tree.</span>
            <span class="n">num_seqs_in_new_tree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree2</span><span class="p">)</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()))</span>
            <span class="k">assert</span> <span class="n">num_seqs_in_new_tree</span> <span class="o">==</span> <span class="n">num_seqs_in_tree</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Do not use the alignment and tree if the above conditions are not</span>
            <span class="c1"># met.</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>


        <span class="c1">#...</span>
        <span class="c1">#assert 2 != 2</span>



    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;remove_columns&#39;</span><span class="p">:</span>
        <span class="c1"># ...code...</span>
        <span class="k">assert</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">2</span>
        <span class="k">pass</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;mod_type variable not set properly.&quot;&quot;&quot;</span>

    <span class="c1">#############################################</span>
    <span class="c1">#############################################</span>

    <span class="c1"># Only run a tree if a new alignent and topology were produced.</span>
    <span class="n">ml_tree_path2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ml_tree_info_dict2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
        <span class="c1"># Run IQ-tree to get ML tree with branch supports for new alignment and/or</span>
        <span class="c1"># tree topology.</span>
        <span class="n">ml_tree_path2</span> <span class="o">=</span>\
        <span class="n">run_tree_for_branch_lengths_and_supports_for_topology</span><span class="p">(</span><span class="n">tree2</span><span class="p">,</span>
                                                              <span class="n">alignment2</span><span class="p">,</span>
                                                              <span class="n">subs_model2</span><span class="p">,</span>
                                                              <span class="n">outputdir</span><span class="p">)</span>


        <span class="c1"># Extract relevant information from ML tree.</span>
        <span class="n">ml_tree_info_dict2</span> <span class="o">=</span> <span class="n">get_ml_tree_info_dict</span><span class="p">(</span><span class="n">ml_tree_path2</span><span class="p">,</span>
                                                  <span class="n">type_seqs_dict2</span><span class="p">,</span>
                                                  <span class="n">annotated_tree_outpath2</span><span class="p">)</span>

    <span class="c1"># Construct a tuple with new info for new alignment and tree.</span>
    <span class="n">new_ali_tree_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">iteration2</span><span class="p">,</span>
                          <span class="n">tree2</span><span class="p">,</span>
                          <span class="n">alignment2</span><span class="p">,</span>
                          <span class="n">positions_attempted_to_remove2</span><span class="p">,</span>
                          <span class="n">subs_model2</span><span class="p">,</span>
                          <span class="n">type_seqs_dict2</span><span class="p">,</span>
                          <span class="n">ml_tree_info_dict2</span><span class="p">,</span>
                          <span class="n">seqs</span><span class="p">,</span>
                          <span class="n">seqs_attempted_to_remove2</span><span class="p">,</span>
                          <span class="n">seqs_attempted_to_add2</span><span class="p">,</span>
                          <span class="n">essential_taxa</span><span class="p">,</span>
                          <span class="n">stop</span><span class="p">)</span>

    <span class="c1"># Return the new tuple.</span>
    <span class="k">return</span> <span class="n">new_ali_tree_tuple</span></div>


<div class="viewcode-block" id="get_taxonomic_info"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_taxonomic_info">[docs]</a><span class="k">def</span> <span class="nf">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a species name that appears in the genome info csv file in the</span>
<span class="sd">    genomes folder, return taxonomic information from that csv file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define path to info file.</span>
    <span class="n">info_csv</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">db_info_csv</span>

    <span class="c1"># Parse info file with pandas.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">info_csv</span><span class="p">)</span>

    <span class="c1"># Iterate through rows until one is found with the same species name.</span>
    <span class="n">taxonomic_info_obj</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">found_row</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">species</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">species</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Species (if applicable)&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">parsed_species_name</span> <span class="o">=</span> <span class="n">species_name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">species</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">parsed_species_name</span><span class="p">:</span>
                <span class="n">found_row</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">superbranch</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Superbranch&#39;</span><span class="p">]</span>
                <span class="n">supergroup</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Supergroup&#39;</span><span class="p">]</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Group&#39;</span><span class="p">]</span>
                <span class="n">taxonomic_info_obj</span> <span class="o">=</span> <span class="n">TaxonomicInfo</span><span class="p">(</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">supergroup</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">species</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">found_row</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">found_row</span><span class="p">:</span>
            <span class="k">break</span>


    <span class="k">assert</span> <span class="n">taxonomic_info_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify taxonomic</span>
<span class="s2">    information for species </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">species_name</span>

    <span class="k">return</span> <span class="n">taxonomic_info_obj</span></div>


<div class="viewcode-block" id="define_textface_for_labeling_stem"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.define_textface_for_labeling_stem">[docs]</a><span class="k">def</span> <span class="nf">define_textface_for_labeling_stem</span><span class="p">(</span><span class="n">clade_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define ete3 textface styles for different nodes of interest that need to be</span>
<span class="sd">    labeled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define TextFace objects for clade stem nodes/branches.</span>
    <span class="n">stem_clade</span> <span class="o">=</span> <span class="n">TextFace</span><span class="p">(</span><span class="n">clade_name</span><span class="p">)</span>

    <span class="c1"># Set some attributes</span>
    <span class="c1">#stem_clade.margin_top = 10</span>
    <span class="c1">#stem_clade.margin_right = 10</span>
    <span class="c1">#stem_clade.margin_left = 10</span>
    <span class="c1">#stem_clade.margin_bottom = 10</span>
    <span class="c1">#stem_clade.opacity = 0.5 # from 0 to 1</span>
    <span class="c1">#stem_clade.inner_border.width = 1 # 1 pixel border</span>
    <span class="c1">#stem_clade.inner_border.type = 1  # dashed line</span>
    <span class="c1">#stem_clade.border.width = 1</span>
    <span class="c1">#stem_clade.background.color = &quot;LightGreen&quot;</span>

    <span class="c1"># Return dictionary.</span>
    <span class="k">return</span> <span class="n">stem_clade</span></div>


<div class="viewcode-block" id="get_corresponding_node"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_corresponding_node">[docs]</a><span class="k">def</span> <span class="nf">get_corresponding_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the ete3 TreeNode object in a tree that corresponds to</span>
<span class="sd">    a given node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Search for a node with child leaf nodes that have the same set of names.</span>
    <span class="n">corresponding_node</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">node_leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_leaves</span><span class="p">):</span>
            <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">break</span>
    <span class="c1"># If necessary, re-root input tree on midpoint for parsing.</span>
    <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Re-root on midpoint.</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>
        <span class="c1"># Search for node of interest again.</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_leaves</span><span class="p">):</span>
                <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">break</span>

    <span class="c1"># Try rooting on random leaf nodes until the corresponding node can be</span>
    <span class="c1"># found.</span>
    <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Loop through random leaf nodes in tree, rooting on them, and then</span>
        <span class="c1"># searching for the corresponding node.</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="c1"># Search for node of interest again.</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_leaves</span><span class="p">):</span>
                    <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="c1"># Check that a corresponding node was identified.</span>
    <span class="k">assert</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not find corresponding</span>
<span class="s2">    node.&quot;&quot;&quot;</span>

    <span class="c1"># Return corresponding node.</span>
    <span class="k">return</span> <span class="n">corresponding_node</span></div>


<div class="viewcode-block" id="get_list_of_leaf_names_for_node"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_list_of_leaf_names_for_node">[docs]</a><span class="k">def</span> <span class="nf">get_list_of_leaf_names_for_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an ete3 TreeNode object, return a list of terminal/leaf node</span>
<span class="sd">    names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">leaf_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">leaf_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf_names</span></div>


<div class="viewcode-block" id="get_clade_name_from_model2"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_clade_name_from_model2">[docs]</a><span class="k">def</span> <span class="nf">get_clade_name_from_model2</span><span class="p">(</span><span class="n">type_seq_name</span><span class="p">,</span> <span class="n">type_seqs_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return clade name for given type sequence name and type seqs info file</span>
<span class="sd">    (from models directory).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get clade name.</span>
    <span class="n">clade_name</span> <span class="o">=</span> <span class="s1">&#39;?&#39;</span>
    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">type_seqs_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">type_seq_name</span> <span class="o">==</span> <span class="n">type_seqs_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
                <span class="n">clade_name</span> <span class="o">=</span> <span class="n">clade</span>
                <span class="k">break</span>
        <span class="k">elif</span> <span class="n">type_seq_name</span> <span class="o">==</span> <span class="n">type_seqs_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="n">clade_name</span> <span class="o">=</span> <span class="n">clade</span>
            <span class="k">break</span>
    <span class="k">assert</span> <span class="n">clade_name</span> <span class="o">!=</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify clade name for type</span>
<span class="s2">    sequence name </span><span class="si">%s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">type_seq_name</span>

    <span class="k">return</span> <span class="n">clade_name</span></div>


<div class="viewcode-block" id="get_nodes_from_actual_tree_obj"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_nodes_from_actual_tree_obj">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_from_actual_tree_obj</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">nodes_of_interest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get nodes in the given tree object that correspond to the nodes in a</span>
<span class="sd">    given list of nodes from another tree object, and return as a list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">## Temp.</span>
    <span class="c1">#print(&#39;\n\nget_nodes_from_actual_tree_obj function call...&#39;)</span>
    <span class="c1">#print(&#39;Input tree:&#39;)</span>
    <span class="c1">#print(t3)</span>

    <span class="c1"># Get original root node for tree object.</span>
    <span class="n">original_outgroup</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">())[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Compile a list of corresponding nodes.</span>
    <span class="n">new_node_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes_of_interest</span><span class="p">:</span>
        <span class="c1">## Temp.</span>
        <span class="c1">#print(&#39;Node of interest&#39;)</span>
        <span class="c1">#print(i)</span>

        <span class="n">i_leaf_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span>
        <span class="n">corresponding_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Traverse the tree to find node.</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="n">node_leaf_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
            <span class="c1"># If the node has the same set of leaf names, then it is the</span>
            <span class="c1"># corresponding node.</span>
            <span class="k">if</span> <span class="n">node_leaf_names</span> <span class="o">==</span> <span class="n">i_leaf_names</span><span class="p">:</span>
                <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">node</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Generate a list of three different rootings for the tree, at</span>
            <span class="c1"># least one of which should allow identification of the clade of</span>
            <span class="c1"># interest.</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>
            <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>
            <span class="c1">#print(&#39;Rerooted tree on midpoint:&#39;)</span>
            <span class="c1">#print(t3)</span>
            <span class="n">side1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">())[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">side2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">())[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="n">side1</span><span class="p">,</span> <span class="n">side2</span><span class="p">]:</span>
                <span class="n">side_longest_length</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">side_longest_leaf</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">side</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                    <span class="n">length</span> <span class="o">=</span> <span class="n">side</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">side_longest_length</span><span class="p">:</span>
                        <span class="n">side_longest_length</span> <span class="o">=</span> <span class="n">length</span>
                        <span class="n">side_longest_leaf</span> <span class="o">=</span> <span class="n">leaf</span>
                <span class="c1"># Check that a leaf was identified.</span>
                <span class="k">assert</span> <span class="n">side_longest_leaf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="c1"># Add the longest leaf on this side of the midpoint to the list</span>
                <span class="c1"># of nodes on which to try rooting the tree.</span>
                <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">side_longest_leaf</span><span class="p">)</span>

            <span class="c1"># Try finding the corresponding node again.</span>
            <span class="k">for</span> <span class="n">root_node</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
                <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">root_node</span><span class="p">)</span>
                <span class="c1">#print(&#39;Rerooted tree:&#39;)</span>
                <span class="c1">#print(t3)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="n">node_leaf_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span>
                    <span class="c1"># If the node has the same set of leaf names, then it is the</span>
                    <span class="c1"># corresponding node.</span>
                    <span class="k">if</span> <span class="n">node_leaf_names</span> <span class="o">==</span> <span class="n">i_leaf_names</span><span class="p">:</span>
                        <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>

            <span class="c1"># Try finding the corresponding node again by rooting on every</span>
            <span class="c1"># single leaf until the node of interest is found.</span>
            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
                <span class="c1">#print(&#39;Rerooted tree:&#39;)</span>
                <span class="c1">#print(t3)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="n">node_leaf_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span>
                    <span class="c1"># If the node has the same set of leaf names, then it is the</span>
                    <span class="c1"># corresponding node.</span>
                    <span class="k">if</span> <span class="n">node_leaf_names</span> <span class="o">==</span> <span class="n">i_leaf_names</span><span class="p">:</span>
                        <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>

            <span class="c1"># Check that the corresponding node was found.</span>
            <span class="k">assert</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># Root on the corresponding node identified.</span>
            <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">corresponding_node</span><span class="p">)</span>

        <span class="c1"># Check that the corresponding node was found.</span>
        <span class="k">assert</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># Append the corresponding node to the list.</span>
        <span class="n">new_node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corresponding_node</span><span class="p">)</span>

    <span class="c1"># Re-root the tree object on the original root node.</span>
    <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">original_outgroup</span><span class="p">)</span>

    <span class="c1"># Return the list of corresponding nodes.</span>
    <span class="k">return</span> <span class="n">new_node_list</span></div>


<div class="viewcode-block" id="get_nodes_of_interest"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_nodes_of_interest">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_of_interest</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">type_seq_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take an ete3 tree (TreeNode object), a list of type sequence names, and</span>
<span class="sd">    return a list of nodes of interest defined by clades (as ete3 TreeNode</span>
<span class="sd">    objects).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate list of orthogroup nodes of interest.</span>
    <span class="n">orthogroup_nodes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Make a copy of the input tree.</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># For each &quot;type&quot; sequence, traverse all nodes and find the node with</span>
    <span class="c1"># the largest number of child nodes that are leaf (terminal) nodes,</span>
    <span class="c1"># containing the &quot;type&quot; sequence of interest, but not containing any of</span>
    <span class="c1"># the other &quot;type&quot; sequences.</span>
    <span class="n">ts_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
        <span class="n">ts_num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="c1"># Root on another &quot;type&quot; sequence for the first type sequence in</span>
            <span class="c1"># the list to get whole clade, then root the tree on the ancestor</span>
            <span class="c1"># node of that first clade.</span>

            <span class="c1"># Get a node name for a node corresponding to a different</span>
            <span class="c1"># &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ts</span><span class="p">:</span>
                    <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
            <span class="k">assert</span> <span class="n">other_type_seq_node_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># Get node corresponding to a different &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_type_seq_node_name</span><span class="p">:</span>
                    <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">break</span>
            <span class="k">assert</span> <span class="n">other_type_seq_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify</span>
<span class="s2">            a type seq node with name: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">other_type_seq_node_name</span>

            <span class="c1"># Root on the other &quot;type&quot; sequence node.</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">other_type_seq_node</span><span class="p">)</span>

            <span class="c1">#print(&#39;\n\n\nTree rooted on a type sequence other than the first type sequence.&#39;)</span>
            <span class="c1">#print(t2)</span>

        <span class="k">elif</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Root on the first &quot;type&quot; sequence node for all subsequent</span>
            <span class="c1"># clades.</span>
            <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="n">leaf_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_type_seq_node_name</span><span class="p">:</span>
                        <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">first_type_seq_node</span><span class="p">)</span>
            <span class="c1">#print(&#39;\n\n\nTree re-rooted on first type sequence:&#39;)</span>
            <span class="c1">#print(t2)</span>


        <span class="c1"># Make a copy of the tree topology to work with for each run</span>
        <span class="c1"># through this loop.</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Make a list of nodes that contain type seq, but not any others. #</span>
        <span class="c1"># SEPARATE</span>
        <span class="n">nodes_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="c1"># Search in nodes that contain the type sequence.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts</span><span class="p">):</span>
                <span class="c1"># Search in nodes that don&#39;t contain other type sequences.</span>
                <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">ts2</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ts2</span> <span class="o">==</span> <span class="n">ts</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts2</span><span class="p">):</span>
                            <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_other_type_seqs</span><span class="p">:</span>
                    <span class="c1"># Add nodes of interest to list.</span>
                    <span class="n">nodes_of_interest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Check that a node of interest was found.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>

        <span class="c1"># find the node with the most child leaf nodes.</span>
        <span class="n">node_w_most_leaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#node_w_most_leaves.name = &#39;X&#39;</span>

        <span class="c1"># Add node to list of nodes of interest.</span>
        <span class="n">orthogroup_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ts</span><span class="p">,</span> <span class="n">node_w_most_leaves</span><span class="p">])</span>

    <span class="c1"># Return list of lists containing defining sequence name and node object.</span>
    <span class="k">return</span> <span class="n">orthogroup_nodes</span></div>


<div class="viewcode-block" id="define_nodestyles_dict_for_colourcoding"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.define_nodestyles_dict_for_colourcoding">[docs]</a><span class="k">def</span> <span class="nf">define_nodestyles_dict_for_colourcoding</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Define node styles for different nodes of interest that need to be</span>
<span class="sd">    colour-coded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate dict.</span>
    <span class="n">nodestyle_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># General default style for tree (apply using the node.set_style(style)</span>
    <span class="c1"># function).</span>
    <span class="n">style</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;fgcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#0f0f0f&quot;</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;vt_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#ff0000&quot;</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#ff0000&quot;</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;vt_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;vt_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 0 solid, 1 dashed, 2 dotted</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># dashed blue lines</span>
    <span class="n">style1</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;fgcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#000000&quot;</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;circle&quot;</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;vt_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#0000aa&quot;</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;hz_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#0000aa&quot;</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;vt_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;vt_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 0 solid, 1 dashed, 2 dotted</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;hz_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># stem_node</span>
    <span class="n">stem_node</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="n">stem_node</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># bold lines</span>
    <span class="n">style2</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="c1">#style2[&quot;vt_line_width&quot;] = 8</span>
    <span class="n">style2</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># bold dashed lines</span>
    <span class="n">style3</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="n">style3</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">style3</span><span class="p">[</span><span class="s2">&quot;hz_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>


    <span class="c1"># Set dashed blue lines in all leaves</span>
    <span class="c1">#style3 = NodeStyle()</span>
    <span class="c1">#style3[&quot;fgcolor&quot;] = &quot;#000000&quot;</span>
    <span class="c1">#style3[&quot;shape&quot;] = &quot;circle&quot;</span>
    <span class="c1">#style3[&quot;vt_line_color&quot;] = &quot;#0000aa&quot;</span>
    <span class="c1">#style3[&quot;hz_line_color&quot;] = &quot;#0000aa&quot;</span>
    <span class="c1">#style3[&quot;vt_line_width&quot;] = 2</span>
    <span class="c1">#style3[&quot;hz_line_width&quot;] = 2</span>
    <span class="c1">#style3[&quot;vt_line_type&quot;] = 1 # 0 solid, 1 dashed, 2 dotted</span>
    <span class="c1">#style3[&quot;hz_line_type&quot;] = 1</span>


    <span class="c1"># Add styles to dictionary.</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">style1</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;stem_node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stem_node</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;shortest branch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">style2</span> <span class="c1"># bold.</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;longest branch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">style3</span> <span class="c1"># dashed.</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">style1</span>

    <span class="c1"># Return dict.</span>
    <span class="k">return</span> <span class="n">nodestyle_dict</span></div>

<div class="viewcode-block" id="get_abayes_support_for_node_from_another_tree"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_abayes_support_for_node_from_another_tree">[docs]</a><span class="k">def</span> <span class="nf">get_abayes_support_for_node_from_another_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                                                  <span class="n">t_with_abayes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a node from one ete3 TreeNode object and find the corresponding</span>
<span class="sd">    node in another ete3 TreeNode object and return the support value for the</span>
<span class="sd">    node in the second tree (the abayes support value).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get corresponding node.</span>
    <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">get_corresponding_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t_with_abayes</span><span class="p">)</span>

    <span class="c1"># Return support value.</span>
    <span class="k">return</span> <span class="n">corresponding_node</span><span class="o">.</span><span class="n">support</span></div>


<div class="viewcode-block" id="get_ml_tree_info_dict"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_ml_tree_info_dict">[docs]</a><span class="k">def</span> <span class="nf">get_ml_tree_info_dict</span><span class="p">(</span><span class="n">ml_tree_path</span><span class="p">,</span>
                          <span class="n">type_seqs_dict</span><span class="p">,</span>
                          <span class="n">annotated_tree_outpath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to an ML tree and return a dict with information about</span>
<span class="sd">    lengths and supports of relevant branches.</span>
<span class="sd">    </span>
<span class="sd">    Return a dictionary with keys as type sequence names and values lists with branch</span>
<span class="sd">    length ratios and branch support values for the respective clades in the input tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate output dictionary.</span>
    <span class="n">branch_length_info_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Parse tree file.</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">ml_tree_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Define a dictionary of ete3 NodeStyle objects for different branch types</span>
    <span class="c1"># in the tree to be visualized.</span>
    <span class="n">style_dict</span> <span class="o">=</span> <span class="n">define_nodestyles_dict_for_colourcoding</span><span class="p">()</span>

    <span class="c1"># Get a list of nodes of interest (ancestral nodes for clades of interest).</span>
    <span class="n">orthogroup_nodes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Get list of &quot;type&quot; sequences from input.</span>
    <span class="c1">#type_seq_list = []</span>
    <span class="c1">#for i in open(type_seqs):</span>
    <span class="c1">#    type_seq_list.append(i.strip().split(&#39;,&#39;)[0])</span>
    <span class="n">type_seq_list</span> <span class="o">=</span> <span class="n">type_seqs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="c1"># Copy tree for colour-coding etc.</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Translate node names (support values) to branch supports so that when the</span>
    <span class="c1"># tree is re-rooted, the supports won&#39;t be mixed up.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># Assign support attribute value to node.</span>
                <span class="n">alrt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">abayes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">node</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">alrt</span> <span class="c1"># Get abayes later.</span>
                <span class="c1">## Round up the node support value to 2 significant digits.</span>
                <span class="c1">#node.support = float(format(node.support * 0.01, &#39;3.2f&#39;))</span>
                <span class="c1"># Delete existing node name attribute for node.</span>
                <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># Make a tree object with abayes supports instead of alrt.</span>
    <span class="n">t_with_abayes</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># Use this tree later to retrieve abayes values for nodes.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t_with_abayes</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># Assign support attribute value to node.</span>
                <span class="n">alrt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">abayes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">node</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">abayes</span>
                <span class="c1">## Round up the node support value to 2 significant digits.</span>
                <span class="c1">#node.support = float(format(node.support * 0.01, &#39;3.2f&#39;))</span>
                <span class="c1"># Delete existing node name attribute for node.</span>
                <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>


    <span class="c1"># Root on the midpoint, because ete3 was having trouble identifying clades</span>
    <span class="c1"># in some of the unrooted trees.</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>
    <span class="n">t_with_abayes</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">t_with_abayes</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>

    <span class="c1"># Get list of nodes of interest.</span>
    <span class="n">orthogroup_nodes</span> <span class="o">=</span> <span class="n">get_nodes_of_interest</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">type_seq_list</span><span class="p">)</span>


    <span class="c1">###########################</span>
    <span class="c1"># Get lengths and supports for internal branches (excluding those within</span>
    <span class="c1"># the specific clades of interest) and add those to the dictionary as a</span>
    <span class="c1"># list of dictionaries.</span>

    <span class="c1"># Initiate list to store dictionaries with info for each internal branch.</span>
    <span class="n">internal_branch_info_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Copy the tree object(s).</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">t3_abayes</span> <span class="o">=</span> <span class="n">t_with_abayes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Record initial number of nodes.</span>
    <span class="n">initial_node_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span>

    <span class="c1"># Record which node is the original outgroup.</span>
    <span class="n">original_outgroup</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">())[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Find nodes of interest in new tree object for detaching.</span>
    <span class="n">orthogroup_nodes_t3</span> <span class="o">=</span> <span class="n">get_nodes_from_actual_tree_obj</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orthogroup_nodes</span><span class="p">])</span>
    <span class="n">orthogroup_nodes_t3_abayes</span> <span class="o">=</span> <span class="n">get_nodes_from_actual_tree_obj</span><span class="p">(</span><span class="n">t3_abayes</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orthogroup_nodes</span><span class="p">])</span>

    <span class="c1"># Re-root on one of the nodes of interest.</span>
    <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">orthogroup_nodes_t3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">t3_abayes</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">orthogroup_nodes_t3_abayes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1">#print(&#39;\nt3 before detaching nodes of interest:&#39;)</span>
    <span class="c1">#print(t3)</span>

    <span class="c1"># Detach all nodes of interest in the copy of the tree.</span>
    <span class="c1">#for i in to_remove_list:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">orthogroup_nodes_t3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">():</span>
            <span class="n">j</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">orthogroup_nodes_t3_abayes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">():</span>
            <span class="n">j</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
    <span class="c1">#print(&#39;\ntree with nodes removed (is this right???***):&#39;)</span>
    <span class="c1">#print(t3)</span>

    <span class="c1"># Record (reduced) number of nodes.</span>
    <span class="n">reduced_node_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span>

    <span class="c1"># Check that at least one node was actually removed.</span>
    <span class="k">assert</span> <span class="n">reduced_node_num</span> <span class="o">&lt;</span> <span class="n">initial_node_num</span>
    <span class="c1"># Check that the tree has the minimum number of nodes.</span>
    <span class="k">assert</span> <span class="n">reduced_node_num</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orthogroup_nodes</span><span class="p">)</span>
    <span class="c1"># Check that the two pruned trees have the same number of nodes.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t3_abayes</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span>

    <span class="c1"># Unroot pruned tree so that there are no internal branches that are split</span>
    <span class="c1"># up by the root.</span>
    <span class="n">t3</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>
    <span class="n">t3_abayes</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>

    <span class="c1"># Get internal branch lengths and support values from pruned copy of the</span>
    <span class="c1"># tree (all the branches left are internal branches of interest).</span>
    <span class="n">internal_branch_info_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node_alrt_sup</span><span class="p">,</span> <span class="n">node_abayes_sup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">(),</span> <span class="n">t3_abayes</span><span class="o">.</span><span class="n">traverse</span><span class="p">()):</span>
        <span class="c1"># Get branch length.</span>
        <span class="k">assert</span> <span class="n">node_alrt_sup</span><span class="o">.</span><span class="n">dist</span> <span class="o">==</span> <span class="n">node_abayes_sup</span><span class="o">.</span><span class="n">dist</span>
        <span class="n">branch_length</span> <span class="o">=</span> <span class="n">node_alrt_sup</span><span class="o">.</span><span class="n">dist</span>

        <span class="c1"># Ignore the root node (branch length 0).</span>
        <span class="k">if</span> <span class="n">branch_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Initiate dict to store info for this branch.</span>
            <span class="n">branch_dict</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Add branch length to dict.</span>
            <span class="n">branch_dict</span><span class="p">[</span><span class="s1">&#39;branch length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_length</span>

            <span class="c1"># Add branch supports to dict.</span>
            <span class="n">branch_dict</span><span class="p">[</span><span class="s1">&#39;alrt support&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_alrt_sup</span><span class="o">.</span><span class="n">support</span>
            <span class="n">branch_dict</span><span class="p">[</span><span class="s1">&#39;abayes support&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_abayes_sup</span><span class="o">.</span><span class="n">support</span>

            <span class="c1"># Add dict to list of branch dicts.</span>
            <span class="n">internal_branch_info_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch_dict</span><span class="p">)</span>

    <span class="c1"># Check that a minimum number of internal nodes were identified.</span>
    <span class="c1">#assert len(internal_branch_lengths) &gt;= len(orthogroup_nodes), &quot;&quot;&quot;Too few</span>
    <span class="c1">#internal nodes identified.&quot;&quot;&quot;</span>

    <span class="c1"># Add internal branch lengths and supports as a list of dicts to the output</span>
    <span class="c1"># dict.</span>
    <span class="n">branch_length_info_dict</span><span class="p">[</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">internal_branch_info_list</span>

    <span class="c1">###########################</span>
    <span class="c1"># Determine characteristics of clades of interest.</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">seq_node_list</span> <span class="ow">in</span> <span class="n">orthogroup_nodes</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">type_seq</span> <span class="o">=</span> <span class="n">seq_node_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">clade_name</span> <span class="o">=</span> <span class="n">get_clade_name_from_model2</span><span class="p">(</span><span class="n">type_seq</span><span class="p">,</span> <span class="n">type_seqs_dict</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">seq_node_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1">#print(&#39;\n\nClade defined by sequence &#39; + type_seq + &#39;:&#39;)</span>
        <span class="c1">#print(node)</span>

        <span class="c1"># Get list of leaf names.</span>
        <span class="n">leaf_names</span> <span class="o">=</span> <span class="n">get_list_of_leaf_names_for_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Get stem length for node.</span>
        <span class="n">stem_len</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span>
        <span class="c1">#print(&#39;\nStem length: &#39; + str(stem_len))</span>

        <span class="c1"># Get branch lengths for all sequences in the clade.</span>
        <span class="c1">#print(&#39;\nBranch lengths:&#39;)</span>
        <span class="n">seq_branch_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="c1">#print(&#39;\t&#39; + n.name + &#39;: &#39; + str(length))</span>
                <span class="n">seq_branch_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="p">])</span>

        <span class="c1"># Get longest branch length.</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">seq_branch_lengths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#print(&#39;\n\tLongest branch: &#39; + max_len[0] + &#39; &#39; + str(max_len[1]))</span>

        <span class="c1"># Get shortest branch length.</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">seq_branch_lengths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#print(&#39;\n\tShortest branch: &#39; + min_len[0] + &#39; &#39; + str(min_len[1]))</span>

        <span class="c1"># Get average branch length relative to ancestral/root node in the</span>
        <span class="c1"># clade for each sequence/terminal/leaf node.</span>
        <span class="n">mean_len</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq_branch_lengths</span><span class="p">])</span>
        <span class="c1">#print(&#39;\n\tMean length: &#39; + str(mean_len))</span>

        <span class="c1"># Get median branch length relative to ancestral/root node in the</span>
        <span class="c1"># clade for each sequence/terminal/leaf node.</span>
        <span class="n">median_len</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">median</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq_branch_lengths</span><span class="p">])</span>
        <span class="c1">#print(&#39;\n\tMedian length: &#39; + str(median_len))</span>

        <span class="c1"># Calculate ratio of stem length to average branch length.</span>
        <span class="n">stem_branches_ratio</span> <span class="o">=</span> <span class="n">stem_len</span> <span class="o">/</span> <span class="n">mean_len</span>
        <span class="c1">#print(&#39;\n\tRatio of stem len to avg branch len: &#39; + str(stem_branches_ratio))</span>


        <span class="c1"># Format tree for visualization.</span>

        <span class="c1"># Root on first clade of interest.</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#print(&#39;\n\n\n\n&#39;)</span>
            <span class="c1">#print(&#39;t2:&#39;)</span>
            <span class="c1">#print(t2)</span>
            <span class="c1">#print(t2.write())</span>
            <span class="c1">#print(&#39;node:&#39;)</span>
            <span class="c1">#print(node)</span>
            <span class="c1">#print(&#39;\n\n\n\n&#39;)</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">get_corresponding_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">t2</span><span class="p">))</span>

        <span class="c1"># Make stem branch for clade of interest bold.</span>
        <span class="n">stem_node</span> <span class="o">=</span> <span class="n">get_corresponding_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
        <span class="n">stem_node</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="n">style_dict</span><span class="p">[</span><span class="s1">&#39;stem_node&#39;</span><span class="p">])</span>

        <span class="c1"># Add clade name to stem branch.</span>
        <span class="c1">#stem_node.name = clade_name</span>
        <span class="n">stem_node</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">define_textface_for_labeling_stem</span><span class="p">(</span><span class="n">clade_name</span><span class="p">),</span> <span class="n">column</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="s2">&quot;branch-top&quot;</span><span class="p">)</span>

        <span class="c1"># Iterate over branches within clade and customize appearance.</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
            <span class="c1"># Set general features for all leaf nodes.</span>
            <span class="n">style</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
            <span class="n">style</span><span class="p">[</span><span class="s2">&quot;fgcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#0f0f0f&quot;</span>
            <span class="n">style</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">style</span><span class="p">[</span><span class="s2">&quot;vt_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#000000&quot;</span>
            <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#000000&quot;</span>

            <span class="c1">#style[&quot;vt_line_width&quot;] = 8</span>
            <span class="c1">#style[&quot;hz_line_width&quot;] = 8</span>
            <span class="c1">#style[&quot;vt_line_type&quot;] = 0 # 0 solid, 1 dashed, 2 dotted</span>
            <span class="c1">#style[&quot;hz_line_type&quot;] = 0</span>

            <span class="c1"># Make shortest branch in clade of interest bold.</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">min_len</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1">#shortbranchnode = get_corresponding_node(t1.search_nodes(name=min_len[0])[0], t2)</span>
                <span class="c1">#shortbranchnode.set_style(style_dict[&#39;shortest branch&#39;])</span>
                <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

            <span class="c1"># Make longest branch in clade of interest bold.</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">max_len</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1">#longbranchnode = get_corresponding_node(t1.search_nodes(name=max_len[0])[0], t2)</span>
                <span class="c1">#longbranchnode.set_style(style_dict[&#39;longest branch&#39;])</span>
                <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            
            <span class="c1"># Customize leaf node appearance.</span>
            <span class="c1"># Get species name.</span>
            <span class="c1">#species_name = leaf.name.replace(&#39;__&#39;, &#39; &#39;).replace(&#39;_&#39;, &#39; &#39;).split(&#39; &#39;, 1)[1]</span>
            <span class="n">species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="c1">#print(species_name)</span>

            <span class="c1"># Check that the name does not end with &#39;.copy&#39;.</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">species_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.copy&#39;</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;A sequence with an</span>
<span class="s2">            identical name to a sequence already in the alignment/tree was</span>
<span class="s2">            apparently added: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span>

            <span class="n">ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
            <span class="c1">#print(&#39;\t&#39; + &#39; &#39;.join([str(ti.superbranch), str(ti.supergroup),</span>
            <span class="c1">#    str(ti.group), str(ti.species)]))</span>

            <span class="c1"># Set style for node.</span>
            <span class="n">get_corresponding_node</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="n">style</span><span class="p">)</span>

        <span class="c1"># Sort seq names by descending branch lengths.</span>
        <span class="n">seq_names_by_br_len</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">(),</span>\
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="c1"># Identify most &quot;basal&quot; sequence in the clade, and the length of the</span>
        <span class="c1"># stem for the remaining seqs.</span>
        <span class="c1"># The node that is sister to the most basal sequence would be the one</span>
        <span class="c1"># that has the most daughter nodes.</span>
        <span class="n">basal_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">node_sister_to_basal_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node_sister_to_basal_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node_sister_to_basal_node</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_sister_to_basal_node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()):</span>
                <span class="n">node_sister_to_basal_node</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">sister_leaf_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_sister_to_basal_node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">in_sister</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">sister_leaf_names</span><span class="p">:</span> 
                    <span class="n">in_sister</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_sister</span><span class="p">:</span>
                <span class="n">basal_node</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">break</span>
        <span class="c1"># Check whether the basal node was identified.</span>
        <span class="k">assert</span> <span class="n">basal_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># Define name of basal node.</span>
        <span class="n">basal_node_name</span> <span class="o">=</span> <span class="s1">&#39;clade&#39;</span>
        <span class="k">if</span> <span class="n">basal_node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">basal_node_name</span> <span class="o">=</span> <span class="n">basal_node</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># Define stem length of the clade that is sister to the &quot;basal&quot; clade.</span>
        <span class="n">basal_node_depth</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">node_sister_to_basal_node</span><span class="p">)</span>

        <span class="c1"># Get support values for clade.</span>
        <span class="n">alrt_support_value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">support</span>
        <span class="c1">#print(&#39;alrt: &#39; + str(alrt_support_value))</span>
        <span class="c1"># Have to retrieve abayes value from another tree object.</span>
        <span class="n">abayes_support_value</span> <span class="o">=</span>\
        <span class="n">get_abayes_support_for_node_from_another_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t_with_abayes</span><span class="p">)</span>
        <span class="c1">#print(&#39;abayes: &#39; + str(abayes_support_value))</span>

        <span class="c1"># Add info to output dictionary.</span>
        <span class="n">branch_length_info_dict</span><span class="p">[</span><span class="n">clade_name</span><span class="p">]</span> <span class="o">=</span>\
                <span class="p">{</span><span class="s1">&#39;stem length&#39;</span><span class="p">:</span> <span class="n">stem_len</span><span class="p">,</span>
                 <span class="s1">&#39;average branch length&#39;</span><span class="p">:</span> <span class="n">mean_len</span><span class="p">,</span>
                 <span class="s1">&#39;stem/branch ratio&#39;</span><span class="p">:</span> <span class="n">stem_branches_ratio</span><span class="p">,</span>
                 <span class="s1">&#39;seq names by descending length&#39;</span><span class="p">:</span> <span class="n">seq_names_by_br_len</span><span class="p">,</span>
                 <span class="s1">&#39;basal node name&#39;</span><span class="p">:</span> <span class="n">basal_node_name</span><span class="p">,</span>
                 <span class="s1">&#39;basal node depth&#39;</span><span class="p">:</span> <span class="n">basal_node_depth</span><span class="p">,</span>
                 <span class="c1">#&#39;internal branch lengths&#39;: internal_branch_lengths,</span>
                 <span class="s1">&#39;alrt support&#39;</span><span class="p">:</span> <span class="n">alrt_support_value</span><span class="p">,</span>
                 <span class="s1">&#39;abayes support&#39;</span><span class="p">:</span> <span class="n">abayes_support_value</span>
                 <span class="p">}</span>



    <span class="c1"># Show tree annotations.</span>

    <span class="c1"># Remove underscores from leaf names.</span>
    <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
        <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>

    <span class="c1"># Stretch branches.</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">TreeStyle</span><span class="p">()</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">show_leaf_name</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span>  <span class="mi">120</span> <span class="c1"># 120 pixels per branch length unit</span>

    <span class="c1"># Add title.</span>
    <span class="n">tree_title</span> <span class="o">=</span> <span class="s2">&quot;[Tree title here]&quot;</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">TextFace</span><span class="p">(</span><span class="n">tree_title</span><span class="p">,</span> <span class="n">fsize</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span> <span class="n">column</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Show.</span>
    <span class="c1">#t2.show(tree_style=ts)</span>

    <span class="c1"># Write tree to file.</span>
    <span class="k">if</span> <span class="n">annotated_tree_outpath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t2</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">annotated_tree_outpath</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">183</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="n">tree_style</span><span class="o">=</span><span class="n">ts</span><span class="p">)</span>

    <span class="c1"># Return main output path.</span>
    <span class="k">return</span> <span class="n">branch_length_info_dict</span></div>


<div class="viewcode-block" id="get_constraint_tree_fp"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_constraint_tree_fp">[docs]</a><span class="k">def</span> <span class="nf">get_constraint_tree_fp</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to an alignment, and return a path to use for a</span>
<span class="sd">    corresponding contraint tree topology.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_constraint_tree.newick&#39;</span>
    <span class="k">return</span> <span class="n">constraint_tree_fp</span></div>


<div class="viewcode-block" id="run_tree_for_branch_lengths_and_supports_for_topology"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.run_tree_for_branch_lengths_and_supports_for_topology">[docs]</a><span class="k">def</span> <span class="nf">run_tree_for_branch_lengths_and_supports_for_topology</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span>
                                                          <span class="n">alignment</span><span class="p">,</span>
                                                          <span class="n">subs_model</span><span class="p">,</span>
                                                          <span class="n">outputdir</span><span class="p">,</span>
                                                          <span class="n">place_seq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run an ML tree and branch support tests given a tree (for constraining</span>
<span class="sd">    topology), an alignment file, and a substitution model. Return path to</span>
<span class="sd">    output tree file.</span>

<span class="sd">    Optionally use the place_seq option to just do an ML search to place a</span>
<span class="sd">    sequence in a constrained topology with the -g option.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get list of all sequence names in alignment.</span>
    <span class="n">all_seq_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)]</span>

    <span class="c1"># Check that the input tree file exists.</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Input tree file path doesn&#39;t exist.&quot;&quot;&quot;</span>

    <span class="c1"># Get list of all leaf names for tree.</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">all_leaf_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tx</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>

    <span class="c1"># Check that the list of leaf names is the same as the list of sequence</span>
    <span class="c1"># names in the alignment.</span>
    <span class="c1">#for i, j in zip(sorted(all_seq_names), sorted(all_leaf_names)):</span>
    <span class="c1">#    print(i + &#39;, &#39; + j)</span>
    <span class="c1">#print(all_seq_names)</span>
    <span class="c1">#print(all_leaf_names)</span>
    <span class="k">if</span> <span class="n">place_seq</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Constraint tree</span>
<span class="s2">        should have one less sequence than alignment.&quot;&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Different number of</span>
<span class="s2">        sequences represented in the tree vs. alignment.&quot;&quot;&quot;</span>

    <span class="c1"># Convert nexus alignment to afa.</span>
    <span class="n">temp_fa_1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span>\
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_temp1.afa&#39;</span><span class="p">)</span>
    <span class="n">nex_to_afa</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">)</span> 

    <span class="c1"># Code names in alignment.</span>
    <span class="n">outalifp</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.afa&#39;</span>
    <span class="n">outtablefp</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.table&#39;</span>
    <span class="n">code_names_in_ali</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">,</span> <span class="n">outalifp</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span> 

    <span class="c1"># Convert alignment back to nexus.</span>
    <span class="n">outalifpnex</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.nex&#39;</span>
    <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">outalifp</span><span class="p">,</span> <span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Get list of all sequence names in coded alignment.</span>
    <span class="n">all_seq_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)]</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_fa_1</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifp</span><span class="p">)</span>

    <span class="c1"># Define path for intermediate unrooted tree.</span>
    <span class="n">tree2</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_unrooted_tree.newick&#39;</span>

    <span class="c1"># Parse tree using ete3.</span>
    <span class="c1"># Note: parentheses and commas and colons get replaced with underscores by</span>
    <span class="c1"># ete3.</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Unroot tree.</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>

    <span class="c1"># Write unrooted tree to a new file.</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">tree2</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>

    <span class="c1"># Define path for constraint tree file.</span>
    <span class="n">constraint_tree_fp_coded</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Only do the following steps once for all the alignments, because all the</span>
    <span class="c1"># constrained topology analyses will use the same constraint trees.</span>

    <span class="c1"># Put quotation marks around names in constraint tree. # SEPARATE</span>
    <span class="c1">#outtreefp = ali.rsplit(&#39;.&#39;, 1)[0] + &#39;.constraint_tree0.Q.newick&#39;</span>
    <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">place_seq</span><span class="p">:</span>
        <span class="c1"># Use the input tree path as the constraint tree if the place_seq</span>
        <span class="c1"># option is used (because using the previous topology without the new</span>
        <span class="c1"># sequence to constrain the ML tree search).</span>
        <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">tree</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">get_constraint_tree_fp</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree2</span><span class="p">)</span> <span class="k">as</span> <span class="n">intreefh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">intreefh</span><span class="p">:</span>
                <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">quote_tree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">))</span>

    <span class="c1"># Make constraint tree with coded names.</span>
    <span class="n">constraint_tree_fp_coded</span> <span class="o">=</span> <span class="n">constraint_tree_fp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.tre&#39;</span>
    <span class="n">code_tree</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">,</span> <span class="n">constraint_tree_fp_coded</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span>

    <span class="c1"># Get list of all leaf names for tree.</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">constraint_tree_fp_coded</span><span class="p">)</span>
    <span class="n">all_leaf_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tx</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>

    <span class="c1"># Check that the list of leaf names is the same as the list of sequence</span>
    <span class="c1"># names in the alignment.</span>
    <span class="k">if</span> <span class="n">place_seq</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Different number of</span>
<span class="s2">        sequences represented in the tree vs. alignment.&quot;&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Different number of</span>
<span class="s2">        sequences represented in the tree vs. alignment.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Sequence names in tree</span>
<span class="s2">        and alignment differ.&quot;&quot;&quot;</span>


    <span class="c1"># Make a copy of the alignment in phylip format for input to IQtree.</span>
    <span class="n">phy_out</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.phy&#39;</span>
    <span class="n">nex_to_phylip</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">)</span>

    <span class="c1"># Do phylogenetic analysis.</span>

    <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">place_seq</span><span class="p">:</span>
        <span class="c1"># Make subdir for output.</span>
        <span class="n">iter_num_str</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">subdirp</span> <span class="o">=</span> <span class="n">constraint_tree_fp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>\
        <span class="s1">&#39;_IQ-tree_output_place_seq_&#39;</span> <span class="o">+</span> <span class="n">iter_num_str</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">):</span>
            <span class="n">subdirp</span> <span class="o">=</span> <span class="o">...</span> 
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">)</span>

        <span class="c1"># Use IQtree to do an ML search</span>
        <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirp</span><span class="p">,</span> <span class="s1">&#39;iqtree&#39;</span><span class="p">)</span>
        <span class="n">iqtree_command_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span>
                               <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span>
                               <span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="n">constraint_tree_fp_coded</span><span class="p">,</span> 
                               <span class="s1">&#39;-pre&#39;</span><span class="p">,</span> <span class="n">output_file_prefix</span><span class="p">,</span> 
                               <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span>
                               <span class="p">]</span>
        <span class="n">stdout_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.stdout.txt&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stdout_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">o</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Make subdir for output.</span>
        <span class="n">subdirp</span> <span class="o">=</span> <span class="n">constraint_tree_fp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_IQ-tree_output&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">)</span>

        <span class="c1"># Use IQtree to do an ML search</span>
        <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirp</span><span class="p">,</span> <span class="s1">&#39;iqtree&#39;</span><span class="p">)</span>
        <span class="n">iqtree_command_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span>
                               <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span>
                               <span class="s1">&#39;-te&#39;</span><span class="p">,</span> <span class="n">constraint_tree_fp_coded</span><span class="p">,</span>
                               <span class="s1">&#39;-alrt&#39;</span><span class="p">,</span> <span class="s1">&#39;1000&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;-abayes&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;-pre&#39;</span><span class="p">,</span> <span class="n">output_file_prefix</span><span class="p">,</span> 
                               <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span>
                               <span class="p">]</span>
        <span class="n">stdout_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.stdout.txt&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stdout_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">o</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>

    <span class="c1"># Define path to output file.</span>
    <span class="n">tree_file_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.treefile&#39;</span>
    <span class="c1"># Check that the output file was actually produced.</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;IQtree did not produce a</span>
<span class="s2">    treefile.&quot;&quot;&quot;</span>

    <span class="c1"># Parse output tree.</span>
    <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>

    <span class="c1"># Uncode tree.</span>
    <span class="n">tree_file_path2</span> <span class="o">=</span> <span class="n">tree_file_path</span> <span class="o">+</span> <span class="s1">&#39;2&#39;</span>
    <span class="n">uncode_tree</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">,</span> <span class="n">tree_file_path2</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span>

    <span class="c1"># Return path to the tree with uncoded taxon names.</span>
    <span class="k">return</span> <span class="n">tree_file_path2</span> </div>


<div class="viewcode-block" id="get_type_seqs_dict"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_type_seqs_dict">[docs]</a><span class="k">def</span> <span class="nf">get_type_seqs_dict</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to a file listing sequences that define nodes of interest in</span>
<span class="sd">    a tree, and construct a dictionary with clade names as keys and sequence</span>
<span class="sd">    names as values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">type_seqs_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="n">spliti</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                <span class="n">seqname</span> <span class="o">=</span> <span class="n">spliti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cladename</span> <span class="o">=</span> <span class="n">spliti</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">type_seqs_dict</span><span class="p">[</span><span class="n">cladename</span><span class="p">]</span> <span class="o">=</span> <span class="n">seqname</span>
    <span class="k">return</span> <span class="n">type_seqs_dict</span></div>

<div class="viewcode-block" id="get_essential_taxa_list"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_essential_taxa_list">[docs]</a><span class="k">def</span> <span class="nf">get_essential_taxa_list</span><span class="p">(</span><span class="n">essential_taxa_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to a file listing essential taxa (taxonomy terms) and return</span>
<span class="sd">    a list of the terms in the file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">essential_taxa</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">essential_taxa_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">essential_taxa_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                    <span class="n">taxon</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">essential_taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">essential_taxa</span></div>


<div class="viewcode-block" id="get_y_measure_of_support"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_y_measure_of_support">[docs]</a><span class="k">def</span> <span class="nf">get_y_measure_of_support</span><span class="p">(</span><span class="n">previous_ali_tree_tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a tuple with objects containing info about an alignment and tree,</span>
<span class="sd">    and extract specific info to use as a measure of support for nodes of</span>
<span class="sd">    interest.</span>

<span class="sd">    *** Need to get support for all nodes of interest, not just for clades of</span>
<span class="sd">    interest, but also backbone nodes, and find the one with the lowest</span>
<span class="sd">    support.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get info dict from input tuple.</span>
    <span class="n">ml_tree_info_dict</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>

    <span class="c1"># For reference:</span>
    <span class="c1">#ml_tree_info_dict[clade_name] =\</span>
    <span class="c1">#        {&#39;stem length&#39;: stem_len,</span>
    <span class="c1">#         &#39;average branch length&#39;: mean_len,</span>
    <span class="c1">#         &#39;stem/branch ratio&#39;: stem_branches_ratio,</span>
    <span class="c1">#         &#39;seq names by descending length&#39;: seq_names_by_br_len,</span>
    <span class="c1">#         &#39;basal node name&#39;: basal_node_name,</span>
    <span class="c1">#         &#39;basal node depth&#39;: basal_node_depth,</span>
    <span class="c1">#         &#39;internal branch lengths&#39;: internal_branch_lengths,</span>
    <span class="c1">#         &#39;alrt support&#39;: alrt_support_value,</span>
    <span class="c1">#         &#39;abayes support&#39;: abayes_support_value</span>
    <span class="c1">#         }</span>

    <span class="c1"># Sort clades by alrt support.</span>
    <span class="n">clade_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">clade_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">)</span>

    <span class="n">clades_by_ascending_alrt_support</span> <span class="o">=</span>\
    <span class="nb">sorted</span><span class="p">(</span><span class="n">clade_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;alrt support&#39;</span><span class="p">])</span>

    <span class="c1">#clades_by_ascending_alrt_support = sorted(ml_tree_info_dict.keys(),\</span>
    <span class="c1">#        key=lambda x: ml_tree_info_dict[x][&#39;alrt support&#39;])</span>

    <span class="c1"># Get alrt branch support for the clade with the lowest alrt branch</span>
    <span class="c1"># support.</span>
    <span class="n">lowest_alrt</span> <span class="o">=</span> <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clades_by_ascending_alrt_support</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;alrt support&#39;</span><span class="p">]</span>

    <span class="c1"># Return measure of support.</span>
    <span class="k">return</span> <span class="n">lowest_alrt</span></div>


<div class="viewcode-block" id="search_alignment_space"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.search_alignment_space">[docs]</a><span class="k">def</span> <span class="nf">search_alignment_space</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span>
                           <span class="n">out_dir_path</span><span class="p">,</span>
                           <span class="n">mod_type</span><span class="p">,</span>
                           <span class="n">iterations</span><span class="p">,</span>
                           <span class="n">timestamp</span><span class="p">,</span>
                           <span class="n">file_with_seqs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                           <span class="n">essential_taxa_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Master function to manage the iterative process of modifying an</span>
<span class="sd">    alignment/tree, and assessing whether the modification results in better</span>
<span class="sd">    branch support for a topology of interest. In other words, optimize an</span>
<span class="sd">    alignment to support a backbone topology for clades of interest in the</span>
<span class="sd">    tree. IMPORTANT: Do this in parallel for alternative topologies and compare</span>
<span class="sd">    results to avoid cherry-picking.</span>

<span class="sd">    Replacement for optimize_sequence_selection2 and</span>
<span class="sd">    optimize_position_selection functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that modification type is valid.</span>
    <span class="k">assert</span> <span class="n">mod_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;remove_seqs&#39;</span><span class="p">,</span> <span class="s1">&#39;add_seqs&#39;</span><span class="p">,</span> <span class="s1">&#39;remove_columns&#39;</span><span class="p">,</span> <span class="s1">&#39;mixed&#39;</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;Invalid value provided with --mod_type option.&quot;&quot;&quot;</span>

    <span class="c1"># Define output directory path.</span>
    <span class="n">outputdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir_path</span><span class="p">,</span>\
            <span class="n">model_name</span> <span class="o">+</span> <span class="s1">&#39;_srch_ali_space_&#39;</span> <span class="o">+</span> <span class="n">timestamp</span><span class="p">)</span>

    <span class="c1"># Make output directory.</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outputdir</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outputdir</span><span class="p">)</span>

    <span class="c1"># Unpack information about current dataset and tree including assessment of</span>
    <span class="c1"># relevant branch supports.</span>

    <span class="c1"># Parse data from model.</span>
    <span class="c1"># Get info about model that is relevant.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parsing input alignment/tree...&#39;</span><span class="p">)</span>
    <span class="n">model_info</span> <span class="o">=</span> <span class="n">ModelInfoFromCSV</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">alignment_file</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">tree_topology_file</span>
    <span class="n">subs_model</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">subs_model</span>
    <span class="n">type_seqs_dict</span> <span class="o">=</span> <span class="n">get_type_seqs_dict</span><span class="p">(</span><span class="n">model_info</span><span class="o">.</span><span class="n">type_seqs_file</span><span class="p">)</span>

    <span class="c1"># Parse tree using ete3.</span>
    <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Print tree.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input tree:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>

    <span class="c1"># Compile list of sequences represented in the input initial tree.</span>
    <span class="n">names_of_seqs_in_tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t1</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_of_seqs_in_tree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify names of</span>
<span class="s2">    sequences in the tree.&quot;&quot;&quot;</span>

    <span class="c1"># Get list of essential taxa from file. </span>
    <span class="n">essential_taxa</span> <span class="o">=</span> <span class="n">get_essential_taxa_list</span><span class="p">(</span><span class="n">essential_taxa_file</span><span class="p">)</span>

    <span class="c1"># Copy alignment file to new path, and replace parentheses and commas and</span>
    <span class="c1"># colons with underscores in the sequence descriptions.</span>
    <span class="n">new_ali_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_0.nex&#39;</span><span class="p">)</span>
    <span class="n">problem_characters</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\(|\)|:|,&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">new_ali_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">ali_obj</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">ali_obj</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">problem_characters</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">seq</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ali_obj</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">new_ali_path</span><span class="p">)</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">new_ali_path</span> 

    <span class="c1"># Run ML search on model tree to get branch lengths and branch supports.</span>
    <span class="n">ml_tree_path</span> <span class="o">=</span>\
    <span class="n">run_tree_for_branch_lengths_and_supports_for_topology</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span>
                                                          <span class="n">alignment</span><span class="p">,</span>
                                                          <span class="n">subs_model</span><span class="p">,</span>
                                                          <span class="n">outputdir</span><span class="p">)</span>

    <span class="c1"># Define path to tree to use as a constraint tree for further analysis.</span>
    <span class="c1">#constraint_tree_fp_for_future = get_constraint_tree_fp(alignment)</span>
    <span class="n">constraint_tree_fp_for_future</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C_constraint_tree.newick&#39;</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">constraint_tree_fp_for_future</span><span class="p">)</span>

    <span class="c1"># Define output path for annotated tree image file.</span>
    <span class="n">annotated_tree_outpath</span> <span class="o">=</span>\
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_annotated_result.png&#39;</span><span class="p">)</span>

    <span class="c1"># Extract info about branch lengths and supports from tree, and write</span>
    <span class="c1"># annotated tree image file.</span>
    <span class="n">ml_tree_info_dict</span> <span class="o">=</span> <span class="n">get_ml_tree_info_dict</span><span class="p">(</span><span class="n">ml_tree_path</span><span class="p">,</span>
                                              <span class="n">type_seqs_dict</span><span class="p">,</span>
                                              <span class="n">annotated_tree_outpath</span><span class="p">)</span>


    <span class="c1"># ***Also, need to make it stop iterating if it can&#39;t do any more</span>
    <span class="c1"># modifications.</span>

    <span class="c1"># Parse input sequence file, and construct a list of sequence objects for</span>
    <span class="c1"># potential inclusion in the tree.</span>
    <span class="n">seqs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">file_with_seqs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">file_with_seqs</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
            <span class="n">seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;add_seqs&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No sequences provided for addition to the</span>
<span class="s2">        alignment.&quot;&quot;&quot;</span>

    <span class="c1"># Initiate lists of elements that will be modified.</span>
    <span class="n">positions_attempted_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seqs_attempted_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seqs_attempted_to_add</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Stores true if no modification can be made by the modify_alignment_in_x_way function.</span>

    <span class="c1"># Construct a tuple with all the relevant info from the original tree and</span>
    <span class="c1"># alignment.</span>
    <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                               <span class="c1">#tree, # ???</span>
                               <span class="n">constraint_tree_fp_for_future</span><span class="p">,</span>
                               <span class="n">alignment</span><span class="p">,</span>
                               <span class="n">positions_attempted_to_remove</span><span class="p">,</span>
                               <span class="n">subs_model</span><span class="p">,</span>
                               <span class="n">type_seqs_dict</span><span class="p">,</span>
                               <span class="n">ml_tree_info_dict</span><span class="p">,</span>
                               <span class="n">seqs</span><span class="p">,</span>
                               <span class="n">seqs_attempted_to_remove</span><span class="p">,</span>
                               <span class="n">seqs_attempted_to_add</span><span class="p">,</span>
                               <span class="n">essential_taxa</span><span class="p">,</span>
                               <span class="n">stop</span><span class="p">)</span>

    <span class="c1"># Handle mixed modification type if needed.</span>
    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;mixed&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Doesn&#39;t work yet. Add code for using mutltiple</span>
<span class="s2">        strategies...&quot;&quot;&quot;</span>

    <span class="c1"># Handle number of iterations.</span>
    <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">iterations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Specify a very large number by default so that it will run until no</span>
        <span class="c1"># further modifications result in improvements (it should break the</span>
        <span class="c1"># loop before 10000!).</span>
        <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_iterations</span> <span class="o">=</span> <span class="n">iterations</span>
    <span class="k">assert</span> <span class="n">max_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="c1"># Specify number of iterations that do not find improved support before the</span>
    <span class="c1"># loop gets broken.</span>
    <span class="n">max_failed_iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;remove_seqs&#39;</span><span class="p">:</span>
        <span class="n">max_failed_iterations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_of_seqs_in_tree</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;add_seqs&#39;</span><span class="p">:</span>
        <span class="n">max_failed_iterations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;remove_columns&#39;</span><span class="p">:</span>
        <span class="n">original_alignment_length</span> <span class="o">=</span> <span class="o">...</span>
        <span class="n">max_failed_iterations</span> <span class="o">=</span> <span class="n">original_alignment_length</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;mixed&#39;</span><span class="p">:</span>
        <span class="n">max_failed_iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">max_failed_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Iteratively modify the alignment and assess support in the tree.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Iteratively modifying and assessing alignments/trees...&#39;</span><span class="p">)</span>
    <span class="n">failed_iterations_tally</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_iterations</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Iteration &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="c1"># Modify alignment (and tree if necessary). There are various types of</span>
        <span class="c1"># modifications that could be done: 1) Remove a sequence, 2) Add a</span>
        <span class="c1"># sequence, 3) Remove positions/columns from the alignment, 4)</span>
        <span class="c1"># Re-align, 5) Reset the substitution model.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Modifying alignment (and tree) in X way, and assessing measures of branch support in new tree...&#39;</span><span class="p">)</span> 
        <span class="n">new_ali_tree_tuple</span> <span class="o">=</span>\
        <span class="n">modify_alignment_in_x_way</span><span class="p">(</span><span class="n">previous_ali_tree_tuple</span><span class="p">,</span> <span class="n">mod_type</span><span class="p">)</span>

        <span class="c1"># Stop if no modification could be made (the stop variable is set to</span>
        <span class="c1"># True).</span>
        <span class="k">if</span> <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">11</span><span class="p">]:</span>
            <span class="c1"># Stop iterations.</span>
            <span class="c1">#print(&#39;Stopping iterations because no further modification could be made.&#39;)</span>
            <span class="c1">#break</span>

            <span class="c1"># Or, reset the list of items to be modified and continue instead of</span>
            <span class="c1"># break.</span>
            
            <span class="c1"># Reset lists of elements that have been modified already.</span>
            <span class="n">positions_attempted_to_remove</span> <span class="o">=</span> <span class="p">[]</span> 
            <span class="n">seqs_attempted_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">seqs_attempted_to_add</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Apply changes to previous alignment/tree info tuple.</span>
            <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                       <span class="n">positions_attempted_to_remove</span><span class="p">,</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
                                       <span class="n">seqs_attempted_to_remove</span><span class="p">,</span>
                                       <span class="n">seqs_attempted_to_add</span><span class="p">,</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
                                       <span class="kc">False</span>
                                       <span class="p">)</span>
            <span class="c1"># Go to the next iteration so that nothing else is done before</span>
            <span class="c1"># trying another modification.</span>
            <span class="k">continue</span>



        <span class="c1"># Get measures of support for both trees.</span>
        <span class="n">prev_tree_measure</span> <span class="o">=</span> <span class="n">get_y_measure_of_support</span><span class="p">(</span><span class="n">previous_ali_tree_tuple</span><span class="p">)</span>
        <span class="n">new_tree_measure</span> <span class="o">=</span> <span class="n">get_y_measure_of_support</span><span class="p">(</span><span class="n">new_ali_tree_tuple</span><span class="p">)</span>

        <span class="c1"># Decide whether to use new alignment/tree based on various criteria.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Comparing measures of branch support in new tree to those of the previous tree...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_tree_measure</span> <span class="o">&lt;</span> <span class="n">prev_tree_measure</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">New tree is better.&#39;</span><span class="p">)</span>
            <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="n">new_ali_tree_tuple</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">New tree is not better.&#39;</span><span class="p">)</span>
            <span class="n">failed_iterations_tally</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Just update the lists of modifications that have already been</span>
            <span class="c1"># attempted.</span>
            <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                       <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
                                       <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
                                       <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
                                       <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
                                       <span class="p">)</span>

        <span class="c1"># Break the loop if the max number of failed iterations have occured.</span>
        <span class="k">if</span> <span class="n">failed_iterations_tally</span> <span class="o">&gt;=</span> <span class="n">max_failed_iterations</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Reached maximum number of failed iterations (modifications that</span>
<span class="s2">            do not result in a tree with better support).&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="c1"># Return path to main/final output file or directory.</span>
    <span class="k">return</span> <span class="n">outputdir</span></div>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Lael D. Barlow.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>