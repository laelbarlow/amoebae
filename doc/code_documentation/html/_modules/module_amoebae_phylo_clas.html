
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>module_amoebae_phylo_clas &#8212; amoebae 0.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for module_amoebae_phylo_clas</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright 2018 Lael D. Barlow</span>
<span class="c1"># </span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1"># </span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># </span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># </span>

<span class="sd">&quot;&quot;&quot;Contains functions for classifying sequences using existing phylogenetic models.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">settings</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">AlignIO</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">SeqIO</span>
<span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="k">import</span> <span class="n">IUPAC</span><span class="p">,</span> <span class="n">Gapped</span>
<span class="kn">from</span> <span class="nn">module_afa_to_nex</span> <span class="k">import</span> <span class="n">delete_extra_mesquite_lines</span><span class="p">,</span> <span class="n">afa_to_nex</span><span class="p">,</span> <span class="n">nex_to_afa</span><span class="p">,</span> <span class="n">nex_to_phylip</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="k">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="k">import</span> <span class="n">SeqRecord</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">from</span> <span class="nn">ete3</span> <span class="k">import</span> <span class="n">Tree</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">module_amoebae_trim_nex</span> <span class="k">import</span> <span class="n">trim_nex</span>
<span class="kn">from</span> <span class="nn">module_paralogue_counter</span> <span class="k">import</span> <span class="n">get_seq_obj_from_srch_res_csv_info</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">module_amoebae_column_header_lists</span>
<span class="kn">from</span> <span class="nn">module_amoebae</span> <span class="k">import</span> <span class="n">mask_nex2</span>
<span class="kn">from</span> <span class="nn">module_paralogue_counter</span> <span class="k">import</span> <span class="n">add_seq_to_alignment3</span><span class="p">,</span>\
<span class="n">modify_seq_descr_for_tree</span>
<span class="kn">from</span> <span class="nn">module_amoebae_name_replace</span> <span class="k">import</span> <span class="n">write_afa_with_code_names</span><span class="p">,</span>\
<span class="n">codenames_nex</span><span class="p">,</span> <span class="n">write_newick_tree_with_coded_names</span>
<span class="kn">from</span> <span class="nn">get_alt_topos</span> <span class="k">import</span> <span class="n">get_all_alt_topologies</span><span class="p">,</span> <span class="n">get_polytomy_for_treenode</span>
<span class="kn">from</span> <span class="nn">module_amoebae_constrain_mb</span> <span class="k">import</span> <span class="n">constrain_mb_with_tree</span>



<span class="c1"># Need to automatically align a given sequence to an existing alignment (high</span>
<span class="c1"># gap extension penalty to prevent wonky alignments?) and trim to get a final</span>
<span class="c1"># alignment. (there should be some checking to make sure the right domain was</span>
<span class="c1"># aligned, for example in the case of proteins that contain two homologous</span>
<span class="c1"># domains such as Qbc SNAREs).</span>



<div class="viewcode-block" id="add_seq_to_alignment"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.add_seq_to_alignment">[docs]</a><span class="k">def</span> <span class="nf">add_seq_to_alignment</span><span class="p">(</span><span class="n">inseqobj</span><span class="p">,</span> <span class="n">innexpath</span><span class="p">,</span> <span class="n">outdp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a sequence and adds it to a trimmed alignment for a backbone tree</span>
<span class="sd">    (which will be used to classify the sequence).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Write input sequence object to a file temporarily for input to MUSCLE.</span>
    <span class="n">fa_temp_1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdp</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">innexpath</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_temp1.fa&#39;</span><span class="p">)</span>
    <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">inseqobj</span><span class="p">,</span> <span class="n">fa_temp_1</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>

    <span class="c1"># Temporarily save a copy of the input alignment (nexus format) to fasta</span>
    <span class="c1"># file.</span>
    <span class="n">inali</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">innexpath</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
    <span class="n">fa_temp_2</span> <span class="o">=</span> <span class="n">fa_temp_1</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_temp1.fa&#39;</span><span class="p">,</span> <span class="s1">&#39;_temp2.afa&#39;</span><span class="p">)</span>
    <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">inali</span><span class="p">,</span> <span class="n">fa_temp_2</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)</span>

    <span class="c1"># Check that the input sequence does not have the same name as any of the</span>
    <span class="c1"># sequences in the input alignment.</span>
    <span class="c1"># Get list of sequence names from alignment.</span>
    <span class="n">existing_seq_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fa_temp_2</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
            <span class="n">extra_text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\.copy$&#39;</span><span class="p">)</span>
            <span class="n">rec_id_no_extra</span> <span class="o">=</span> <span class="n">extra_text</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">description</span><span class="p">)</span> 
            <span class="n">existing_seq_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec_id_no_extra</span><span class="p">)</span>
            <span class="c1">#existing_seq_names.append(record.id)</span>
    <span class="c1"># Get additional sequence name.</span>
    <span class="n">additional_seq_name</span> <span class="o">=</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">description</span>
    <span class="c1"># Determine if additional sequence name is in existing names.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">existing_seq_names</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">additional_seq_name</span><span class="p">,</span> <span class="s2">&quot;Error: Additional sequence with name</span><span class="se">\</span>
<span class="s2"> &quot;</span> <span class="o">+</span> <span class="n">additional_seq_name</span> <span class="o">+</span> <span class="s2">&quot; has the same name as a sequence in the</span><span class="se">\</span>
<span class="s2"> input alignment. Make sure that you give the input sequences unique names.&quot;</span>

    <span class="c1"># Align sequence to alignment (make sure that gap penalties are optimized).</span>
    <span class="n">fa_temp_3</span> <span class="o">=</span> <span class="n">fa_temp_2</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_temp2.afa&#39;</span><span class="p">,</span> <span class="s1">&#39;_temp3.afa&#39;</span><span class="p">)</span>
    <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s2">&quot;muscle&quot;</span><span class="p">,</span> <span class="s2">&quot;-profile&quot;</span><span class="p">,</span> <span class="s2">&quot;-in1&quot;</span><span class="p">,</span> <span class="n">fa_temp_2</span><span class="p">,</span> <span class="s2">&quot;-in2&quot;</span><span class="p">,</span>
        <span class="n">fa_temp_1</span><span class="p">,</span> <span class="s2">&quot;-out&quot;</span><span class="p">,</span> <span class="n">fa_temp_3</span><span class="p">])</span>

    <span class="c1"># Convert alignment to nexus format.</span>
    <span class="n">nex_out_1</span> <span class="o">=</span> <span class="n">fa_temp_3</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_plus_&#39;</span> <span class="o">+</span> <span class="n">inseqobj</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span>
    <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">,</span> <span class="n">nex_out_1</span><span class="p">)</span> 

    <span class="c1"># Mask alignment (mask out any positions in which the last sequence, the</span>
    <span class="c1"># additional sequence, has a residue but none of the other sequences have</span>
    <span class="c1"># residues at that position).</span>
    <span class="n">nex_out_2_mask</span> <span class="o">=</span> <span class="n">nex_out_1</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_mask.nex&#39;</span>
    <span class="n">mask_nex2</span><span class="p">(</span><span class="n">nex_out_1</span><span class="p">,</span> <span class="n">nex_out_2_mask</span><span class="p">)</span> 

    <span class="c1"># Trim alignment.</span>
    <span class="n">nex_out_3_trim</span> <span class="o">=</span> <span class="n">nex_out_2_mask</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_trim.nex&#39;</span>
    <span class="n">trim_nex</span><span class="p">(</span><span class="n">nex_out_2_mask</span><span class="p">,</span> <span class="n">nex_out_3_trim</span><span class="p">)</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_1</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_2</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fa_temp_3</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">nex_out_1</span><span class="p">)</span>

    <span class="c1"># Return file path of trimmed nexus file for downstream processes.</span>
    <span class="k">return</span> <span class="n">nex_out_3_trim</span></div>
    

<div class="viewcode-block" id="code_names_in_ali"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.code_names_in_ali">[docs]</a><span class="k">def</span> <span class="nf">code_names_in_ali</span><span class="p">(</span><span class="n">indp</span><span class="p">,</span> <span class="n">inalifp</span><span class="p">,</span> <span class="n">outalifp</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Code names using name_replace.pl.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Code for doing this with the old name_replace.pl script:</span>
    <span class="c1">#subprocess.call([&#39;name_replace.pl&#39;, &#39;-f&#39;, inalifp, outalifp,\</span>
    <span class="c1">#outtablefp], cwd=indp)</span>
    <span class="c1">#subprocess.call([&#39;name_replace.pl&#39;, &#39;-f&#39;, inalifp, outalifp,\</span>
    <span class="c1">#outtablefp])</span>

    <span class="c1"># Call function from module_amoebae_name_replace.py.</span>
    <span class="n">write_afa_with_code_names</span><span class="p">(</span><span class="n">inalifp</span><span class="p">,</span> <span class="n">outalifp</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_conversion_dict"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.get_conversion_dict">[docs]</a><span class="k">def</span> <span class="nf">get_conversion_dict</span><span class="p">(</span><span class="n">tablefile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a Name_Replace-style taxon name conversion table file, and return a</span>
<span class="sd">    dictionary for converting between coded names and long names, with long</span>
<span class="sd">    names as keys and codes as values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conv_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tablefile</span><span class="p">)</span> <span class="k">as</span> <span class="n">tablefh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tablefh</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ZZ&#39;</span><span class="p">):</span>
                <span class="n">cur_code</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conv_dict</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cur_code</span>
    <span class="k">return</span> <span class="n">conv_dict</span></div>


<div class="viewcode-block" id="quote_tree"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.quote_tree">[docs]</a><span class="k">def</span> <span class="nf">quote_tree</span><span class="p">(</span><span class="n">intree</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add quotation marks around long names in tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">outtree</span> <span class="o">=</span> <span class="n">intree</span>
    <span class="n">conv_dict</span> <span class="o">=</span> <span class="n">get_conversion_dict</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">conv_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">outtree</span> <span class="o">=</span> <span class="n">outtree</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#for value in conv_dict.values():</span>
    <span class="c1">#    outtree = outtree.replace(value, &quot;\&quot;&quot; + key + &quot;\&quot;&quot;)</span>

    <span class="k">return</span> <span class="n">outtree</span></div>


<div class="viewcode-block" id="code_tree"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.code_tree">[docs]</a><span class="k">def</span> <span class="nf">code_tree</span><span class="p">(</span><span class="n">intreefp</span><span class="p">,</span> <span class="n">outtreefp</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Code names in a tree, given a conversion table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Construct a name conversion dict from input table file.</span>
    <span class="n">conv_dict</span> <span class="o">=</span> <span class="n">get_conversion_dict</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

    <span class="c1"># Parse input tree file.</span>
    <span class="n">intree</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">intreefp</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">infh</span><span class="o">.</span><span class="n">read</span><span class="p">():</span> 
            <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#print(&#39;\n&#39;)</span>
    <span class="c1">#print(&#39;intreefp&#39;)</span>
    <span class="c1">#print(intreefp)</span>
    <span class="c1">#print(&#39;quoted_node_names_var&#39;)</span>
    <span class="c1">#print(quoted_node_names_var)</span>
    <span class="n">intree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">intreefp</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="n">quoted_node_names_var</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">intree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1">## Check that the number of keys in the conversion dict is the same as the</span>
    <span class="c1">## number of leaf nodes in the tree.</span>
    <span class="c1">#assert len(conv_dict.keys()) == len(intree.get_leaves()), &quot;&quot;&quot;Different</span>
    <span class="c1">#number of code names than leaf nodes in tree.&quot;&quot;&quot;</span>

    <span class="c1">## Check that each of the node names is a key in the dictionary.</span>
    <span class="c1">#for node in intree.iter_leaves():</span>
    <span class="c1">#    assert node.name in conv_dict.keys(), &quot;&quot;&quot;Node name not in name</span>
    <span class="c1">#    conversion dictionary: %s&quot;&quot;&quot; % node.name</span>

    <span class="c1"># Convert node names in tree.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">intree</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
        <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">conv_dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">)]</span>

    <span class="c1"># Write modified tree to output file.</span>
    <span class="n">intree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="n">outtreefp</span><span class="p">)</span></div>


<div class="viewcode-block" id="uncode_tree"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.uncode_tree">[docs]</a><span class="k">def</span> <span class="nf">uncode_tree</span><span class="p">(</span><span class="n">intreefp</span><span class="p">,</span> <span class="n">outtreefp</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Code names in a tree file, given a conversion table. Without parsing</span>
<span class="sd">    with ete3.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Construct a name conversion dict from input table file.</span>
    <span class="n">conv_dict</span> <span class="o">=</span> <span class="n">get_conversion_dict</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">intreefp</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
            <span class="n">new_text</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">for</span> <span class="n">longname</span> <span class="ow">in</span> <span class="n">conv_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">new_text</span> <span class="o">=</span> <span class="n">new_text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">conv_dict</span><span class="p">[</span><span class="n">longname</span><span class="p">],</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">+</span>\
                        <span class="n">longname</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">new_text</span><span class="p">)</span></div>


<div class="viewcode-block" id="uncode_tree_obj"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.uncode_tree_obj">[docs]</a><span class="k">def</span> <span class="nf">uncode_tree_obj</span><span class="p">(</span><span class="n">intreeobj</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uncode names in a tree, given a conversion table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Construct a name conversion dict from input table file.</span>
    <span class="n">conv_dict</span> <span class="o">=</span> <span class="n">get_conversion_dict</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

    <span class="c1"># Convert node names in tree.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">intreeobj</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
        <span class="n">uncoded_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">conv_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">conv_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">uncoded_name</span> <span class="o">=</span> <span class="n">key</span>
                <span class="k">break</span>

        <span class="c1"># Check that an uncoded name was found.</span>
        <span class="k">assert</span> <span class="n">uncoded_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># Change name of node to uncoded name.</span>
        <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">uncoded_name</span></div>


<div class="viewcode-block" id="classify_seq_with_constrained_tree"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.classify_seq_with_constrained_tree">[docs]</a><span class="k">def</span> <span class="nf">classify_seq_with_constrained_tree</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span> <span class="n">type_seqs</span><span class="p">,</span> <span class="n">fasta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Classify sequences in a given fasta file using a given backbone tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define timestamp.</span>
    <span class="n">cur_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y_%m_</span><span class="si">%d</span><span class="s2">_%H_%M_%S&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Timestamp: &#39;</span> <span class="o">+</span> <span class="n">cur_time</span><span class="p">)</span>
    
    <span class="c1"># Make output directory.</span>
    <span class="n">outdirpath1</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_classify_seq_&#39;</span> <span class="o">+</span> <span class="n">cur_time</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">)</span>
    
    <span class="c1">## Take a specific approach, depending on the options specified at runtime.</span>
    <span class="c1">#</span>
    <span class="c1">## If bootstrapping option not specified, then use default topology-testing</span>
    <span class="c1">## approach.</span>
    <span class="c1">#if not args.boot:</span>
    <span class="c1">#</span>
    <span class="c1">#    # Call function for doing default analysis.</span>
    
    <span class="c1"># Write initial summary csv file.</span>
    <span class="n">summary_csv_fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="s1">&#39;0_&#39;</span> <span class="o">+</span>\
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>\
        <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_Summary.csv&#39;</span><span class="p">)</span>
    <span class="n">summary_header_line</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;Original alignment file&#39;</span><span class="p">,</span> <span class="c1">#0</span>
                                    <span class="s1">&#39;Original tree file&#39;</span><span class="p">,</span> <span class="c1">#1</span>
                                    <span class="s1">&#39;Substitution model&#39;</span><span class="p">,</span> <span class="c1">#2</span>
                                    <span class="s1">&#39;Sequence added to tree&#39;</span><span class="p">,</span> <span class="c1">#3</span>
                                    <span class="s1">&#39;Hypothesis (tree/clade) number&#39;</span><span class="p">,</span> <span class="c1">#4</span>
                                    <span class="s1">&#39;Type sequence of clade the additional sequence was constrained into&#39;</span><span class="p">,</span> <span class="c1">#5</span>
                                    <span class="s1">&#39;Clade name&#39;</span><span class="p">,</span> <span class="c1">#6</span>
                                    <span class="s1">&#39;Log-likelihood of ML tree&#39;</span><span class="p">,</span>  <span class="c1">#7</span>
                                    <span class="s1">&#39;bp-RELL: bootstrap proportion using RELL method (Kishino et al. 1990)&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                    <span class="s1">&#39;p-KH: p-value of one sided Kishino-Hasegawa test (1989)&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                    <span class="s1">&#39;p-SH: p-value of Shimodaira-Hasegawa test (2000)&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                    <span class="s1">&#39;c-ELW: Expected Likelihood Weight (Strimmer &amp; Rambaut 2002)&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                    <span class="s1">&#39;&quot;p-AU: p-value of approximately unbiased (AU) test (Shimodaira, 2002)&quot;&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                    <span class="s1">&#39;Accept (+) or reject (-) hypothesis based on consensus of topology tests&#39;</span><span class="p">,</span>  <span class="c1">#9</span>
                                    <span class="s1">&#39;Masked alignment file&#39;</span><span class="p">,</span> <span class="c1">#10</span>
                                    <span class="s1">&#39;Sequence name conversion table file&#39;</span><span class="p">,</span> <span class="c1">#11</span>
                                    <span class="s1">&#39;Trimmed input alignment file&#39;</span><span class="p">,</span> <span class="c1">#12</span>
                                    <span class="s1">&#39;Constraint tree file&#39;</span><span class="p">,</span> <span class="c1">#13</span>
                                    <span class="s1">&#39;Starting tree file&#39;</span><span class="p">,</span> <span class="c1">#14</span>
                                    <span class="s1">&#39;ML tree file&#39;</span><span class="p">,</span> <span class="c1">#15</span>
                                    <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                    <span class="p">])</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">summary_csv_fp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">summary_header_line</span><span class="p">)</span>

    <span class="c1"># Align sequences to alignment and trim.</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">fasta</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
        <span class="n">add_seq_to_alignment</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">outdirpath1</span><span class="p">)</span>
        
    <span class="c1"># Take tree topology and alignment (regular names), convert names in alignment</span>
    <span class="c1"># generating a conversion table similar to for name_replace.pl, then use that</span>
    <span class="c1"># conversion table to code the names in the tree topology as well.</span>
    <span class="n">ali_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ali</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="s1">&#39;*trim.nex&#39;</span><span class="p">)):</span>
        <span class="n">ali_num</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Convert nexus alignment to afa.</span>
        <span class="n">temp_fa_1</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_temp1.afa&#39;</span>
        <span class="n">nex_to_afa</span><span class="p">(</span><span class="n">ali</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">)</span> 
    
        <span class="c1"># Code names in alignment.</span>
        <span class="n">outalifp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.afa&#39;</span>
        <span class="n">outtablefp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.table&#39;</span>
        <span class="n">code_names_in_ali</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">,</span> <span class="n">outalifp</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span> 
    
        <span class="c1"># Convert alignment back to nexus.</span>
        <span class="n">outalifpnex</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.nex&#39;</span>
        <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">outalifp</span><span class="p">,</span> <span class="n">outalifpnex</span><span class="p">)</span>
    
        <span class="c1"># Delete temporary files.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_fa_1</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifp</span><span class="p">)</span>
    
        <span class="c1"># Only do the following steps once for all the alignments, because all the</span>
        <span class="c1"># constrained topology analyses will use the same constraint trees.</span>
        <span class="k">if</span> <span class="n">ali_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    
            <span class="c1"># Put quotation marks around names in constraint tree. # SEPARATE</span>
            <span class="n">outtreefp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.constraint_tree0.Q.newick&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">as</span> <span class="n">intreefh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">intreefh</span><span class="p">:</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">quote_tree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">))</span>
    
    
            <span class="c1"># Make topology constraint trees.   </span>
    
            <span class="c1"># Parse backbone topology and root on a clade rather than having the root</span>
            <span class="c1"># inside a clade.</span>
    
            <span class="c1">######################</span>
            <span class="c1"># Parse tree using ete3.</span>
            <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
            <span class="c1"># Define name for tree without branch lengths.</span>
            <span class="n">simple_tree</span> <span class="o">=</span> <span class="n">outtreefp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_TEMP2&#39;</span> 
    
            <span class="c1"># Write simple tree to a new file </span>
            <span class="n">t1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="n">simple_tree</span><span class="p">)</span>
    
            <span class="c1"># Parse simple tree.</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">simple_tree</span><span class="p">)</span>
    
            <span class="c1"># Print simple tree.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input tree:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
    
            <span class="c1">## Get node for a key clade. </span>
            <span class="c1">## Or, just require to root it before inputting (figtree can export</span>
            <span class="c1">## re-rooted newick)?????</span>
            <span class="c1">#print(&quot;\nPlease define an arbitrary clade of interest for rooting the tree topology\n&quot;)</span>
            <span class="c1">#clade_member_1 = input(&#39;Clade member 1: &#39;)</span>
            <span class="c1">#clade_member_2 = input(&#39;Clade member 2: &#39;)</span>
            <span class="c1">#ancestor1 = t2.get_common_ancestor(clade_member_1, clade_member_2)</span>
            <span class="c1">##print(ancestor1)</span>
    
            <span class="c1">## Re-root tree on a clade (as a polytomy) rather than inside a clade, so</span>
            <span class="c1">## that key branches can be more easily identified.</span>
            <span class="c1">#t2.set_outgroup(ancestor1)</span>
    
            <span class="c1">######################</span>
    
    
            <span class="c1"># Get to topologies sorted out...</span>
    
            <span class="c1"># Get constraint topologies for each clade of interest to test</span>
            <span class="c1"># alternative topology hypotheses.</span>
    
            <span class="c1"># Get list of &quot;type&quot; sequences from input.</span>
            <span class="n">type_seq_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">):</span>
                <span class="n">type_seq_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    
            <span class="c1"># For each &quot;type&quot; sequence, traverse all nodes and find the node with</span>
            <span class="c1"># the largest number of child nodes that are leaf (terminal) nodes,</span>
            <span class="c1"># containing the &quot;type&quot; sequence of interest, but not containing any of</span>
            <span class="c1"># the other &quot;type&quot; sequences.</span>
            <span class="n">ts_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                <span class="n">ts_num</span> <span class="o">+=</span> <span class="mi">1</span>
    
                <span class="k">if</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="n">ts</span>
                    <span class="c1"># Root on another &quot;type&quot; sequence for the first type sequence in</span>
                    <span class="c1"># the list to get whole clade, then root the tree on the ancestor</span>
                    <span class="c1"># node of that first clade.</span>
    
                    <span class="c1"># Get a node name for a node corresponding to a different</span>
                    <span class="c1"># &quot;type&quot; sequence.</span>
                    <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ts</span><span class="p">:</span>
                            <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="k">break</span>
    
                    <span class="c1"># Get node corresponding to a different &quot;type&quot; sequence.</span>
                    <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_type_seq_node_name</span><span class="p">:</span>
                            <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                            <span class="k">break</span>
    
                    <span class="c1"># Root on the other &quot;type&quot; sequence node.</span>
                    <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">other_type_seq_node</span><span class="p">)</span>
    
                    <span class="c1">#print(&#39;\n\n\nTree rooted on a type sequence other than the first type sequence.&#39;)</span>
                    <span class="c1">#print(t2)</span>
    
                <span class="k">elif</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># Root on the first &quot;type&quot; sequence node for all subsequent</span>
                    <span class="c1"># clades.</span>
                    <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                        <span class="n">leaf_list</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_type_seq_node_name</span><span class="p">:</span>
                                <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                                <span class="k">break</span>
                    <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">first_type_seq_node</span><span class="p">)</span>
                    <span class="c1">#print(&#39;\n\n\nTree re-rooted on first type sequence:&#39;)</span>
                    <span class="c1">#print(t2)</span>
    
    
                <span class="c1"># Make a copy of the tree topology to work with for each run</span>
                <span class="c1"># through this loop.</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
                <span class="c1"># Make a list of nodes that contain type seq, but not any others. #</span>
                <span class="c1"># SEPARATE</span>
                <span class="n">nodes_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="c1"># Search in nodes that contain the type sequence.</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts</span><span class="p">):</span>
                        <span class="c1"># Search in nodes that don&#39;t contain other type sequences.</span>
                        <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">for</span> <span class="n">ts2</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">ts2</span> <span class="o">==</span> <span class="n">ts</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts2</span><span class="p">):</span>
                                    <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_other_type_seqs</span><span class="p">:</span>
                            <span class="c1"># Add nodes of interest to list.</span>
                            <span class="n">nodes_of_interest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
                <span class="c1"># find the node with the most child leaf nodes.</span>
                <span class="c1">#node_num = 0</span>
                <span class="c1">#for node in nodes_of_interest:</span>
                <span class="c1">#    node_num += 1 </span>
                <span class="c1">#    print(&#39;Node &#39; + str(node_num) + &#39; Number of leaves:  &#39; + str(len(node.get_leaves())))</span>
                <span class="c1">#    print(node)</span>
                <span class="n">node_w_most_leaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                        <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
                <span class="c1">#print(&#39;\n\nClade defined by sequence &#39; + ts + &#39;:&#39;)</span>
                <span class="c1">#print(node_w_most_leaves)</span>
    
    
                <span class="c1"># Copy tree and remove node/clades in constraint trees and replace with</span>
                <span class="c1"># polytomies composed of the same sequences.</span>
                <span class="n">starting_tree</span> <span class="o">=</span> <span class="n">t3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
                <span class="n">node_of_interest</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">starting_tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                        <span class="n">node_of_interest</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
    
                <span class="c1"># Add node for additional sequence as most basal taxon.</span>
                <span class="n">name_for_additional_node</span> <span class="o">=</span> <span class="s1">&#39;AddSeq&#39;</span>
                <span class="n">node_of_interest</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name_for_additional_node</span><span class="p">)</span>
                <span class="n">node_of_interest</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="s1">&#39;AddSeq&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;node with additional sequence:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">node_of_interest</span><span class="p">)</span>
    
                <span class="c1"># Unroot tree, because ML trees are all unrooted.</span>
                <span class="n">starting_tree</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>
    
                <span class="c1"># Write modified tree.</span>
                <span class="n">outtreename1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span>
                        <span class="s1">&#39;clade_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_starting_tree_def_seq_&#39;</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>\
                        <span class="o">+</span> <span class="s1">&#39;.tre&#39;</span><span class="p">)</span>
                <span class="n">starting_tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">outtreename1</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
    
    
                <span class="c1"># Copy tree and remove node/clades in constraint trees and replace with</span>
                <span class="c1"># polytomies composed of the same sequences.</span>
                <span class="n">clade_constr_tree</span> <span class="o">=</span> <span class="n">starting_tree</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
                <span class="c1"># Remove internal child nodes in the clade so that it becomes a</span>
                <span class="c1"># polytomy. # SEPARATE</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">clade_constr_tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                        <span class="n">nodes_to_delete</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">():</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">cn</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                                <span class="n">nodes_to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">nodes_to_delete</span><span class="p">:</span>
                            <span class="n">cn</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
    
                <span class="c1"># Show modified node.</span>
                <span class="c1">#print(&#39;\nClade as polytomy:&#39;)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">clade_constr_tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                        <span class="c1">#print(node)</span>
                        <span class="k">pass</span>
    
                <span class="c1"># Unroot tree, because ML trees are all unrooted.</span>
                <span class="n">clade_constr_tree</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>
                
                <span class="c1"># Write modified tree.</span>
                <span class="n">outtreename2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span>
                        <span class="s1">&#39;clade_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_constraint_tree_def_seq_&#39;</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>\
                        <span class="o">+</span> <span class="s1">&#39;.tre&#39;</span><span class="p">)</span>
                <span class="c1">#print(&#39;outtreename:&#39;)</span>
                <span class="c1">#print(outtreename)</span>
                <span class="c1">#with open(outtreename, &#39;w&#39;) as outfh:</span>
                <span class="n">clade_constr_tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">outtreename2</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
    
            <span class="c1"># Remove temporary files.</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">simple_tree</span><span class="p">)</span>
    
    
    <span class="c1"># Loop through alignments and make copies of the starting trees and constraint</span>
    <span class="c1"># trees with renamed &quot;AddSeq&quot; taxon, as well as copies with coded sequence</span>
    <span class="c1"># names for input to IQtree.</span>
    <span class="n">ali_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ali</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="s1">&#39;*trim.C.nex&#39;</span><span class="p">)):</span>
        <span class="n">ali_num</span> <span class="o">+=</span> <span class="mi">1</span>
    
        <span class="c1"># Remove unnecessary uncoded trim file.</span>
        <span class="n">trim_file_to_remove</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">trim_file_to_remove</span><span class="p">)</span>
    
        <span class="c1"># Define corresponding conversion table file path.</span>
        <span class="n">tablefp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.table&#39;</span>
    
        <span class="c1"># Get name of additional sequence from table.</span>
        <span class="n">additional_seq_orig_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tablefp</span><span class="p">)</span> <span class="k">as</span> <span class="n">tablefh</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">tablefh</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="n">additional_seq_orig_name</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    
        <span class="c1"># Loop through trees, parse them, change the &quot;AddSeq&quot; node name to the name</span>
        <span class="c1"># of the additional sequence for this particular alignment, then write to a</span>
        <span class="c1"># file. # SEPARATE</span>
        <span class="n">constraint_tree_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">starting_tree_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">ali</span><span class="p">),</span> <span class="s1">&#39;clade_*.tre&#39;</span><span class="p">))):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
            <span class="c1"># Parse tree.</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tf</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Change node name in tree.</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tx</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;AddSeq&#39;</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">additional_seq_orig_name</span>
                    <span class="k">break</span>
            <span class="c1"># Write modified tree.</span>
            <span class="n">outtreename</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
            <span class="n">tx</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">outtreename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
            <span class="c1"># Make copy of tree file with coded names.</span>
            <span class="n">outtreename2</span> <span class="o">=</span> <span class="n">outtreename</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.tre&#39;</span>
            <span class="n">code_tree</span><span class="p">(</span><span class="n">outtreename</span><span class="p">,</span> <span class="n">outtreename2</span><span class="p">,</span> <span class="n">tablefp</span><span class="p">)</span>
            <span class="c1"># Remove copy with uncoded names.</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outtreename</span><span class="p">)</span>
            <span class="c1"># Add file paths to lists as appropriate.</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;constraint&#39;</span><span class="p">:</span>
                <span class="n">constraint_tree_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outtreename2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;starting&#39;</span><span class="p">:</span>
                <span class="n">starting_tree_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outtreename2</span><span class="p">)</span>
    
    
        <span class="c1"># Make a copy of the alignment in phylip format for input to IQtree.</span>
        <span class="n">phy_out</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.phy&#39;</span>
        <span class="n">nex_to_phylip</span><span class="p">(</span><span class="n">ali</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">)</span>
    
        <span class="c1"># Remove nexus format version of alignment, because it is redundant with</span>
        <span class="c1"># the phylip version.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ali</span><span class="p">)</span>
    
        <span class="c1"># Print to see whether the tree files are in the right order.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ctf</span><span class="p">,</span> <span class="n">stf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">constraint_tree_list</span><span class="p">,</span> <span class="n">starting_tree_list</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ctf</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">stf</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
    
        <span class="c1"># Do phylogenetic analysis. # SEPARATE</span>
        <span class="n">outtree_files_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ctf</span><span class="p">,</span> <span class="n">stf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">constraint_tree_list</span><span class="p">,</span> <span class="n">starting_tree_list</span><span class="p">):</span>
            <span class="c1"># Make subdir for output.</span>
            <span class="n">subdirp</span> <span class="o">=</span> <span class="n">ctf</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_IQ-tree_output&#39;</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">)</span>
    
            <span class="c1"># Use IQtree to do an ML search</span>
            <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirp</span><span class="p">,</span> <span class="s1">&#39;iqtree&#39;</span><span class="p">)</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span> <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span>
                <span class="n">ctf</span><span class="p">,</span> <span class="s1">&#39;-t&#39;</span><span class="p">,</span> <span class="n">stf</span><span class="p">,</span> <span class="s1">&#39;-pre&#39;</span><span class="p">,</span> <span class="n">output_file_prefix</span><span class="p">,</span> <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">])</span>
            <span class="c1"># Add output tree file path to list.</span>
            <span class="n">tree_file_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.treefile&#39;</span>
            <span class="n">outtree_files_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">)</span>
            <span class="c1"># Check that the output file was actually produced.</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">)</span>
    
        <span class="c1"># Do topology tests using yielded trees.</span>
    
        <span class="c1"># Make output directory for topology test analysis.</span>
        <span class="n">topo_test_subdirp</span> <span class="o">=</span> <span class="n">phy_out</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topology_tests&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">)</span>
        <span class="n">concat_tree_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">,</span> <span class="s1">&#39;concat_trees.tre&#39;</span><span class="p">)</span>
        <span class="n">concat_tree_name_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">,</span> <span class="s1">&#39;concat_tree_names.txt&#39;</span><span class="p">)</span>
        <span class="n">f_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">alt_tree_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">outtree_files_list</span><span class="p">:</span>
            <span class="n">f_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">alt_tree_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">concat_tree_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o1</span><span class="p">,</span>\
            <span class="nb">open</span><span class="p">(</span><span class="n">concat_tree_name_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o2</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
                    <span class="n">o1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">o2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="n">f</span><span class="p">)</span>
    
        <span class="c1"># Use IQ-tree to perform topology tests.</span>
        <span class="n">topo_test_output_prefix</span> <span class="o">=</span> <span class="n">concat_tree_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topo_test&#39;</span> 
        <span class="n">topo_test_output_fp</span> <span class="o">=</span> <span class="n">concat_tree_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topo_test.iqtree&#39;</span> 
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span> <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span> <span class="s1">&#39;-n&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;-z&#39;</span><span class="p">,</span> <span class="n">concat_tree_file</span><span class="p">,</span> <span class="s1">&#39;-zb&#39;</span><span class="p">,</span> <span class="s1">&#39;10000&#39;</span><span class="p">,</span> <span class="s1">&#39;-au&#39;</span><span class="p">,</span> <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;-pre&#39;</span><span class="p">,</span>
            <span class="n">topo_test_output_prefix</span><span class="p">])</span>
    
        <span class="c1"># Parse IQ-tree output to get results of topology test. # SEPARATE</span>
        <span class="n">data_line</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+ +-\d+\.\d+ +\d+\.\d+ +&#39;</span><span class="p">)</span>
        <span class="n">space_char</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39; +&#39;</span><span class="p">)</span>
        <span class="n">topo_test_res_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">topo_test_output_fp</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_line</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                    <span class="c1"># Parse info from line in IQ-tree output file.</span>
                    <span class="n">parsed_tree_info_list</span> <span class="o">=</span> <span class="n">space_char</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="n">tree_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">original_tree_fp</span> <span class="o">=</span> <span class="n">alt_tree_files</span><span class="p">[</span><span class="n">tree_num</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">logL</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">bp_RELL</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="n">p_KH</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                    <span class="n">p_SH</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
                    <span class="n">c_ELW</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span>
                    <span class="n">p_AU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span>
                    <span class="c1">#accept_reject = parsed_tree_info_list[12]</span>
                    <span class="c1"># Add info to dict.</span>
                    <span class="n">topo_test_res_dict</span><span class="p">[</span><span class="n">tree_num</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_tree_fp</span><span class="p">,</span> <span class="n">logL</span><span class="p">,</span>\
                            <span class="n">bp_RELL</span><span class="p">,</span> <span class="n">p_KH</span><span class="p">,</span> <span class="n">p_SH</span><span class="p">,</span> <span class="n">c_ELW</span><span class="p">,</span> <span class="n">p_AU</span><span class="p">)</span>
    
        <span class="c1"># Write info to summary spreadsheet file. # SEPARATE</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">summary_csv_fp</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">num_keys</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">topo_test_res_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">key_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topo_test_res_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                    <span class="n">topo_test_res_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">key_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">info_tuple</span> <span class="o">=</span> <span class="n">topo_test_res_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="c1"># Assemble info to write to spreadsheet.</span>
                <span class="n">relative_tree_path</span> <span class="o">=</span> <span class="n">info_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">orig_align_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
                <span class="n">orig_tree_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">logL</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">bp_RELL</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">p_KH</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">p_SH</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
                <span class="n">c_ELW</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                <span class="n">p_AU</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
    
                <span class="c1"># Apply a consensus approach to determine whether to accept or</span>
                <span class="c1"># reject topologies.</span>
                <span class="n">accept_reject</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
                <span class="n">consensus_num</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">bp_RELL</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                    <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">p_KH</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                    <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">p_SH</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                    <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">c_ELW</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                    <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">p_AU</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                    <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">consensus_num</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">accept_reject</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
    
                <span class="n">hypothesis_num</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">key_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of &#39;</span> <span class="o">+</span> <span class="n">num_keys</span>
                <span class="n">relative_table_path</span> <span class="o">=</span> <span class="n">tablefp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">tablefp</span><span class="p">)),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">type_seq_name</span> <span class="o">=</span>\
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_def_seq_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.C_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
                <span class="n">masked_ali_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span><span class="s1">&#39;*mask.C.nex&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    
                <span class="c1"># Write info line to spreadsheet.</span>
                <span class="n">info_line</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">orig_align_file</span><span class="p">,</span> <span class="c1">#0</span>
                                      <span class="n">orig_tree_file</span><span class="p">,</span> <span class="c1">#1</span>
                                      <span class="n">subs_model</span><span class="p">,</span> <span class="c1">#2</span>
                                      <span class="n">additional_seq_orig_name</span><span class="p">,</span> <span class="c1">#3</span>
                                      <span class="n">hypothesis_num</span><span class="p">,</span> <span class="c1">#4</span>
                                      <span class="n">type_seq_name</span><span class="p">,</span> <span class="c1">#5</span>
                                      <span class="s1">&#39;Clade ?&#39;</span><span class="p">,</span> <span class="c1">#6</span>
                                      <span class="n">logL</span><span class="p">,</span>  <span class="c1">#7</span>
                                      <span class="n">bp_RELL</span><span class="p">,</span> <span class="c1">#8</span>
                                      <span class="n">p_KH</span><span class="p">,</span> <span class="c1">#8A</span>
                                      <span class="n">p_SH</span><span class="p">,</span> <span class="c1">#8B</span>
                                      <span class="n">c_ELW</span><span class="p">,</span> <span class="c1">#8C</span>
                                      <span class="n">p_AU</span><span class="p">,</span> <span class="c1">#8D</span>
                                      <span class="n">accept_reject</span><span class="p">,</span>
                                      <span class="n">masked_ali_file</span><span class="p">,</span> <span class="c1">#10</span>
                                      <span class="n">relative_table_path</span><span class="p">,</span> <span class="c1">#11</span>
                                      <span class="s1">&#39;Trimmed input alignment file&#39;</span><span class="p">,</span> <span class="c1">#12</span>
                                      <span class="s1">&#39;Constraint tree file&#39;</span><span class="p">,</span> <span class="c1">#13</span>
                                      <span class="s1">&#39;Starting tree file&#39;</span><span class="p">,</span> <span class="c1">#14</span>
                                      <span class="n">relative_tree_path</span><span class="p">,</span> <span class="c1">#15</span>
                                      <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                      <span class="p">])</span>
                <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">info_line</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_phylo_class_csv"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.get_phylo_class_csv">[docs]</a><span class="k">def</span> <span class="nf">get_phylo_class_csv</span><span class="p">(</span><span class="n">outdirpath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a phylo_class output directory, return the path to the full</span>
<span class="sd">    summary file contained in the directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#summary_csv_fp = os.path.join(outdirpath1, &#39;0_&#39; +\</span>
    <span class="c1">#        os.path.basename(file_with_seqs).rsplit(&#39;.&#39;,\</span>
    <span class="c1">#    1)[0] + &#39;_Summary.csv&#39;)</span>
    <span class="n">summary_csv_fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath</span><span class="p">,</span> <span class="s1">&#39;0_full_summary.csv&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">summary_csv_fp</span></div>


<div class="viewcode-block" id="classify_seq_with_constrained_tree2"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.classify_seq_with_constrained_tree2">[docs]</a><span class="k">def</span> <span class="nf">classify_seq_with_constrained_tree2</span><span class="p">(</span><span class="n">file_with_seqs</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">subseq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">abbrev</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Classify sequences in a given fasta file using a given backbone tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Start time.</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># Define timestamp.</span>
    <span class="n">cur_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">%H%M%S&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Timestamp: &#39;</span> <span class="o">+</span> <span class="n">cur_time</span><span class="p">)</span>
    
    <span class="c1"># Make output directory.</span>
    <span class="c1">#outdirpath1 = alignment.rsplit(&#39;.&#39;, 1)[0] + &#39;_classify_seq_&#39; + cur_time</span>
    <span class="n">outdirpath1</span> <span class="o">=</span> <span class="n">file_with_seqs</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_classify_seq_&#39;</span> <span class="o">+</span> <span class="n">cur_time</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">)</span>
    
    <span class="c1">## Take a specific approach, depending on the options specified at runtime.</span>
    <span class="c1">#</span>
    <span class="c1">## If bootstrapping option not specified, then use default topology-testing</span>
    <span class="c1">## approach.</span>
    <span class="c1">#if not args.boot:</span>
    <span class="c1">#</span>
    <span class="c1">#    # Call function for doing default analysis.</span>
    
    <span class="c1"># Write initial summary csv file.</span>
    <span class="n">summary_csv_fp</span> <span class="o">=</span> <span class="n">get_phylo_class_csv</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">)</span> 

    <span class="c1"># Define summary header line string.</span>
    <span class="n">summary_header_line</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">place</span><span class="p">:</span>
        <span class="n">summary_header_line</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;Model/backbone tree name&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;Original alignment file&#39;</span><span class="p">,</span> <span class="c1">#0</span>
                                        <span class="s1">&#39;Original tree file&#39;</span><span class="p">,</span> <span class="c1">#1</span>
                                        <span class="s1">&#39;Substitution model&#39;</span><span class="p">,</span> <span class="c1">#2</span>
                                        <span class="s1">&#39;Sequence added to tree&#39;</span><span class="p">,</span> <span class="c1">#3</span>
                                        <span class="s1">&#39;Hypothesis (tree/clade) number&#39;</span><span class="p">,</span> <span class="c1">#4</span>
                                        <span class="s1">&#39;Type sequence of clade the additional sequence was constrained into&#39;</span><span class="p">,</span> <span class="c1">#5</span>
                                        <span class="s1">&#39;Clade name&#39;</span><span class="p">,</span> <span class="c1">#6</span>
                                        <span class="s1">&#39;Log-likelihood of ML tree&#39;</span><span class="p">,</span>  <span class="c1">#7</span>
                                        <span class="s1">&#39;bp-RELL: bootstrap proportion using RELL method (Kishino et al. 1990)&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                        <span class="s1">&#39;p-KH: p-value of one sided Kishino-Hasegawa test (1989)&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                        <span class="s1">&#39;p-SH: p-value of Shimodaira-Hasegawa test (2000)&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                        <span class="s1">&#39;c-ELW: Expected Likelihood Weight (Strimmer &amp; Rambaut 2002)&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                        <span class="s1">&#39;&quot;p-AU: p-value of approximately unbiased (AU) test (Shimodaira, 2002)&quot;&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                        <span class="s1">&#39;Accept (+) or reject (-) hypothesis based on consensus of topology tests&#39;</span><span class="p">,</span>  <span class="c1">#9</span>
                                        <span class="s1">&#39;Masked alignment file&#39;</span><span class="p">,</span> <span class="c1">#10</span>
                                        <span class="s1">&#39;Sequence name conversion table file&#39;</span><span class="p">,</span> <span class="c1">#11</span>
                                        <span class="s1">&#39;Trimmed input alignment file&#39;</span><span class="p">,</span> <span class="c1">#12</span>
                                        <span class="s1">&#39;Constraint tree file&#39;</span><span class="p">,</span> <span class="c1">#13</span>
                                        <span class="s1">&#39;Starting tree file&#39;</span><span class="p">,</span> <span class="c1">#14</span>
                                        <span class="s1">&#39;ML tree file&#39;</span><span class="p">,</span> <span class="c1">#15</span>
                                        <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                        <span class="p">])</span>
    <span class="k">elif</span> <span class="n">place</span><span class="p">:</span>
        <span class="n">summary_header_line</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;Model/backbone tree name&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;Original alignment file&#39;</span><span class="p">,</span> <span class="c1">#0</span>
                                        <span class="s1">&#39;Original tree file&#39;</span><span class="p">,</span> <span class="c1">#1</span>
                                        <span class="s1">&#39;Substitution model&#39;</span><span class="p">,</span> <span class="c1">#2</span>
                                        <span class="s1">&#39;ID of sequence added to tree&#39;</span><span class="p">,</span> <span class="c1">#3</span>
                                        <span class="s1">&#39;Description of sequence added to tree&#39;</span><span class="p">,</span> <span class="c1">#3</span>
                                        <span class="s1">&#39;Type sequence of clade the additional sequence was placed in by ML search&#39;</span><span class="p">,</span> <span class="c1">#5</span>
                                        <span class="s1">&#39;Name of clade that additional sequence was placed in&#39;</span><span class="p">,</span> <span class="c1">#6</span>
                                        <span class="s1">&#39;Masked alignment file&#39;</span><span class="p">,</span> <span class="c1">#10</span>
                                        <span class="s1">&#39;Sequence name conversion table file&#39;</span><span class="p">,</span> <span class="c1">#11</span>
                                        <span class="s1">&#39;Trimmed input alignment file&#39;</span><span class="p">,</span> <span class="c1">#12</span>
                                        <span class="s1">&#39;Constraint tree file&#39;</span><span class="p">,</span> <span class="c1">#13</span>
                                        <span class="s1">&#39;ML tree file&#39;</span><span class="p">,</span> <span class="c1">#15</span>
                                        <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                        <span class="p">])</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">summary_csv_fp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">summary_header_line</span><span class="p">)</span>

    <span class="c1"># Take tree topology and alignment (regular names), convert names in alignment</span>
    <span class="c1"># generating a conversion table similar to for name_replace.pl, then use that</span>
    <span class="c1"># conversion table to code the names in the tree topology as well.</span>

    <span class="c1"># Determine whether input sequence file is a fasta file or not.</span>
    <span class="n">fasta</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">file_with_seqs</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">):</span>
        <span class="n">fasta</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="c1"># Align sequences to alignment and trim.</span>
    <span class="k">if</span> <span class="n">fasta</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;A model must be specified if the input</span>
<span class="s2">        sequence file is a FASTA file.&quot;&quot;&quot;</span>
        <span class="c1">## Get info.</span>
        <span class="c1">#model_info = ModelInfoFromCSV(model)</span>

        <span class="c1"># Classify each sequence.</span>
        <span class="n">ali_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">file_with_seqs</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
            <span class="n">ali_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">place</span><span class="p">:</span>
                <span class="n">classify_one_seq_record</span><span class="p">(</span><span class="n">ali_num</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span>
                    <span class="n">outdirpath1</span><span class="p">,</span> <span class="n">summary_csv_fp</span><span class="p">,</span> <span class="n">summary_header_line</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">place_one_seq_record</span><span class="p">(</span><span class="n">ali_num</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span>
                    <span class="n">outdirpath1</span><span class="p">,</span> <span class="n">summary_csv_fp</span><span class="p">,</span> <span class="n">summary_header_line</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Parse csv file.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file_with_seqs</span><span class="p">)</span>

        <span class="c1"># Get column header for column with Yes/No data.</span>
        <span class="n">yes_no_col</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">header</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Represents an identifiably unique paralogue&#39;</span><span class="p">):</span>
                <span class="n">yes_no_col</span> <span class="o">=</span> <span class="n">header</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">yes_no_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">header</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Collective interpretation of reverse search results&#39;</span><span class="p">):</span>
                    <span class="n">yes_no_col</span> <span class="o">=</span> <span class="n">header</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">yes_no_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">header</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit based on E-value criterion&#39;</span><span class="p">):</span>
                    <span class="n">yes_no_col</span> <span class="o">=</span> <span class="n">header</span>
                    <span class="k">break</span>

        <span class="c1"># Iterate over rows in dataframe.</span>
        <span class="n">ali_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ali_used_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">ali_num</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Get a sequence record object and model from info in the row.</span>
            <span class="n">record</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">model</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">yes_no_col</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="s1">&#39;Yes&#39;</span> <span class="ow">or</span> <span class="n">result</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span> 
                <span class="n">ali_used_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit accession&#39;</span><span class="p">]</span>
                <span class="n">description</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">subseq</span> <span class="ow">or</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward search method&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;tblastn&#39;</span><span class="p">):</span>
                    <span class="n">description</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit description of subsequence(s) that align(s) to query&#39;</span><span class="p">]</span>
                    <span class="n">seq</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit subsequence(s) that align(s) to query&#39;</span><span class="p">]</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">description</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit description&#39;</span><span class="p">]</span>
                    <span class="n">seq</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit sequence&#39;</span><span class="p">]</span> 
                <span class="n">db_file</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Subject database species (if applicable)&#39;</span><span class="p">]</span>

                <span class="c1"># Get name of model/tree to use from the Models directory</span>
                <span class="c1"># (specified in the settings module).</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Model/backbone tree name&#39;</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">model</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span>
                <span class="k">assert</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="c1"># Use the species name if writing the file for input to</span>
                <span class="c1"># phylogenetics software.</span>
                <span class="k">if</span> <span class="n">abbrev</span><span class="p">:</span>
                    <span class="n">description</span> <span class="o">=</span> <span class="n">db_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="c1"># Instantiate a sequence object for the sequence of interest to</span>
                <span class="c1"># be written to output.</span>
                <span class="n">record</span> <span class="o">=</span> <span class="n">get_seq_obj_from_srch_res_csv_info</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>

                <span class="c1">## Call function to retrieve info about model tree to use.</span>
                <span class="c1">#model_info = ModelInfoFromCSV(model)</span>

                <span class="c1"># Call function to classify the sequence and add corresponding rows</span>
                <span class="c1"># to the (intermediate) summary spreadsheet.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">place</span><span class="p">:</span>
                    <span class="n">classify_one_seq_record</span><span class="p">(</span><span class="n">ali_used_num</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> 
                        <span class="n">outdirpath1</span><span class="p">,</span> <span class="n">summary_csv_fp</span><span class="p">,</span> <span class="n">summary_header_line</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">place_one_seq_record</span><span class="p">(</span><span class="n">ali_num</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> 
                        <span class="n">outdirpath1</span><span class="p">,</span> <span class="n">summary_csv_fp</span><span class="p">,</span> <span class="n">summary_header_line</span><span class="p">)</span>

    <span class="c1"># End time.</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># Record time elapsed.</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
    <span class="n">logfile</span> <span class="o">=</span> <span class="n">get_phylo_class_logfile_path</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">logfile</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logh</span><span class="p">:</span>
        <span class="n">logh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Total run time: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">elapsed</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Return main output path.</span>
    <span class="k">return</span> <span class="n">summary_csv_fp</span></div>


<div class="viewcode-block" id="ModelInfoFromCSV"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.ModelInfoFromCSV">[docs]</a><span class="k">class</span> <span class="nc">ModelInfoFromCSV</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for retrieving information about a named model (backbone tree).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span>

        <span class="c1"># Get info from model info csv file using pandas.</span>
        <span class="n">alignmentfp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">subs_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tree_topologyfp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">type_seqsfp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">model_info_csv</span><span class="p">)</span>
        <span class="n">found_model_with_name</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Model name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">model_name</span><span class="p">:</span>
                <span class="n">found_model_with_name</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">alignmentfp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">model_dir_path</span><span class="p">,</span>
                        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Alignment file&#39;</span><span class="p">])</span>
                <span class="n">subs_model</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Substitution model&#39;</span><span class="p">]</span>
                <span class="n">type_seqsfp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">model_dir_path</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Type sequences and names of the clades that they define&#39;</span><span class="p">])</span>
                <span class="n">tree_topologyfp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">model_dir_path</span><span class="p">,</span>
                        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Tree topology file&#39;</span><span class="p">])</span>
                <span class="k">break</span>
        <span class="k">assert</span> <span class="n">found_model_with_name</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not find a model named </span><span class="si">%s</span><span class="s2"> in</span>
<span class="s2">        info spreadsheet </span><span class="si">%s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">model_info_csv</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">alignmentfp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">alignmentfp</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">subs_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">subs_model</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">tree_topologyfp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tree_topologyfp</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">type_seqsfp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">type_seqsfp</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># Store this information as attributes of the object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alignment_file</span> <span class="o">=</span> <span class="n">alignmentfp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subs_model</span> <span class="o">=</span> <span class="n">subs_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_topology_file</span> <span class="o">=</span> <span class="n">tree_topologyfp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_seqs_file</span> <span class="o">=</span> <span class="n">type_seqsfp</span></div>


<div class="viewcode-block" id="get_clade_name_from_model"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.get_clade_name_from_model">[docs]</a><span class="k">def</span> <span class="nf">get_clade_name_from_model</span><span class="p">(</span><span class="n">type_seq_name</span><span class="p">,</span> <span class="n">type_seqs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return clade name for given type sequence name and type seqs info file</span>
<span class="sd">    (from models directory).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get clade name.</span>
    <span class="n">clade_name</span> <span class="o">=</span> <span class="s1">&#39;?&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
            <span class="n">spliti</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">spliti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">spliti</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">type_seq_name</span><span class="p">:</span>
                <span class="n">clade_name</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">type_seq_name</span><span class="p">:</span>
                <span class="n">clade_name</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">break</span>
    <span class="k">assert</span> <span class="n">clade_name</span> <span class="o">!=</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify clade name for type</span>
<span class="s2">    sequence name </span><span class="si">%s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">type_seq_name</span>

    <span class="k">return</span> <span class="n">clade_name</span></div>
        

<div class="viewcode-block" id="get_phylo_class_logfile_path"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.get_phylo_class_logfile_path">[docs]</a><span class="k">def</span> <span class="nf">get_phylo_class_logfile_path</span><span class="p">(</span><span class="n">phylo_class_outdir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a log file path given an output directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">phylo_class_outdir</span><span class="p">,</span> <span class="s1">&#39;0_tree_search_log.txt&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logfile</span></div>


<div class="viewcode-block" id="classify_one_seq_record"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.classify_one_seq_record">[docs]</a><span class="k">def</span> <span class="nf">classify_one_seq_record</span><span class="p">(</span><span class="n">ali_num</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span>
        <span class="n">outdirpath1</span><span class="p">,</span> <span class="n">summary_csv_fp</span><span class="p">,</span> <span class="n">summary_header_line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Classify one sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#assert 1 == 2, &quot;&quot;&quot;Trying not to use this function.&quot;&quot;&quot; # Temp.</span>

    <span class="c1"># Check that the input sequence record is not just &#39;-&#39;.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Input sequence is only one residue long.&quot;&quot;&quot;</span>

    <span class="c1"># Get info about model that is relevant.</span>
    <span class="n">model_info</span> <span class="o">=</span> <span class="n">ModelInfoFromCSV</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">alignment_file</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">tree_topology_file</span>
    <span class="n">subs_model</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">subs_model</span>
    <span class="n">type_seqs</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">type_seqs_file</span>

    <span class="c1"># Define logfile path to write to.</span>
    <span class="n">logfile</span> <span class="o">=</span> <span class="n">get_phylo_class_logfile_path</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">)</span>

    <span class="c1">#ali = os.path.join(outdirpath1, &#39;1.nex&#39;) </span>
    <span class="c1">#ali = add_seq_to_alignment3(record, alignment, outdirpath1)</span>
    <span class="n">ali</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ali_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span><span class="p">)</span> 
    <span class="n">add_seq_to_alignment3</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">ali</span><span class="p">)</span>

    <span class="c1"># Convert nexus alignment to afa.</span>
    <span class="n">temp_fa_1</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_temp1.afa&#39;</span>
    <span class="n">nex_to_afa</span><span class="p">(</span><span class="n">ali</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">)</span> 

    <span class="c1"># Code names in alignment.</span>
    <span class="n">outalifp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.afa&#39;</span>
    <span class="n">outtablefp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.table&#39;</span>
    <span class="n">code_names_in_ali</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">,</span> <span class="n">outalifp</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span> 

    <span class="c1"># Convert alignment back to nexus.</span>
    <span class="n">outalifpnex</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.nex&#39;</span>
    <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">outalifp</span><span class="p">,</span> <span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_fa_1</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifp</span><span class="p">)</span>

    <span class="c1"># Get list of &quot;type&quot; sequences from input.</span>
    <span class="n">type_seq_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">):</span>
        <span class="n">type_seq_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>


    <span class="c1"># Only do the following steps once for all the alignments, because all the</span>
    <span class="c1"># constrained topology analyses will use the same constraint trees.</span>
    <span class="k">if</span> <span class="n">ali_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c1"># Put quotation marks around names in constraint tree. # SEPARATE</span>
        <span class="n">outtreefp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.constraint_tree0.Q.newick&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">as</span> <span class="n">intreefh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">intreefh</span><span class="p">:</span>
                <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">quote_tree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">))</span>



        <span class="c1"># Make topology constraint trees.   </span>

        <span class="c1"># Parse backbone topology and root on a clade rather than having the root</span>
        <span class="c1"># inside a clade.</span>

        <span class="c1">######################</span>
        <span class="c1"># Parse tree using ete3.</span>
        <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Define name for tree without branch lengths.</span>
        <span class="n">simple_tree</span> <span class="o">=</span> <span class="n">outtreefp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_TEMP2&#39;</span> 

        <span class="c1"># Write simple tree to a new file </span>
        <span class="n">t1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="n">simple_tree</span><span class="p">)</span>

        <span class="c1"># Parse simple tree.</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">simple_tree</span><span class="p">)</span>

        <span class="c1"># Print simple tree.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input tree:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

        <span class="c1">## Get node for a key clade. </span>
        <span class="c1">## Or, just require to root it before inputting (figtree can export</span>
        <span class="c1">## re-rooted newick)?????</span>
        <span class="c1">#print(&quot;\nPlease define an arbitrary clade of interest for rooting the tree topology\n&quot;)</span>
        <span class="c1">#clade_member_1 = input(&#39;Clade member 1: &#39;)</span>
        <span class="c1">#clade_member_2 = input(&#39;Clade member 2: &#39;)</span>
        <span class="c1">#ancestor1 = t2.get_common_ancestor(clade_member_1, clade_member_2)</span>
        <span class="c1">##print(ancestor1)</span>

        <span class="c1">## Re-root tree on a clade (as a polytomy) rather than inside a clade, so</span>
        <span class="c1">## that key branches can be more easily identified.</span>
        <span class="c1">#t2.set_outgroup(ancestor1)</span>

        <span class="c1">######################</span>


        <span class="c1"># Get to topologies sorted out...</span>

        <span class="c1"># Get constraint topologies for each clade of interest to test</span>
        <span class="c1"># alternative topology hypotheses.</span>

        <span class="c1"># For each &quot;type&quot; sequence, traverse all nodes and find the node with</span>
        <span class="c1"># the largest number of child nodes that are leaf (terminal) nodes,</span>
        <span class="c1"># containing the &quot;type&quot; sequence of interest, but not containing any of</span>
        <span class="c1"># the other &quot;type&quot; sequences.</span>
        <span class="n">ts_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
            <span class="n">ts_num</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="n">ts</span>
                <span class="c1"># Root on another &quot;type&quot; sequence for the first type sequence in</span>
                <span class="c1"># the list to get whole clade, then root the tree on the ancestor</span>
                <span class="c1"># node of that first clade.</span>

                <span class="c1"># Get a node name for a node corresponding to a different</span>
                <span class="c1"># &quot;type&quot; sequence.</span>
                <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ts</span><span class="p">:</span>
                        <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>

                <span class="c1"># Get node corresponding to a different &quot;type&quot; sequence.</span>
                <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1">#print(other_type_seq_node_name)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="c1">#print(node.name)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_type_seq_node_name</span><span class="p">:</span>
                        <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
                <span class="k">assert</span> <span class="n">other_type_seq_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="c1"># Root on the other &quot;type&quot; sequence node.</span>
                <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">other_type_seq_node</span><span class="p">)</span>

                <span class="c1">#print(&#39;\n\n\nTree rooted on a type sequence other than the first type sequence.&#39;)</span>
                <span class="c1">#print(t2)</span>

            <span class="k">elif</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Root on the first &quot;type&quot; sequence node for all subsequent</span>
                <span class="c1"># clades.</span>
                <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="n">leaf_list</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_type_seq_node_name</span><span class="p">:</span>
                            <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                            <span class="k">break</span>
                <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">first_type_seq_node</span><span class="p">)</span>
                <span class="c1">#print(&#39;\n\n\nTree re-rooted on first type sequence:&#39;)</span>
                <span class="c1">#print(t2)</span>


            <span class="c1"># Make a copy of the tree topology to work with for each run</span>
            <span class="c1"># through this loop.</span>
            <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Make a list of nodes that contain type seq, but not any others. #</span>
            <span class="c1"># SEPARATE</span>
            <span class="n">nodes_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="c1"># Search in nodes that contain the type sequence.</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts</span><span class="p">):</span>
                    <span class="c1"># Search in nodes that don&#39;t contain other type sequences.</span>
                    <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">ts2</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">ts2</span> <span class="o">==</span> <span class="n">ts</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts2</span><span class="p">):</span>
                                <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_other_type_seqs</span><span class="p">:</span>
                        <span class="c1"># Add nodes of interest to list.</span>
                        <span class="n">nodes_of_interest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="c1"># find the node with the most child leaf nodes.</span>
            <span class="c1">#node_num = 0</span>
            <span class="c1">#for node in nodes_of_interest:</span>
            <span class="c1">#    node_num += 1 </span>
            <span class="c1">#    print(&#39;Node &#39; + str(node_num) + &#39; Number of leaves:  &#39; + str(len(node.get_leaves())))</span>
            <span class="c1">#    print(node)</span>
            <span class="n">node_w_most_leaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                    <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
            <span class="c1">#print(&#39;\n\nClade defined by sequence &#39; + ts + &#39;:&#39;)</span>
            <span class="c1">#print(node_w_most_leaves)</span>


            <span class="c1"># Copy tree and remove node/clades in constraint trees and replace with</span>
            <span class="c1"># polytomies composed of the same sequences.</span>
            <span class="n">starting_tree</span> <span class="o">=</span> <span class="n">t3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">node_of_interest</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">starting_tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                    <span class="n">node_of_interest</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">break</span>

            <span class="c1"># Add node for additional sequence as most basal taxon.</span>
            <span class="n">name_for_additional_node</span> <span class="o">=</span> <span class="s1">&#39;AddSeq&#39;</span>
            <span class="n">node_of_interest</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name_for_additional_node</span><span class="p">)</span>
            <span class="n">node_of_interest</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="s1">&#39;AddSeq&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;node with additional sequence:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">node_of_interest</span><span class="p">)</span>

            <span class="c1"># Unroot tree, because ML trees are all unrooted.</span>
            <span class="n">starting_tree</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>

            <span class="c1"># Write modified tree.</span>
            <span class="n">outtreename1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span>
                    <span class="s1">&#39;clade_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_starting_tree_def_seq_&#39;</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>\
                    <span class="o">+</span> <span class="s1">&#39;.tre&#39;</span><span class="p">)</span>
            <span class="n">starting_tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">outtreename1</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>


            <span class="c1"># Copy tree and remove node/clades in constraint trees and replace with</span>
            <span class="c1"># polytomies composed of the same sequences.</span>
            <span class="n">clade_constr_tree</span> <span class="o">=</span> <span class="n">starting_tree</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Remove internal child nodes in the clade so that it becomes a</span>
            <span class="c1"># polytomy. # SEPARATE</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">clade_constr_tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                    <span class="n">nodes_to_delete</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">cn</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                            <span class="n">nodes_to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">nodes_to_delete</span><span class="p">:</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

            <span class="c1"># Show modified node.</span>
            <span class="c1">#print(&#39;\nClade as polytomy:&#39;)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">clade_constr_tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                    <span class="c1">#print(node)</span>
                    <span class="k">pass</span>

            <span class="c1"># Unroot tree, because ML trees are all unrooted.</span>
            <span class="n">clade_constr_tree</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>
            
            <span class="c1"># Write modified tree.</span>
            <span class="n">outtreename2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span>
                    <span class="s1">&#39;clade_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_constraint_tree_def_seq_&#39;</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>\
                    <span class="o">+</span> <span class="s1">&#39;.tre&#39;</span><span class="p">)</span>
            <span class="c1">#print(&#39;outtreename:&#39;)</span>
            <span class="c1">#print(outtreename)</span>
            <span class="c1">#with open(outtreename, &#39;w&#39;) as outfh:</span>
            <span class="n">clade_constr_tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">outtreename2</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>

        <span class="c1"># Remove temporary files.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">simple_tree</span><span class="p">)</span>


    <span class="c1">## Loop through alignments and make copies of the starting trees and constraint</span>
    <span class="c1">## trees with renamed &quot;AddSeq&quot; taxon, as well as copies with coded sequence</span>
    <span class="c1">## names for input to IQtree.</span>
    <span class="c1">#ali_num = 0</span>
    <span class="c1">#for ali in glob.glob(os.path.join(outdirpath1, &#39;*trim.C.nex&#39;)):</span>
    <span class="c1">#    ali_num += 1</span>

    <span class="c1"># Remove unnecessary uncoded trim file.</span>
    <span class="n">trim_file_to_remove</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">trim_file_to_remove</span><span class="p">)</span>

    <span class="c1"># Define corresponding conversion table file path.</span>
    <span class="n">tablefp</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.table&#39;</span>

    <span class="c1"># Get name of additional sequence from table.</span>
    <span class="n">additional_seq_orig_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tablefp</span><span class="p">)</span> <span class="k">as</span> <span class="n">tablefh</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">tablefh</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">additional_seq_orig_name</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="c1"># Check that the output folder is a directory.</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">)),</span> <span class="s2">&quot;&quot;&quot;Directory does not exist: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Loop through trees, parse them, change the &quot;AddSeq&quot; node name to the name</span>
    <span class="c1"># of the additional sequence for this particular alignment, then write to a</span>
    <span class="c1"># file. # SEPARATE</span>
    <span class="n">constraint_tree_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">starting_tree_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">))</span>
    <span class="n">trees_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">),</span> <span class="s1">&#39;clade_*.tre&#39;</span><span class="p">)))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No constraint or starting trees identified.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">trees_list</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
        <span class="c1"># Parse tree.</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tf</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Change node name in tree.</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tx</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;AddSeq&#39;</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">additional_seq_orig_name</span>
                <span class="k">break</span>
        <span class="c1"># Write modified tree.</span>
        <span class="n">outtreename</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">tx</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">outtreename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
        <span class="c1"># Make copy of tree file with coded names.</span>
        <span class="n">outtreename2</span> <span class="o">=</span> <span class="n">outtreename</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.tre&#39;</span>
        <span class="n">code_tree</span><span class="p">(</span><span class="n">outtreename</span><span class="p">,</span> <span class="n">outtreename2</span><span class="p">,</span> <span class="n">tablefp</span><span class="p">)</span>
        <span class="c1"># Remove copy with uncoded names.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outtreename</span><span class="p">)</span>
        <span class="c1"># Add file paths to lists as appropriate.</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;constraint&#39;</span><span class="p">:</span>
            <span class="n">constraint_tree_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outtreename2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;starting&#39;</span><span class="p">:</span>
            <span class="n">starting_tree_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outtreename2</span><span class="p">)</span>

    <span class="c1"># Check that constraint trees were found.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraint_tree_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No constraint trees in list.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">starting_tree_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No starting trees in list.&quot;&quot;&quot;</span>


    <span class="c1"># Make a copy of the alignment in phylip format for input to IQtree.</span>
    <span class="n">phy_out</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.phy&#39;</span>
    <span class="n">nex_to_phylip</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">)</span>

    <span class="c1"># Remove nexus format version of alignment, because it is redundant with</span>
    <span class="c1"># the phylip version.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Print to see whether the tree files are in the right order.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ctf</span><span class="p">,</span> <span class="n">stf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">constraint_tree_list</span><span class="p">,</span> <span class="n">starting_tree_list</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ctf&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ctf</span><span class="p">)</span>
        <span class="c1"># Check that the constraint tree is a file.</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ctf</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Could not find constraint tree file: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">ctf</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;stf&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">stf</span><span class="p">)</span>
        <span class="c1"># Check that the starting tree is a file.</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ctf</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Could not find starting tree file: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">stf</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>


    <span class="c1"># Do phylogenetic analysis. # SEPARATE</span>
    <span class="n">outtree_files_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ctf</span><span class="p">,</span> <span class="n">stf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">constraint_tree_list</span><span class="p">,</span> <span class="n">starting_tree_list</span><span class="p">):</span>
        <span class="c1"># Make subdir for output.</span>
        <span class="n">subdirp</span> <span class="o">=</span> <span class="n">ctf</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_IQ-tree_output&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">)</span>

        <span class="c1"># Use IQtree to do an ML search</span>
        <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirp</span><span class="p">,</span> <span class="s1">&#39;iqtree&#39;</span><span class="p">)</span>
        <span class="n">iqtree_command_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span> <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span>
            <span class="n">ctf</span><span class="p">,</span> <span class="s1">&#39;-t&#39;</span><span class="p">,</span> <span class="n">stf</span><span class="p">,</span> <span class="s1">&#39;-pre&#39;</span><span class="p">,</span> <span class="n">output_file_prefix</span><span class="p">,</span> <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">]</span>
        <span class="n">tree_search_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">)</span>
        <span class="n">tree_search_end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">logfile</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logh</span><span class="p">:</span>
            <span class="n">logh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">tree_search_elapsed</span> <span class="o">=</span> <span class="n">tree_search_end_time</span> <span class="o">-</span> <span class="n">tree_search_start_time</span>
            <span class="n">logh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Run time: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">tree_search_elapsed</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Add output tree file path to list.</span>
        <span class="n">tree_file_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.treefile&#39;</span>
        <span class="n">outtree_files_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">)</span>
        <span class="c1"># Check that the output file was actually produced.</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">)</span>

    <span class="c1"># Do topology tests using yielded trees.</span>

    <span class="c1"># Make output directory for topology test analysis.</span>
    <span class="n">topo_test_subdirp</span> <span class="o">=</span> <span class="n">phy_out</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topology_tests&#39;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">)</span>
    <span class="n">concat_tree_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">,</span> <span class="s1">&#39;concat_trees.tre&#39;</span><span class="p">)</span>
    <span class="n">concat_tree_name_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">,</span> <span class="s1">&#39;concat_tree_names.txt&#39;</span><span class="p">)</span>
    <span class="n">f_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">alt_tree_files</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">outtree_files_list</span><span class="p">:</span>
        <span class="n">f_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">alt_tree_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">concat_tree_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o1</span><span class="p">,</span>\
        <span class="nb">open</span><span class="p">(</span><span class="n">concat_tree_name_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
                <span class="n">o1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">o2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="n">f</span><span class="p">)</span>

    <span class="c1"># Use IQ-tree to perform topology tests.</span>
    <span class="n">topo_test_output_prefix</span> <span class="o">=</span> <span class="n">concat_tree_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topo_test&#39;</span> 
    <span class="n">topo_test_output_fp</span> <span class="o">=</span> <span class="n">concat_tree_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topo_test.iqtree&#39;</span> 
    <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span> <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span> <span class="s1">&#39;-n&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
        <span class="s1">&#39;-z&#39;</span><span class="p">,</span> <span class="n">concat_tree_file</span><span class="p">,</span> <span class="s1">&#39;-zb&#39;</span><span class="p">,</span> <span class="s1">&#39;10000&#39;</span><span class="p">,</span> <span class="s1">&#39;-au&#39;</span><span class="p">,</span> <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;-pre&#39;</span><span class="p">,</span>
        <span class="n">topo_test_output_prefix</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">topo_test_output_fp</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Topology test .iqtree output</span>
<span class="s2">    file not found.&quot;&quot;&quot;</span>

    <span class="c1"># Parse IQ-tree output to get results of topology test. # SEPARATE</span>
    <span class="n">data_line</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+ +-\d+\.\d+ +\d+\.\d+ +&#39;</span><span class="p">)</span>
    <span class="c1">#data_line = re.compile(r&#39;^ +\d+ +-\d+\.\d+&#39;)</span>
    <span class="n">space_char</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39; +&#39;</span><span class="p">)</span>
    <span class="n">topo_test_res_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">topo_test_output_fp</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data_line</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="c1"># Parse info from line in IQ-tree output file.</span>
                <span class="n">parsed_tree_info_list</span> <span class="o">=</span> <span class="n">space_char</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                <span class="n">tree_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">original_tree_fp</span> <span class="o">=</span> <span class="n">alt_tree_files</span><span class="p">[</span><span class="n">tree_num</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">logL</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">bp_RELL</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">p_KH</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                <span class="n">p_SH</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
                <span class="n">c_ELW</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span>
                <span class="n">p_AU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span>
                <span class="c1">#accept_reject = parsed_tree_info_list[12]</span>
                <span class="c1"># Add info to dict.</span>
                <span class="n">topo_test_res_dict</span><span class="p">[</span><span class="n">tree_num</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_tree_fp</span><span class="p">,</span> <span class="n">logL</span><span class="p">,</span>\
                        <span class="n">bp_RELL</span><span class="p">,</span> <span class="n">p_KH</span><span class="p">,</span> <span class="n">p_SH</span><span class="p">,</span> <span class="n">c_ELW</span><span class="p">,</span> <span class="n">p_AU</span><span class="p">)</span>

    <span class="c1"># Check that the number of test results is the same as the number of clades</span>
    <span class="c1"># of interest in the input tree.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">topo_test_res_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Too few lines found with</span>
<span class="s2">    topology search results.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">topo_test_res_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_seq_list</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Incorrect</span>
<span class="s2">    number of topology test results found.&quot;&quot;&quot;</span>

    <span class="c1"># Write info to summary spreadsheet file. # SEPARATE</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">summary_csv_fp</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">num_keys</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">topo_test_res_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">key_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topo_test_res_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                <span class="n">topo_test_res_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">key_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">info_tuple</span> <span class="o">=</span> <span class="n">topo_test_res_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># Assemble info to write to spreadsheet.</span>
            <span class="n">relative_tree_path</span> <span class="o">=</span> <span class="n">info_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">orig_align_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
            <span class="n">orig_tree_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">logL</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">bp_RELL</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">p_KH</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">p_SH</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">c_ELW</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
            <span class="n">p_AU</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>

            <span class="c1"># Apply a consensus approach to determine whether to accept or</span>
            <span class="c1"># reject topologies.</span>
            <span class="n">accept_reject</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
            <span class="n">consensus_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">bp_RELL</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">p_KH</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">p_SH</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">c_ELW</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">p_AU</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="n">consensus_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">consensus_num</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">accept_reject</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

            <span class="n">hypothesis_num</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">key_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of &#39;</span> <span class="o">+</span> <span class="n">num_keys</span>
            <span class="n">relative_table_path</span> <span class="o">=</span> <span class="n">tablefp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">tablefp</span><span class="p">)),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">type_seq_name</span> <span class="o">=</span>\
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">info_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_def_seq_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.C_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Get clade name.</span>
            <span class="n">clade_name</span> <span class="o">=</span> <span class="n">get_clade_name_from_model</span><span class="p">(</span><span class="n">type_seq_name</span><span class="p">,</span> <span class="n">type_seqs</span><span class="p">)</span>

            <span class="n">masked_ali_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span><span class="s1">&#39;*mask.C.nex&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="c1"># Write info line to spreadsheet.</span>
            <span class="n">info_line</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">model</span><span class="p">,</span>
                                  <span class="n">orig_align_file</span><span class="p">,</span> <span class="c1">#0</span>
                                  <span class="n">orig_tree_file</span><span class="p">,</span> <span class="c1">#1</span>
                                  <span class="n">subs_model</span><span class="p">,</span> <span class="c1">#2</span>
                                  <span class="n">additional_seq_orig_name</span><span class="p">,</span> <span class="c1">#3</span>
                                  <span class="n">hypothesis_num</span><span class="p">,</span> <span class="c1">#4</span>
                                  <span class="n">type_seq_name</span><span class="p">,</span> <span class="c1">#5</span>
                                  <span class="n">clade_name</span><span class="p">,</span> <span class="c1">#6</span>
                                  <span class="n">logL</span><span class="p">,</span>  <span class="c1">#7</span>
                                  <span class="n">bp_RELL</span><span class="p">,</span> <span class="c1">#8</span>
                                  <span class="n">p_KH</span><span class="p">,</span> <span class="c1">#8A</span>
                                  <span class="n">p_SH</span><span class="p">,</span> <span class="c1">#8B</span>
                                  <span class="n">c_ELW</span><span class="p">,</span> <span class="c1">#8C</span>
                                  <span class="n">p_AU</span><span class="p">,</span> <span class="c1">#8D</span>
                                  <span class="n">accept_reject</span><span class="p">,</span>
                                  <span class="n">masked_ali_file</span><span class="p">,</span> <span class="c1">#10</span>
                                  <span class="n">relative_table_path</span><span class="p">,</span> <span class="c1">#11</span>
                                  <span class="s1">&#39;Trimmed input alignment file&#39;</span><span class="p">,</span> <span class="c1">#12</span>
                                  <span class="s1">&#39;Constraint tree file&#39;</span><span class="p">,</span> <span class="c1">#13</span>
                                  <span class="s1">&#39;Starting tree file&#39;</span><span class="p">,</span> <span class="c1">#14</span>
                                  <span class="n">relative_tree_path</span><span class="p">,</span> <span class="c1">#15</span>
                                  <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                  <span class="p">])</span>
            <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">info_line</span><span class="p">)</span></div>


<div class="viewcode-block" id="place_one_seq_record"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.place_one_seq_record">[docs]</a><span class="k">def</span> <span class="nf">place_one_seq_record</span><span class="p">(</span><span class="n">ali_num</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span>
        <span class="n">outdirpath1</span><span class="p">,</span> <span class="n">summary_csv_fp</span><span class="p">,</span> <span class="n">summary_header_line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Classify one sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get info about model that is relevant.</span>
    <span class="n">model_info</span> <span class="o">=</span> <span class="n">ModelInfoFromCSV</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">alignment_file</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">tree_topology_file</span>
    <span class="n">subs_model</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">subs_model</span>
    <span class="n">type_seqs</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">type_seqs_file</span>

    <span class="c1"># Define logfile path to write to.</span>
    <span class="n">logfile</span> <span class="o">=</span> <span class="n">get_phylo_class_logfile_path</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">)</span>

    <span class="c1"># Modify sequence header for easy parsing.</span>
    <span class="n">additional_seq_description</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">description</span>
    <span class="n">modify_seq_descr_for_tree</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>

    <span class="c1"># Add sequence to alignment.</span>
    <span class="c1">#ali = os.path.join(outdirpath1, &#39;1.nex&#39;) </span>
    <span class="n">ali</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span><span class="p">)</span>
    <span class="n">masked_ali_file</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_mask.nex&#39;</span>
    <span class="n">add_seq_to_alignment3</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">ali</span><span class="p">)</span>

    <span class="c1"># Convert nexus alignment to afa.</span>
    <span class="n">temp_fa_1</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_temp1.afa&#39;</span>
    <span class="n">nex_to_afa</span><span class="p">(</span><span class="n">ali</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">)</span> 

    <span class="c1"># Code names in alignment.</span>
    <span class="n">outalifp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.afa&#39;</span>
    <span class="n">outtablefp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.table&#39;</span>
    <span class="n">code_names_in_ali</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">,</span> <span class="n">outalifp</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span> 

    <span class="c1"># Convert alignment back to nexus.</span>
    <span class="n">outalifpnex</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.nex&#39;</span>
    <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">outalifp</span><span class="p">,</span> <span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_fa_1</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifp</span><span class="p">)</span>

    <span class="c1"># Define path for constraint tree file.</span>
    <span class="n">constraint_tree_fp_coded</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Only do the following steps once for all the alignments, because all the</span>
    <span class="c1"># constrained topology analyses will use the same constraint trees.</span>
    <span class="k">if</span> <span class="n">ali_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c1"># Put quotation marks around names in constraint tree. # SEPARATE</span>
        <span class="c1">#outtreefp = ali.rsplit(&#39;.&#39;, 1)[0] + &#39;.constraint_tree0.Q.newick&#39;</span>
        <span class="n">constraint_tree_fp_rooted</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">ali</span><span class="p">),</span>\
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_constraint_tree_rooted.newick&#39;</span><span class="p">))</span>
        <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">ali</span><span class="p">),</span>\
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_constraint_tree.newick&#39;</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">as</span> <span class="n">intreefh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">constraint_tree_fp_rooted</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">intreefh</span><span class="p">:</span>
                <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">quote_tree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">))</span>
        <span class="c1"># Unroot constraint tree.</span>
        <span class="n">tobj</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">constraint_tree_fp_rooted</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tobj</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>
        <span class="n">tobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">constraint_tree_fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">)</span>
        
        <span class="c1"># Make constraint tree with coded names.</span>
        <span class="n">constraint_tree_fp_coded</span> <span class="o">=</span> <span class="n">constraint_tree_fp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.newick&#39;</span>
        <span class="n">code_tree</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">,</span> <span class="n">constraint_tree_fp_coded</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">constraint_tree_fp_coded</span><span class="p">)</span>
        <span class="c1">#print(constraint_tree_fp_coded)</span>
        <span class="c1">#assert 2 != 2</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">constraint_tree_fp_coded</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">ali</span><span class="p">),</span>\
        <span class="s1">&#39;*_constraint_tree.C.newick&#39;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Run an ML search with the alignment (with additional sequence) and</span>
    <span class="c1"># constraint tree defined above.</span>

    <span class="c1"># Make a copy of the alignment in phylip format for input to IQtree.</span>
    <span class="n">phy_out</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.phy&#39;</span>
    <span class="n">nex_to_phylip</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">)</span>

    <span class="c1"># Remove nexus format version of alignment, because it is redundant with</span>
    <span class="c1"># the phylip version.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Do phylogenetic analysis. # SEPARATE</span>
    <span class="c1"># Make subdir for output.</span>
    <span class="c1">#subdirp = constraint_tree_fp_coded.rsplit(&#39;.&#39;, 1)[0] + &#39;_IQ-tree_output&#39;</span>
    <span class="n">subdirp</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_IQ-tree_output&#39;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">)</span>

    <span class="c1"># Use IQtree to do an ML search</span>
    <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirp</span><span class="p">,</span> <span class="s1">&#39;iqtree&#39;</span><span class="p">)</span>
    <span class="n">iqtree_command_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span> <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span>
        <span class="n">constraint_tree_fp_coded</span><span class="p">,</span> <span class="s1">&#39;-pre&#39;</span><span class="p">,</span> <span class="n">output_file_prefix</span><span class="p">,</span> <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">]</span>
    <span class="n">tree_search_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">)</span>
    <span class="n">tree_search_end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">logfile</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logh</span><span class="p">:</span>
        <span class="n">logh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">tree_search_elapsed</span> <span class="o">=</span> <span class="n">tree_search_end_time</span> <span class="o">-</span> <span class="n">tree_search_start_time</span>
        <span class="n">logh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Run time: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">tree_search_elapsed</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># Add output tree file path to list.</span>
    <span class="n">tree_file_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.treefile&#39;</span>
    <span class="c1"># Check that the output file was actually produced.</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">)</span>


    <span class="c1"># Parse the resulting tree to determine in which clade of interest, if any,</span>
    <span class="c1"># the sequence was placed.</span>

    <span class="c1"># Parse tree using ete3.</span>
    <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Convert names in tree back to original names.</span>
    <span class="n">uncode_tree_obj</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span>

    <span class="c1">## Define name for tree without branch lengths.</span>
    <span class="c1">#simple_tree = tree_file_path.rsplit(&#39;_&#39;, 1)[0] + &#39;_TEMP2&#39; </span>

    <span class="c1">## Write simple tree to a new file </span>
    <span class="c1">#t1.write(format=9, outfile=simple_tree)</span>

    <span class="c1">## Parse simple tree.</span>
    <span class="c1">#t2 = Tree(simple_tree)</span>

    <span class="c1"># Print simple tree.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ML tree:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>

    <span class="c1"># Make a copy of the tree object.</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Get list of &quot;type&quot; sequences from input.</span>
    <span class="n">type_seq_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">):</span>
        <span class="n">type_seq_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># For each &quot;type&quot; sequence, traverse all nodes and find the node with</span>
    <span class="c1"># the largest number of child nodes that are leaf (terminal) nodes,</span>
    <span class="c1"># containing the &quot;type&quot; sequence of interest, but not containing any of</span>
    <span class="c1"># the other &quot;type&quot; sequences.</span>
    <span class="n">ts_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
        <span class="n">ts_num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="c1"># Root on another &quot;type&quot; sequence for the first type sequence in</span>
            <span class="c1"># the list to get whole clade, then root the tree on the ancestor</span>
            <span class="c1"># node of that first clade.</span>

            <span class="c1"># Get a node name for a node corresponding to a different</span>
            <span class="c1"># &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ts</span><span class="p">:</span>
                    <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>

            <span class="c1"># Get node corresponding to a different &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_type_seq_node_name</span><span class="p">:</span>
                    <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">break</span>

            <span class="c1"># Root on the other &quot;type&quot; sequence node.</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">other_type_seq_node</span><span class="p">)</span>

            <span class="c1">#print(&#39;\n\n\nTree rooted on a type sequence other than the first type sequence.&#39;)</span>
            <span class="c1">#print(t2)</span>

        <span class="k">elif</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Root on the first &quot;type&quot; sequence node for all subsequent</span>
            <span class="c1"># clades.</span>
            <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="n">leaf_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_type_seq_node_name</span><span class="p">:</span>
                        <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">first_type_seq_node</span><span class="p">)</span>
            <span class="c1">#print(&#39;\n\n\nTree re-rooted on first type sequence:&#39;)</span>
            <span class="c1">#print(t2)</span>


        <span class="c1"># Make a copy of the tree topology to work with for each run</span>
        <span class="c1"># through this loop.</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Make a list of nodes that contain type seq, but not any others. #</span>
        <span class="c1"># SEPARATE</span>
        <span class="n">nodes_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="c1"># Search in nodes that contain the type sequence.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts</span><span class="p">):</span>
                <span class="c1"># Search in nodes that don&#39;t contain other type sequences.</span>
                <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">ts2</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ts2</span> <span class="o">==</span> <span class="n">ts</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts2</span><span class="p">):</span>
                            <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_other_type_seqs</span><span class="p">:</span>
                    <span class="c1"># Add nodes of interest to list.</span>
                    <span class="n">nodes_of_interest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># find the node with the most child leaf nodes.</span>
        <span class="c1">#node_num = 0</span>
        <span class="c1">#for node in nodes_of_interest:</span>
        <span class="c1">#    node_num += 1 </span>
        <span class="c1">#    print(&#39;Node &#39; + str(node_num) + &#39; Number of leaves:  &#39; + str(len(node.get_leaves())))</span>
        <span class="c1">#    print(node)</span>
        <span class="n">node_w_most_leaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">Clade defined by sequence &#39;</span> <span class="o">+</span> <span class="n">ts</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">node_w_most_leaves</span><span class="p">)</span>

        <span class="c1">#name_of_additional_seq = record.description</span>
        <span class="n">name_of_additional_seq</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">id</span> <span class="c1"># + &#39; &#39; + record.description</span>

        <span class="c1">#print(&#39;\n\n\n&#39;)</span>
        <span class="c1">#print(name_of_additional_seq)</span>
        <span class="c1">#print(&#39;\n\n\n&#39;)</span>
        <span class="c1">#for i in [x.name for x in node_w_most_leaves.get_leaves()]:</span>
        <span class="c1">#    print(i)</span>
        <span class="c1">#print(&#39;\n\n\n&#39;)</span>

        <span class="k">if</span> <span class="n">name_of_additional_seq</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]:</span>
            <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is in this clade.&#39;</span> <span class="o">%</span> <span class="n">name_of_additional_seq</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="c1"># If the sequence could not be placed in any of the clades of interest,</span>
    <span class="c1"># then set the name of the type sequence to a string &#39;None&#39;.</span>
    <span class="k">if</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>

    <span class="c1"># Check that the clade that the additional sequence was placed in was</span>
    <span class="c1"># identified.</span>
    <span class="k">assert</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Sequence was</span>
<span class="s2">    not placed in any of the clades of interest: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">record</span><span class="o">.</span><span class="n">description</span>


    <span class="c1"># Write info to summary spreadsheet file. # SEPARATE</span>
    <span class="n">orig_align_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span> 
    <span class="n">orig_tree_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> 
    <span class="c1">#additional_seq_orig_name = name_of_additional_seq </span>
    <span class="n">additional_seq_id</span> <span class="o">=</span> <span class="n">name_of_additional_seq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">type_seq_name</span> <span class="o">=</span> <span class="n">ts_that_additional_seq_was_placed_in</span>
    <span class="n">clade_name</span> <span class="o">=</span> <span class="n">ts_that_additional_seq_was_placed_in</span>
    <span class="k">if</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">clade_name</span> <span class="o">=</span> <span class="n">get_clade_name_from_model</span><span class="p">(</span><span class="n">type_seq_name</span><span class="p">,</span> <span class="n">type_seqs</span><span class="p">)</span>

    <span class="n">masked_ali_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">masked_ali_file</span><span class="p">)</span>
    <span class="n">relative_table_path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">relative_tree_path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">summary_csv_fp</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="c1"># Write info line to spreadsheet.</span>
        <span class="n">info_line</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">model</span><span class="p">,</span>
                              <span class="n">orig_align_file</span><span class="p">,</span>
                              <span class="n">orig_tree_file</span><span class="p">,</span>
                              <span class="n">subs_model</span><span class="p">,</span>
                              <span class="n">additional_seq_id</span><span class="p">,</span>
                              <span class="n">additional_seq_description</span><span class="p">,</span>
                              <span class="n">type_seq_name</span><span class="p">,</span>
                              <span class="n">clade_name</span><span class="p">,</span>
                              <span class="n">masked_ali_file</span><span class="p">,</span>
                              <span class="n">relative_table_path</span><span class="p">,</span>
                              <span class="s1">&#39;Trimmed input alignment file&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;Constraint tree file&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;Starting tree file&#39;</span><span class="p">,</span>
                              <span class="n">relative_tree_path</span><span class="p">,</span>
                              <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                              <span class="p">])</span>
        <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">info_line</span><span class="p">)</span></div>


<div class="viewcode-block" id="write_phylo_class_to_csv"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.write_phylo_class_to_csv">[docs]</a><span class="k">def</span> <span class="nf">write_phylo_class_to_csv</span><span class="p">(</span><span class="n">phylo_class_id</span><span class="p">,</span> <span class="n">outdir</span><span class="p">,</span>
        <span class="n">csv_file</span><span class="p">,</span> <span class="n">minimum_confidence</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">output_csv_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse output of a forward search (from running the fwd_srch command of</span>
<span class="sd">    amoebae) and append rows to input csv with information for interpreting</span>
<span class="sd">    the forward results. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get path to full summary csv file.</span>
    <span class="n">full_summary_csv_path</span> <span class="o">=</span> <span class="n">get_phylo_class_csv</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>

    <span class="c1"># Get path to output spreadsheet.</span>
    <span class="k">if</span> <span class="n">output_csv_path</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_csv_path</span> <span class="o">=</span> <span class="n">csv_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">phylo_class_id</span> <span class="o">+</span> <span class="s1">&#39;.csv&#39;</span>
    
    <span class="c1"># Get same list of header titles that the sum_fwd_srch command makes (for</span>
    <span class="c1"># parsing).</span>
    <span class="n">fwd_column_label_list</span> <span class="o">=</span> <span class="n">module_amoebae_column_header_lists</span><span class="o">.</span><span class="n">fwd_column_label_list</span> 

    <span class="c1"># Get data from input file.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Reading input csv file into a pandas dataframe.&#39;</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Manage parsing and summarization of the intermediate summary file</span>
    <span class="c1"># differently depending on whether the --place command was used or not.</span>

    <span class="c1"># Determine whether the place command was used or not.</span>
    <span class="n">place</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1">#if &#39;Accept (+) or reject (-) hypothesis based on consensus of topology tests&#39; not in df.loc[0]:</span>
    <span class="c1">#if &#39;Accept (+) or reject (-) hypothesis based on consensus of topology tests&#39; not in open(full_summary_csv_path).read():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">full_summary_csv_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;Accept (+) or reject (-) hypothesis based on consensus of topology tests&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">readline</span><span class="p">():</span>
            <span class="n">place</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">place</span><span class="p">:</span>
        <span class="c1"># Define a list of new column headers to be appended.</span>
        <span class="n">new_column_label_list</span> <span class="o">=</span> <span class="n">module_amoebae_column_header_lists</span><span class="o">.</span><span class="n">phylo_class_column_label_list</span>

        <span class="c1"># Initiate new dataframe with columns to be appended/joined to spreadsheet.</span>
        <span class="c1">#num_rows = len(list(df.index))</span>
        <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span> 

        <span class="c1"># Join constructed dataframe to input dataframe.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>

        <span class="c1">#num_rev_srchs = df[&#39;Query title&#39;].count()</span>
        <span class="n">num_potential_seqs</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Query title&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

        <span class="c1"># Iterate over rows in input spreadsheet with forward search results, and</span>
        <span class="c1"># determine which phylo_class output data needs to be found, and update the</span>
        <span class="c1"># row by adding this information.</span>
        <span class="n">row_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">row_num</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Check that a classification needed to be done for this row.</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit based on E-value criterion&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># Prevent analyzing reverse searches when the forward hit rank is over</span>
            <span class="c1"># a certain number.</span>
            <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit rank&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">settings</span><span class="o">.</span><span class="n">max_num_reverse_searches_per_database</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get info needed to extract relevant info from the full summary</span>
                <span class="c1"># csv.</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit accession&#39;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Summarizing results for sequence with accession &#39;</span> <span class="o">+</span> <span class="n">acc</span><span class="p">)</span>
                
                <span class="c1"># Parse summary file.</span>
                <span class="n">dff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">full_summary_csv_path</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Get info from corresponding rows in full phylo_class summary csv file.</span>
                <span class="n">info_found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">model_name</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">top_index</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">au_pvalue</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">consensus_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">top_clade</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">second_clade</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">top_clade_ELW_confidence</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">second_clade_ELW_confidence</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">indexf</span><span class="p">,</span> <span class="n">rowf</span> <span class="ow">in</span> <span class="n">dff</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="c1"># Parse the accession out of the sequence header listed in</span>
                    <span class="c1"># the phylo_class summary spreadsheet.</span>
                    <span class="c1"># ***This may be different depending on the formatting of</span>
                    <span class="c1"># the headers in the fasta file input to phylo_class.</span>
                    <span class="c1">#if rowf[&#39;Sequence added to tree&#39;].split(&#39; &#39;)[0] == acc:</span>
                    <span class="k">if</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;Sequence added to tree&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.copy&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">acc</span><span class="p">:</span>
                        <span class="n">info_found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Found info in phylo_class output sheet&#39;</span><span class="p">)</span>
                        <span class="n">consensus_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;Accept (+) or reject (-) hypothesis based on consensus of topology tests&#39;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;Hypothesis (tree/clade) number&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;1 of &#39;</span><span class="p">):</span>
                            <span class="n">top_index</span> <span class="o">=</span> <span class="n">indexf</span>
                            <span class="n">model_name</span> <span class="o">=</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;Model/backbone tree name&#39;</span><span class="p">]</span>
                            <span class="n">top_clade</span> <span class="o">=</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;Clade name&#39;</span><span class="p">]</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Top clade.&#39;</span><span class="p">)</span>
                            <span class="n">top_clade_ELW_confidence</span> <span class="o">=</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;c-ELW: Expected Likelihood Weight (Strimmer &amp; Rambaut 2002)&#39;</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">top_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">indexf</span> <span class="o">==</span> <span class="n">top_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Get info for second best classification clade.</span>
                        <span class="n">au_pvalue</span> <span class="o">=</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;p-AU: p-value of approximately unbiased (AU) test (Shimodaira, 2002)&#39;</span><span class="p">]</span>
                        <span class="n">second_clade</span> <span class="o">=</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;Clade name&#39;</span><span class="p">]</span>
                        <span class="n">second_clade_ELW_confidence</span> <span class="o">=</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;c-ELW: Expected Likelihood Weight (Strimmer &amp; Rambaut 2002)&#39;</span><span class="p">]</span>

                <span class="c1"># If a row with the information for the sequence with the currrent</span>
                <span class="c1"># Forward hit accession was found in the summary spreadsheet, then</span>
                <span class="c1"># write it to the dataframe.</span>
                <span class="k">if</span> <span class="n">info_found</span><span class="p">:</span>
                    <span class="c1"># Check that the info was retrieved.</span>
                    <span class="k">assert</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">assert</span> <span class="n">top_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">assert</span> <span class="n">au_pvalue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">assert</span> <span class="n">top_clade</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">assert</span> <span class="n">second_clade</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">assert</span> <span class="n">top_clade_ELW_confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">assert</span> <span class="n">second_clade_ELW_confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                    <span class="c1">## Determine whether all but the top classification/clade was</span>
                    <span class="c1">## rejected by consensus of hypothesis tests.</span>
                    <span class="c1">#all_but_top_rejected = &#39;No&#39;</span>
                    <span class="c1">#if consensus_list.count(&#39;+&#39;) == 1:</span>
                    <span class="c1">#    all_but_top_rejected = &#39;Yes&#39;</span>

                    <span class="c1"># Use AU test only for rejecting hypotheses.</span>
                    <span class="n">all_but_top_rejected</span> <span class="o">=</span> <span class="s1">&#39;No&#39;</span>
                    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">au_pvalue</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
                        <span class="n">all_but_top_rejected</span> <span class="o">=</span> <span class="s1">&#39;Yes&#39;</span>

                    <span class="c1"># Determine if ELW above threshold.</span>
                    <span class="n">top_ELW_above_threshold</span> <span class="o">=</span> <span class="s1">&#39;No&#39;</span>
                    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">top_clade_ELW_confidence</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">minimum_confidence</span><span class="p">:</span>
                        <span class="n">top_ELW_above_threshold</span> <span class="o">=</span> <span class="s1">&#39;Yes&#39;</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">top_clade_ELW_confidence</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>

                    <span class="c1"># Add info to output df.</span>
                    <span class="c1">#row[&#39;Model/backbone tree name&#39;] = model_name</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Classification&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_clade</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Second most likely classification&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_clade</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;AU topology test p-value for comparison with next most likely classification/topology&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">au_pvalue</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;All but top classification rejected by AU test?&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_but_top_rejected</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;ELW for most likely topology&#39;</span><span class="p">]</span> <span class="o">=</span>\
                        <span class="n">top_clade_ELW_confidence</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;ELW confidence for second most likely topology&#39;</span><span class="p">]</span> <span class="o">=</span>\
                        <span class="n">second_clade_ELW_confidence</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;ELW for most likely topology above threshold?&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_ELW_above_threshold</span>
                
                    <span class="c1"># Update row in dataframe with new information.</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>

                <span class="c1"># Otherwise, write &#39;-&#39; to the dataframe.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">place</span><span class="p">:</span>
        <span class="c1"># Define a list of new column headers to be appended.</span>
        <span class="n">new_column_label_list</span> <span class="o">=</span>\
        <span class="n">module_amoebae_column_header_lists</span><span class="o">.</span><span class="n">phylo_class_place_column_label_list</span>

        <span class="c1"># Initiate new dataframe with columns to be appended/joined to spreadsheet.</span>
        <span class="c1">#num_rows = len(list(df.index))</span>
        <span class="n">df_new_cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_label_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Set default value of all fields to &#39;-&#39;.</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_new_cols</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">df_new_cols</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)</span> 

        <span class="c1"># Join constructed dataframe to input dataframe.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_new_cols</span><span class="p">)</span>

        <span class="c1">#num_rev_srchs = df[&#39;Query title&#39;].count()</span>
        <span class="n">num_potential_seqs</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Query title&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

        <span class="c1"># Iterate over rows in input spreadsheet with forward search results, and</span>
        <span class="c1"># determine which phylo_class output data needs to be found, and update the</span>
        <span class="c1"># row by adding this information.</span>
        <span class="n">row_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">row_num</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Check that a classification needed to be done for this row.</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Positive/redundant (+) or negative (-) hit based on E-value criterion&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># Prevent analyzing reverse searches when the forward hit rank is over</span>
            <span class="c1"># a certain number.</span>
            <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit rank&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">settings</span><span class="o">.</span><span class="n">max_num_reverse_searches_per_database</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get info needed to extract relevant info from the full summary</span>
                <span class="c1"># csv.</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Forward hit accession&#39;</span><span class="p">]</span>
                
                <span class="c1"># Parse summary file.</span>
                <span class="n">dff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">full_summary_csv_path</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Get info from corresponding rows in full phylo_class summary csv file.</span>
                <span class="n">info_found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">model_name</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">top_clade</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">indexf</span><span class="p">,</span> <span class="n">rowf</span> <span class="ow">in</span> <span class="n">dff</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;ID of sequence added to tree&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">acc</span><span class="p">:</span>
                        <span class="n">info_found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">model_name</span> <span class="o">=</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;Model/backbone tree name&#39;</span><span class="p">]</span>
                        <span class="n">top_clade</span> <span class="o">=</span> <span class="n">rowf</span><span class="p">[</span><span class="s1">&#39;Name of clade that additional sequence was placed in&#39;</span><span class="p">]</span>

                <span class="c1"># If a row with the information for the sequence with the currrent</span>
                <span class="c1"># Forward hit accession was found in the summary spreadsheet, then</span>
                <span class="c1"># write it to the dataframe.</span>
                <span class="k">if</span> <span class="n">info_found</span><span class="p">:</span>
                    <span class="c1"># Check that the info was retrieved.</span>
                    <span class="k">assert</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">assert</span> <span class="n">top_clade</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                    <span class="c1"># Add info to output df.</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Model/backbone tree name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_name</span>
                    <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Classification&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_clade</span>
                    <span class="c1">#row[&#39;Second most likely classification&#39;] = second_clade</span>
                    <span class="c1">#row[&#39;AU topology test p-value for comparison with next most likely classification/topology&#39;] = au_pvalue</span>
                    <span class="c1">#row[&#39;All but top classification rejected?&#39;] = all_but_top_rejected</span>
                
                    <span class="c1"># Update row in dataframe with new information.</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>

                <span class="c1"># Otherwise, write &#39;-&#39; to the dataframe.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>



    <span class="c1"># Append phylo_class id to headers (to make unique).</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_column_label_list</span><span class="p">)])</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="s1">&#39; (&#39;</span> <span class="o">+</span> <span class="n">phylo_class_id</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_column_label_list</span><span class="p">]</span>

    <span class="c1"># Write joined to output path.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_csv_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Return main output path.</span>
    <span class="k">return</span> <span class="n">output_csv_path</span></div>


<div class="viewcode-block" id="get_all_alt_model_backbones"><a class="viewcode-back" href="../module_amoebae_phylo_clas.html#module_amoebae_phylo_clas.get_all_alt_model_backbones">[docs]</a><span class="k">def</span> <span class="nf">get_all_alt_model_backbones</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span>
                                <span class="n">out_dir_path</span><span class="p">,</span>
                                <span class="n">main_out_path</span><span class="p">,</span>
                                <span class="n">polytomy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">not_polytomy_clades</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">iqtree_au_test</span><span class="o">=</span><span class="kc">False</span>
                                <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a tree and make all alternative topologies for internal branches</span>
<span class="sd">    outside specific clades of interest. Or, take a tree and make internal</span>
<span class="sd">    branches/nodes outside specified clades of interest into a polytomy (by</span>
<span class="sd">    setting the polytomy option to True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get info from model.</span>
    <span class="n">model_info</span> <span class="o">=</span> <span class="n">ModelInfoFromCSV</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
    <span class="n">ali</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">alignment_file</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">tree_topology_file</span>
    <span class="n">subs_model</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">subs_model</span>
    <span class="n">type_seqs</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">type_seqs_file</span>


    <span class="c1"># Make output directory.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">main_out_path</span><span class="p">)</span>

    <span class="c1"># Get output directory path.</span>
    <span class="c1">#outdirpath1 = os.path.dirname(ali)</span>
    <span class="n">outdirpath1</span> <span class="o">=</span> <span class="n">main_out_path</span>

    <span class="c1"># Copy alignment to new directory.</span>
    <span class="n">max_ali_filename_len</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">ali</span><span class="p">)</span>
    <span class="n">shortname</span> <span class="o">=</span> <span class="n">basename</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basename</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_ali_filename_len</span><span class="p">:</span>
        <span class="n">shortname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">ali</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">46</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span>
    <span class="n">new_ali_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="n">shortname</span><span class="p">)</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">ali</span><span class="p">,</span> <span class="n">new_ali_path</span><span class="p">)</span>
    <span class="n">ali</span> <span class="o">=</span> <span class="n">new_ali_path</span>

    <span class="c1"># Convert nexus alignment to afa.</span>
    <span class="n">temp_fa_1</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_temp1.afa&#39;</span>
    <span class="n">nex_to_afa</span><span class="p">(</span><span class="n">ali</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">)</span> 

    <span class="c1"># Code names in alignment.</span>
    <span class="n">outalifp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.afa&#39;</span>
    <span class="n">outtablefp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.table&#39;</span>
    <span class="n">code_names_in_ali</span><span class="p">(</span><span class="n">outdirpath1</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">,</span> <span class="n">outalifp</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span> 

    <span class="c1"># Convert alignment back to nexus.</span>
    <span class="n">outalifpnex</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.nex&#39;</span>
    <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">outalifp</span><span class="p">,</span> <span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_fa_1</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifp</span><span class="p">)</span>


    <span class="c1"># Get outfilepath.</span>
    <span class="c1">#if outfilepath is None:</span>
    <span class="n">outfilepath</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_alt_topo_constraint.newick.tre&#39;</span>

    <span class="c1"># Define output file path.</span>
    <span class="c1">#if outfilepath is None:</span>
    <span class="c1">#    outtreefp = ali.rsplit(&#39;.&#39;, 1)[0] + &#39;_quoted_names.newick&#39;</span>
    <span class="c1">#else:</span>
    <span class="c1">#    outtreefp = outfilepath</span>
    <span class="n">outtreefp</span> <span class="o">=</span> <span class="n">ali</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_quoted_names.newick&#39;</span>

    <span class="c1"># Put quotation marks around names in input tree. # SEPARATE</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">as</span> <span class="n">intreefh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">intreefh</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">quote_tree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">))</span>


    <span class="c1"># Make topology constraint trees.   </span>

    <span class="c1"># Parse backbone topology and root on a clade rather than having the root</span>
    <span class="c1"># inside a clade.</span>

    <span class="c1">######################</span>
    <span class="c1"># Parse tree using ete3.</span>
    <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Define name for tree without branch lengths.</span>
    <span class="n">simple_tree</span> <span class="o">=</span> <span class="n">outtreefp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_TEMP2&#39;</span> 

    <span class="c1"># Write simple tree to a new file </span>
    <span class="n">t1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="n">simple_tree</span><span class="p">)</span>

    <span class="c1"># Parse simple tree.</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">simple_tree</span><span class="p">)</span>

    <span class="c1"># Print simple tree.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input tree:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

    <span class="c1">### Get node for a key clade. </span>
    <span class="c1">### Or, just require to root it before inputting (figtree can export</span>
    <span class="c1">### re-rooted newick)?????</span>
    <span class="c1">##print(&quot;\nPlease define an arbitrary clade of interest for rooting the tree topology\n&quot;)</span>
    <span class="c1">##clade_member_1 = input(&#39;Clade member 1: &#39;)</span>
    <span class="c1">##clade_member_2 = input(&#39;Clade member 2: &#39;)</span>
    <span class="c1">##ancestor1 = t2.get_common_ancestor(clade_member_1, clade_member_2)</span>
    <span class="c1">###print(ancestor1)</span>

    <span class="c1">### Re-root tree on a clade (as a polytomy) rather than inside a clade, so</span>
    <span class="c1">### that key branches can be more easily identified.</span>
    <span class="c1">##t2.set_outgroup(ancestor1)</span>

    <span class="c1">#######################</span>


    <span class="c1">## Get to topologies sorted out...</span>

    <span class="c1">## Get constraint topologies for each clade of interest to test</span>
    <span class="c1">## alternative topology hypotheses.</span>

    <span class="c1"># Get list of &quot;type&quot; sequences from input.</span>
    <span class="n">type_seq_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">type_seq_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># For each &quot;type&quot; sequence, traverse all nodes and find the node with</span>
    <span class="c1"># the largest number of child nodes that are leaf (terminal) nodes,</span>
    <span class="c1"># containing the &quot;type&quot; sequence of interest, but not containing any of</span>
    <span class="c1"># the other &quot;type&quot; sequences.</span>
    <span class="c1"># This loop should be its own function.</span>

    <span class="c1"># Make a list of nodes of interest.</span>
    <span class="n">nodes_of_interest_for_polytomy</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ts_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
        <span class="n">ts_num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Check that the type sequence is a reasonable string.</span>
        <span class="k">assert</span> <span class="n">ts</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Type sequence name is an empty string.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Type sequence name is None.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="c1"># Root on another &quot;type&quot; sequence for the first type sequence in</span>
            <span class="c1"># the list to get whole clade, then root the tree on the ancestor</span>
            <span class="c1"># node of that first clade.</span>

            <span class="c1"># Get a node name for a node corresponding to a different</span>
            <span class="c1"># &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ts</span><span class="p">:</span>
                    <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>

            <span class="c1"># Get node corresponding to a different &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_type_seq_node_name</span><span class="p">:</span>
                    <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">break</span>

            <span class="c1"># Root on the other &quot;type&quot; sequence node.</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">other_type_seq_node</span><span class="p">)</span>

            <span class="c1">#print(&#39;\n\n\nTree rooted on a type sequence other than the first type sequence.&#39;)</span>
            <span class="c1">#print(t2)</span>

        <span class="k">elif</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Root on the first &quot;type&quot; sequence node for all subsequent</span>
            <span class="c1"># clades.</span>
            <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="n">leaf_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_type_seq_node_name</span><span class="p">:</span>
                        <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">first_type_seq_node</span><span class="p">)</span>
            <span class="c1">#print(&#39;\n\n\nTree re-rooted on first type sequence:&#39;)</span>
            <span class="c1">#print(t2)</span>


        <span class="c1"># Make a copy of the tree topology to work with for each run</span>
        <span class="c1"># through this loop.</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Make a list of nodes that contain type seq, but not any others. #</span>
        <span class="c1"># SEPARATE</span>
        <span class="n">nodes_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="c1"># Search in nodes that contain the type sequence.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts</span><span class="p">):</span>
                <span class="c1"># Search in nodes that don&#39;t contain other type sequences.</span>
                <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">ts2</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ts2</span> <span class="o">==</span> <span class="n">ts</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts2</span><span class="p">):</span>
                            <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_other_type_seqs</span><span class="p">:</span>
                    <span class="c1"># Add nodes of interest to list.</span>
                    <span class="n">nodes_of_interest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># find the node with the most child leaf nodes.</span>
        <span class="c1">#node_num = 0</span>
        <span class="c1">#for node in nodes_of_interest:</span>
        <span class="c1">#    node_num += 1 </span>
        <span class="c1">#    print(&#39;Node &#39; + str(node_num) + &#39; Number of leaves:  &#39; + str(len(node.get_leaves())))</span>
        <span class="c1">#    print(node)</span>
        <span class="n">node_w_most_leaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>

        <span class="c1"># Get clade name for type sequence.</span>
        <span class="n">clade_name</span> <span class="o">=</span> <span class="n">get_clade_name_from_model</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">type_seqs</span><span class="p">)</span>

        <span class="c1"># Print clade.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">clade_name</span> <span class="o">+</span> <span class="s1">&#39; clade defined by sequence &#39;</span> <span class="o">+</span> <span class="n">ts</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">node_w_most_leaves</span><span class="p">)</span>

        <span class="n">nodes_of_interest_for_polytomy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_w_most_leaves</span><span class="p">)</span>


    <span class="c1">##if polytomy_clades:</span>
    <span class="c1">## Turn each of the nodes/clades/subtrees of interest into polytomies of</span>
    <span class="c1">## all the sequences they contain.</span>
    <span class="c1">#nodes_of_interest_for_polytomy_as_polytomies = []</span>
    <span class="c1">#for node_of_interest in nodes_of_interest_for_polytomy:</span>
    <span class="c1">#    node_of_interest_as_polytomy = get_polytomy_for_treenode(node_of_interest)</span>
    <span class="c1">#    nodes_of_interest_for_polytomy_as_polytomies.append(node_of_interest_as_polytomy)</span>
    <span class="c1">## Switch to new list.</span>
    <span class="c1">#nodes_of_interest_for_polytomy = nodes_of_interest_for_polytomy_as_polytomies</span>

    <span class="c1">#if not not_polytomy_clades:</span>
    <span class="c1">#    # Turn each of the nodes/clades/subtrees of interest into polytomies of</span>
    <span class="c1">#    # all the sequences they contain.</span>
    <span class="c1">#    nodes_of_interest_for_polytomy_as_polytomies = []</span>
    <span class="c1">#    for node_of_interest in nodes_of_interest_for_polytomy:</span>
    <span class="c1">#        node_of_interest_as_polytomy = get_polytomy_for_treenode(node_of_interest)</span>
    <span class="c1">#        nodes_of_interest_for_polytomy_as_polytomies.append(node_of_interest_as_polytomy)</span>
    <span class="c1">#    # Switch to new list.</span>
    <span class="c1">#    nodes_of_interest_for_polytomy = nodes_of_interest_for_polytomy_as_polytomies</span>

    <span class="c1"># Initiate list of alternative tree topologies (newick strings).</span>
    <span class="n">alt_topos</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Generate relevant topologies.</span>
    <span class="k">if</span> <span class="n">polytomy</span><span class="p">:</span>
        <span class="c1"># Construct a polytomy of the nodes of interest.</span>

        <span class="c1"># Count number of nodes.</span>
        <span class="n">numnodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_of_interest_for_polytomy</span><span class="p">)</span>

        <span class="c1"># Make a backbone polytomy. </span>
        <span class="n">subtrees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_of_interest_for_polytomy</span><span class="p">:</span>
            <span class="c1"># Append modified node to list.</span>
            <span class="c1">#subtrees.append(n.write(format=9, quoted_node_names=True).rstrip(&#39;;&#39;))</span>
            <span class="n">subtrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">))</span>

        <span class="c1">#newick_backbone = &#39;(&#39; + &#39;,&#39;.join(subtrees) + &#39;)&#39;</span>
        <span class="c1">#newick_backbone = &#39;(&#39; + &#39;,&#39;.join(subtrees) + &#39;);&#39;</span>
        <span class="n">newick_backbone</span> <span class="o">=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subtrees</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;);&#39;</span>

        <span class="c1">#print(&#39;Topology as polytomy:&#39;)</span>
        <span class="c1">#print(newick_backbone)</span>

        <span class="c1"># Add polytomy to list of alternative topologies.</span>
        <span class="n">alt_topos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newick_backbone</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Make all alternative bifurcating topologies of branches connecting</span>
        <span class="c1"># the clades of interest.</span>
        <span class="n">alt_topos</span> <span class="o">=</span> <span class="n">get_all_alt_topologies</span><span class="p">(</span><span class="n">nodes_of_interest_for_polytomy</span><span class="p">)</span>
        <span class="c1">#print(&#39;\n\nAlternative newick backbones:\n&#39;)</span>
        <span class="c1">#for i in alt_topos:</span>
        <span class="c1">#    print(i)</span>
        <span class="c1">#    print(&#39;\n&#39;)</span>

    <span class="c1"># Write each alternative topology (with subtrees as polytomies) to a</span>
    <span class="c1"># separate newick file, for use as constraint trees. Also, write trees with</span>
    <span class="c1"># subtrees not as polytomies as starting trees for iqtree analyses.</span>
    <span class="n">topo_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">topo_filepaths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">topo_filepaths_starting</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">topo</span> <span class="ow">in</span> <span class="n">alt_topos</span><span class="p">:</span>
        <span class="n">topo_num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Define path to output text file.</span>
        <span class="n">topo_filepath</span> <span class="o">=</span> <span class="n">outfilepath</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">topo_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.newick.tre&#39;</span>
        <span class="n">topo_filepath_starting</span> <span class="o">=</span> <span class="n">outfilepath</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span>\
        <span class="nb">str</span><span class="p">(</span><span class="n">topo_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.starting.newick.tre&#39;</span>

        <span class="c1"># Add filepath to list.</span>
        <span class="n">topo_filepaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">topo_filepath</span><span class="p">)</span>
        <span class="n">topo_filepaths_starting</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">topo_filepath_starting</span><span class="p">)</span>

        <span class="c1"># Write topology string to text file.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">topo_filepath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">topo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Write starting topology string to text file.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">topo_filepath_starting</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">topo</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Check that the files were written.</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">topo_filepath</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">topo_filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">topo_filehandle</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">topo_filehandle</span><span class="o">.</span><span class="n">read</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">topo_filepath_starting</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">topo_filepath_starting</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">topo_filehandle</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">topo_filehandle</span><span class="o">.</span><span class="n">read</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">simple_tree</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outtreefp</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outtablefp</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Write versions of the nexus alignment file formatted for input to</span>
    <span class="c1"># phylogenetic analysis programs.</span>
    <span class="n">codenames_nex</span><span class="p">(</span><span class="n">ali</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">)</span>

    <span class="c1"># Define path to coded phylip alignment file.</span>
    <span class="n">phylip_filepaths</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">main_out_path</span><span class="p">,</span> <span class="s1">&#39;*C.phy&#39;</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">phylip_filepaths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Not the right number of potential</span>
<span class="s2">    phylip files in directory. Relevant files:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">phylip_filepaths</span><span class="p">)</span>
    <span class="n">phylip_filepath</span> <span class="o">=</span> <span class="n">phylip_filepaths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Define path to conversion table file.</span>
    <span class="n">conversion_table_filepaths</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">main_out_path</span><span class="p">,</span> <span class="s1">&#39;*C.table&#39;</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">conversion_table_filepaths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Not the right number of potential</span>
<span class="s2">    conversion table files in directory. Relevant files:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">conversion_table_filepaths</span><span class="p">)</span>
    <span class="n">conversion_table_filepath</span> <span class="o">=</span> <span class="n">conversion_table_filepaths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Write new constraint tree and starting tree files with names coded using</span>
    <span class="c1"># the same table.</span>
    <span class="n">coded_topo_filepaths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">coded_topo_filepaths_starting</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">topo_file</span><span class="p">,</span> <span class="n">topo_file_starting</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">topo_filepaths</span><span class="p">,</span>
            <span class="n">topo_filepaths_starting</span><span class="p">):</span>
        <span class="c1"># Define path to coded file.</span>
        <span class="n">coded_topo_file</span> <span class="o">=</span> <span class="n">topo_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_C.tre&#39;</span>
        <span class="n">coded_topo_file_starting</span> <span class="o">=</span> <span class="n">topo_file_starting</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_C.tre&#39;</span>

        <span class="c1"># Write coded file.</span>
        <span class="n">write_newick_tree_with_coded_names</span><span class="p">(</span><span class="n">topo_file</span><span class="p">,</span> <span class="n">coded_topo_file</span><span class="p">,</span>
                <span class="n">conversion_table_filepath</span><span class="p">)</span>
        <span class="n">write_newick_tree_with_coded_names</span><span class="p">(</span><span class="n">topo_file_starting</span><span class="p">,</span>
                <span class="n">coded_topo_file_starting</span><span class="p">,</span>
                <span class="n">conversion_table_filepath</span><span class="p">)</span>

        <span class="c1"># Check that the file was written.</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">coded_topo_file</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">coded_topo_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">topo_filehandle</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">topo_filehandle</span><span class="o">.</span><span class="n">read</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># Add coded file path to list.</span>
        <span class="n">coded_topo_filepaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coded_topo_file</span><span class="p">)</span>
        <span class="n">coded_topo_filepaths_starting</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coded_topo_file_starting</span><span class="p">)</span>

    <span class="c1"># Define path to MrBayes input file.</span>
    <span class="n">mrbayes_inputs</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">main_out_path</span><span class="p">,</span> <span class="s1">&#39;*C.mb.nex&#39;</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mrbayes_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Not the right number of potential</span>
<span class="s2">    MrBayes input files in directory. Relevant files:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">mrbayes_inputs</span><span class="p">)</span>
    <span class="n">mrbayes_input</span> <span class="o">=</span> <span class="n">mrbayes_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Write a copy of the MrBayes input file for each of the alternative</span>
    <span class="c1"># constraint trees.</span>
    <span class="n">coded_topo_file_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">coded_topo_file</span> <span class="ow">in</span> <span class="n">coded_topo_filepaths</span><span class="p">:</span>
        <span class="n">coded_topo_file_num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Define path to mrbayes input alignment with constraint encoded.</span>
        <span class="n">mrbayes_input_constrained</span> <span class="o">=</span> <span class="n">mrbayes_input</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>\
        <span class="s1">&#39;_constrained_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">coded_topo_file_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span>

        <span class="c1"># Write file with constraints.</span>
        <span class="n">constrain_mb_with_tree</span><span class="p">(</span><span class="n">mrbayes_input</span><span class="p">,</span>
                               <span class="n">coded_topo_file</span><span class="p">,</span>
                               <span class="n">mrbayes_input_constrained</span>
                               <span class="p">)</span>


    <span class="k">if</span> <span class="n">iqtree_au_test</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">polytomy</span><span class="p">:</span>
        <span class="c1"># Run constrained ML search using the original alignment using each</span>
        <span class="c1"># alternative output tree as a constraint.</span>
        <span class="c1"># ********Also, test against an unconstrained search and/or the exact</span>
        <span class="c1"># topology of the tree from the original model.</span>
        <span class="c1"># *****Consider using starting trees to speed things up.</span>

        <span class="c1"># Get list of constraint tree files.</span>

        <span class="c1"># Do phylogenetic analysis.</span>
        <span class="n">outtree_files_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ctf</span><span class="p">,</span> <span class="n">stf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coded_topo_filepaths</span><span class="p">,</span> <span class="n">coded_topo_filepaths</span><span class="p">):</span>
            <span class="c1"># Make subdir for output.</span>
            <span class="n">subdirp</span> <span class="o">=</span> <span class="n">ctf</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_IQ-tree_ml_search&#39;</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">)</span>

            <span class="c1"># Use IQtree to do an ML search</span>
            <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirp</span><span class="p">,</span> <span class="s1">&#39;iqtree&#39;</span><span class="p">)</span>
            <span class="n">iqtree_command_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phylip_filepath</span><span class="p">,</span> <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span>
                <span class="n">ctf</span><span class="p">,</span> <span class="s1">&#39;-pre&#39;</span><span class="p">,</span> <span class="n">output_file_prefix</span><span class="p">,</span> <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;-t&#39;</span><span class="p">,</span> <span class="n">stf</span><span class="p">]</span>
            <span class="n">tree_search_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">)</span>

            <span class="c1"># Add output tree file path to list.</span>
            <span class="n">tree_file_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.treefile&#39;</span>
            <span class="n">outtree_files_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">)</span>

            <span class="c1"># Check that the output file was actually produced.</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">)</span>

        <span class="c1"># Do topology tests using yielded trees.</span>

        <span class="c1"># Make output directory for topology test analysis.</span>
        <span class="n">topo_test_subdirp</span> <span class="o">=</span> <span class="n">phylip_filepath</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topology_tests&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">)</span>
        <span class="n">concat_tree_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">,</span> <span class="s1">&#39;concat_trees.tre&#39;</span><span class="p">)</span>
        <span class="n">concat_tree_name_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">topo_test_subdirp</span><span class="p">,</span> <span class="s1">&#39;concat_tree_names.txt&#39;</span><span class="p">)</span>
        <span class="n">f_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">alt_tree_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">outtree_files_list</span><span class="p">:</span>
            <span class="n">f_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">alt_tree_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">concat_tree_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o1</span><span class="p">,</span>\
            <span class="nb">open</span><span class="p">(</span><span class="n">concat_tree_name_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o2</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
                    <span class="n">o1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">o2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="n">f</span><span class="p">)</span>

        <span class="c1"># Use IQ-tree to perform topology tests.</span>
        <span class="n">topo_test_output_prefix</span> <span class="o">=</span> <span class="n">concat_tree_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topo_test&#39;</span> 
        <span class="n">topo_test_output_fp</span> <span class="o">=</span> <span class="n">concat_tree_file</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_topo_test.iqtree&#39;</span> 
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phylip_filepath</span><span class="p">,</span> <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span> <span class="s1">&#39;-n&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;-z&#39;</span><span class="p">,</span> <span class="n">concat_tree_file</span><span class="p">,</span> <span class="s1">&#39;-zb&#39;</span><span class="p">,</span> <span class="s1">&#39;10000&#39;</span><span class="p">,</span> <span class="s1">&#39;-au&#39;</span><span class="p">,</span> <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;-pre&#39;</span><span class="p">,</span>
            <span class="n">topo_test_output_prefix</span><span class="p">])</span>

        <span class="c1"># Parse IQ-tree output to get results of topology test.</span>
        <span class="n">data_line</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+ +-\d+\.\d+ +\d+\.\d+ +&#39;</span><span class="p">)</span>
        <span class="n">space_char</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39; +&#39;</span><span class="p">)</span>
        <span class="n">topo_test_res_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">topo_test_output_fp</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_line</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                    <span class="c1"># Parse info from line in IQ-tree output file.</span>
                    <span class="n">parsed_tree_info_list</span> <span class="o">=</span> <span class="n">space_char</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">)</span>
                    <span class="n">tree_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">original_tree_fp</span> <span class="o">=</span> <span class="n">alt_tree_files</span><span class="p">[</span><span class="n">tree_num</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">logL</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">deltaL</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1">#            bp_RELL = float(parsed_tree_info_list[3])</span>
        <span class="c1">#            p_KH = float(parsed_tree_info_list[5])</span>
        <span class="c1">#            p_SH = float(parsed_tree_info_list[7])</span>
        <span class="c1">#            c_ELW = float(parsed_tree_info_list[9])</span>
                    <span class="n">p_AU</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span>
                    <span class="n">accept_reject</span> <span class="o">=</span> <span class="n">parsed_tree_info_list</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
        <span class="c1">#            # Add info to dict.</span>
                    <span class="n">topo_test_res_dict</span><span class="p">[</span><span class="n">tree_num</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;original_tree_fp&#39;</span><span class="p">:</span> <span class="n">original_tree_fp</span><span class="p">,</span>
                            <span class="s1">&#39;logL&#39;</span><span class="p">:</span> <span class="n">logL</span><span class="p">,</span>
                            <span class="s1">&#39;deltaL&#39;</span><span class="p">:</span> <span class="n">deltaL</span><span class="p">,</span>
                            <span class="s1">&#39;p_AU&#39;</span><span class="p">:</span> <span class="n">p_AU</span><span class="p">,</span>
                            <span class="s1">&#39;accept_reject&#39;</span><span class="p">:</span> <span class="n">accept_reject</span>
                            <span class="p">}</span>

        <span class="c1">## Write info to summary spreadsheet file.</span>
        <span class="c1">#with open(summary_csv_fp, &#39;a&#39;) as o:</span>
        <span class="c1">#    num_keys = str(len(topo_test_res_dict.keys()))</span>
        <span class="c1">#    key_num = 0</span>
        <span class="c1">#    for key in sorted(topo_test_res_dict.keys(), key=lambda x:\</span>
        <span class="c1">#            topo_test_res_dict[x][1], reverse=True):</span>
        <span class="c1">#        key_num += 1</span>
        <span class="c1">#        info_tuple = topo_test_res_dict[key]</span>
        <span class="c1">#        # Assemble info to write to spreadsheet.</span>
        <span class="c1">#        relative_tree_path = info_tuple[0].replace(os.path.dirname(os.path.dirname(info_tuple[0])), &#39;&#39;)</span>
        <span class="c1">#        orig_align_file = os.path.basename(alignment)</span>
        <span class="c1">#        orig_tree_file = os.path.basename(tree)</span>
        <span class="c1">#        logL = str(info_tuple[1])</span>
        <span class="c1">#        bp_RELL = str(info_tuple[2])</span>
        <span class="c1">#        p_KH = str(info_tuple[3])</span>
        <span class="c1">#        p_SH = str(info_tuple[4])</span>
        <span class="c1">#        c_ELW = str(info_tuple[5])</span>
        <span class="c1">#        p_AU = str(info_tuple[6])</span>

        <span class="c1">#        # Apply a consensus approach to determine whether to accept or</span>
        <span class="c1">#        # reject topologies.</span>
        <span class="c1">#        accept_reject = &#39;+&#39;</span>
        <span class="c1">#        consensus_num = 0</span>
        <span class="c1">#        if float(bp_RELL) &lt;= 0.05:</span>
        <span class="c1">#            consensus_num += 1</span>
        <span class="c1">#        if float(p_KH) &lt;= 0.05:</span>
        <span class="c1">#            consensus_num += 1</span>
        <span class="c1">#        if float(p_SH) &lt;= 0.05:</span>
        <span class="c1">#            consensus_num += 1</span>
        <span class="c1">#        if float(c_ELW) &lt;= 0.05:</span>
        <span class="c1">#            consensus_num += 1</span>
        <span class="c1">#        if float(p_AU) &lt;= 0.05:</span>
        <span class="c1">#            consensus_num += 1</span>
        <span class="c1">#        if consensus_num &gt;= 4:</span>
        <span class="c1">#            accept_reject = &#39;-&#39;</span>

        <span class="c1">#        hypothesis_num = str(key_num) + &#39; of &#39; + num_keys</span>
        <span class="c1">#        relative_table_path = tablefp.replace(os.path.dirname(os.path.dirname(tablefp)), &#39;&#39;)</span>
        <span class="c1">#        type_seq_name =\</span>
        <span class="c1">#        os.path.dirname(info_tuple[0]).split(&#39;_def_seq_&#39;)[1].split(&#39;.C_&#39;)[0]</span>

        <span class="c1">#        # Get clade name.</span>
        <span class="c1">#        clade_name = get_clade_name_from_model(type_seq_name, type_seqs)</span>

        <span class="c1">#        masked_ali_file = os.path.join(outdirpath1,&#39;*mask.C.nex&#39;).replace(os.path.dirname(outdirpath1), &#39;&#39;)</span>

        <span class="c1">#        # Write info line to spreadsheet.</span>
        <span class="c1">#        info_line = &#39;,&#39;.join([model,</span>
        <span class="c1">#                              orig_align_file, #0</span>
        <span class="c1">#                              orig_tree_file, #1</span>
        <span class="c1">#                              subs_model, #2</span>
        <span class="c1">#                              additional_seq_orig_name, #3</span>
        <span class="c1">#                              hypothesis_num, #4</span>
        <span class="c1">#                              type_seq_name, #5</span>
        <span class="c1">#                              clade_name, #6</span>
        <span class="c1">#                              logL,  #7</span>
        <span class="c1">#                              bp_RELL, #8</span>
        <span class="c1">#                              p_KH, #8A</span>
        <span class="c1">#                              p_SH, #8B</span>
        <span class="c1">#                              c_ELW, #8C</span>
        <span class="c1">#                              p_AU, #8D</span>
        <span class="c1">#                              accept_reject,</span>
        <span class="c1">#                              masked_ali_file, #10</span>
        <span class="c1">#                              relative_table_path, #11</span>
        <span class="c1">#                              &#39;Trimmed input alignment file&#39;, #12</span>
        <span class="c1">#                              &#39;Constraint tree file&#39;, #13</span>
        <span class="c1">#                              &#39;Starting tree file&#39;, #14</span>
        <span class="c1">#                              relative_tree_path, #15</span>
        <span class="c1">#                              &#39;\n&#39;</span>
        <span class="c1">#                              ])</span>
        <span class="c1">#        o.write(info_line)</span>


        <span class="c1"># ************* Get topology string with clade names representing</span>
        <span class="c1"># clades. eg, (Syb, VAMP7, (YKT6, Sec22)).</span>
        
        <span class="c1"># Summarize results in a .csv file with the following information for</span>
        <span class="c1"># each alternative: topology (in newick format), logL, deltaL, p-AU,</span>
        <span class="c1"># accept (+) or reject (-).</span>


    <span class="c1"># Print prompt to run scripts to do tree searches using constraints.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span><span class="s2">Now use cc_constrained_mb.sh and</span>
<span class="s2">    cc_constrained_iqtree_ufboot_and_alrt.sh scripts to set up constrained tree</span>
<span class="s2">    searches to run on computecanada.&quot;&quot;&quot;</span><span class="p">)</span></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Lael D. Barlow.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>