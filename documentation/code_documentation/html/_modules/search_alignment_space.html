
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>search_alignment_space &#8212; amoebae 0.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for search_alignment_space</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright 2018 Lael D. Barlow</span>
<span class="c1"># </span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1"># </span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># </span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># </span>

<span class="sd">&quot;&quot;&quot;Contains functions for searching for alignments that support given tree</span>
<span class="sd">topologies (comparing alternative topologies).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">settings</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">statistics</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">module_amoebae_trim_nex</span> <span class="k">import</span> <span class="n">trim_nex</span>
<span class="kn">from</span> <span class="nn">module_paralogue_counter</span> <span class="k">import</span> <span class="n">get_seq_obj_from_srch_res_csv_info</span>
<span class="kn">import</span> <span class="nn">module_amoebae_column_header_lists</span>
<span class="kn">from</span> <span class="nn">module_amoebae_phylo_clas</span> <span class="k">import</span> <span class="n">ModelInfoFromCSV</span><span class="p">,</span>\
<span class="n">get_clade_name_from_model</span><span class="p">,</span> <span class="n">code_names_in_ali</span><span class="p">,</span> <span class="n">quote_tree</span><span class="p">,</span> <span class="n">code_tree</span><span class="p">,</span>\
<span class="n">uncode_tree</span><span class="p">,</span> <span class="n">uncode_tree_obj</span>
<span class="kn">from</span> <span class="nn">module_paralogue_counter</span> <span class="k">import</span> <span class="n">add_seq_to_alignment3</span>
<span class="kn">from</span> <span class="nn">module_amoebae_select_seqs</span> <span class="k">import</span> <span class="n">get_ml_tree_branch_lengths</span>
<span class="kn">from</span> <span class="nn">module_amoebae</span> <span class="k">import</span> <span class="n">find_input_file_in_parent_directory</span>

<span class="c1"># If running on computecanada, set Qt to offscreen mode so that it works on clusters.</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="n">graham_node</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;node=&#39;gra\d+&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="s1">&#39;computecanada&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">platform</span><span class="o">.</span><span class="n">uname</span><span class="p">())</span> <span class="ow">or</span>\
    <span class="n">graham_node</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">platform</span><span class="o">.</span><span class="n">uname</span><span class="p">()))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;QT_QPA_PLATFORM&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;offscreen&#39;</span>

<span class="c1">#from module_amoebae_select_seqs import get_clade_name_from_model2,\</span>
<span class="c1">#get_nodes_of_interest, get_list_of_leaf_names_for_node, TaxonomicInfo,\</span>
<span class="c1">#get_taxonomic_info, define_nodestyles_dict_for_colourcoding,\</span>
<span class="c1">#define_textface_for_labeling_stem, get_corresponding_node,\</span>
<span class="c1">#get_ml_tree_branch_lengths, get_branch_length_info, reduce_alignment</span>


<span class="c1"># Import functions for working with sequences, alignments, and trees.</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">AlignIO</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="k">import</span> <span class="n">SeqIO</span>
<span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="k">import</span> <span class="n">IUPAC</span><span class="p">,</span> <span class="n">Gapped</span>
<span class="kn">from</span> <span class="nn">module_afa_to_nex</span> <span class="k">import</span> <span class="n">delete_extra_mesquite_lines</span><span class="p">,</span> <span class="n">afa_to_nex</span><span class="p">,</span> <span class="n">nex_to_afa</span><span class="p">,</span> <span class="n">nex_to_phylip</span>
<span class="kn">from</span> <span class="nn">Bio.Align</span> <span class="k">import</span> <span class="n">MultipleSeqAlignment</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="k">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="k">import</span> <span class="n">SeqRecord</span>
<span class="kn">from</span> <span class="nn">ete3</span> <span class="k">import</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">AttrFace</span><span class="p">,</span> <span class="n">TreeStyle</span><span class="p">,</span> <span class="n">NodeStyle</span><span class="p">,</span> <span class="n">TextFace</span>

<span class="c1"># Define classes.</span>

<div class="viewcode-block" id="TaxonomicInfo"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.TaxonomicInfo">[docs]</a><span class="k">class</span> <span class="nc">TaxonomicInfo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Class for storing taxonomic info.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">superbranch</span><span class="p">,</span> <span class="n">supergroup</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">species</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">superbranch</span> <span class="o">=</span> <span class="n">superbranch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supergroup</span> <span class="o">=</span> <span class="n">supergroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">=</span> <span class="n">group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span></div>




<span class="c1"># Define functions.</span>


<div class="viewcode-block" id="trim_one_column_from_alignment"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.trim_one_column_from_alignment">[docs]</a><span class="k">def</span> <span class="nf">trim_one_column_from_alignment</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">,</span> <span class="n">column_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a nexus alignment file path and remove column at a given index</span>
<span class="sd">    (first column has index 0).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">alignment2</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="c1"># Parse input alignment file.</span>
        <span class="n">alignment_obj</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
        <span class="c1"># Record input alignment length.</span>
        <span class="n">len1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alignment_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="c1"># Remove relevant column from alignment object.</span>
        <span class="n">alignment_obj2</span> <span class="o">=</span> <span class="n">alignment_obj</span><span class="p">[:,</span> <span class="p">:</span><span class="n">column_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">alignment_obj</span><span class="p">[:,</span> <span class="n">column_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># Check that the alignment length is shorter by one column.</span>
        <span class="n">len2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alignment_obj2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">len1</span> <span class="o">-</span> <span class="n">len2</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># Write modified alignment object to output file path.</span>
        <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">alignment_obj2</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_taxa_represented_in_clade"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_taxa_represented_in_clade">[docs]</a><span class="k">def</span> <span class="nf">get_taxa_represented_in_clade</span><span class="p">(</span><span class="n">clade</span><span class="p">,</span> <span class="n">ml_tree_info_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a list of taxonomic terms currently represented in the clade.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">taxa_represented</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span>\
    <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">][</span><span class="s1">&#39;seq names by descending length&#39;</span><span class="p">]:</span>
        <span class="c1"># Get species name from sequence name.</span>
        <span class="c1">#species_name = seqname.replace(&#39;__&#39;, &#39; &#39;).replace(&#39;_&#39;, &#39; &#39;).split(&#39; &#39;, 1)[1]</span>
        <span class="n">species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>
        <span class="c1"># Get taxonomic information for species name from info csv file.</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
        <span class="c1"># Add taxon names to taxa represented.</span>
        <span class="n">taxa_represented</span> <span class="o">=</span> <span class="n">taxa_represented</span>\
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">ti</span><span class="o">.</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">supergroup</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">species</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">taxa_represented</span></div>


<div class="viewcode-block" id="get_species_name_from_seq_id"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_species_name_from_seq_id">[docs]</a><span class="k">def</span> <span class="nf">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a fasta sequence id/header/taxon name for one of the sequences in</span>
<span class="sd">    an alignment or FASTA file, and return the species name that it contains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#species_name = seq_id.replace(&#39;__&#39;, &#39; &#39;).replace(&#39;_&#39;, &#39; &#39;).split(&#39; &#39;, 1)[1]</span>
    <span class="c1">#print(&#39;WARNING: Remember to update parsing of species names for new trees.&#39;)</span>
    <span class="c1"># For parsing new sequence ids:</span>
    <span class="n">species_name</span> <span class="o">=</span> <span class="n">seq_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">species_name</span></div>


<div class="viewcode-block" id="get_names_of_dispensable_seqs_in_clade"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_names_of_dispensable_seqs_in_clade">[docs]</a><span class="k">def</span> <span class="nf">get_names_of_dispensable_seqs_in_clade</span><span class="p">(</span><span class="n">clade</span><span class="p">,</span>
                                           <span class="n">ml_tree_info_dict</span><span class="p">,</span>
                                           <span class="n">essential_taxa</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a clade name and a dictionary of info for the tree that it came</span>
<span class="sd">    from, and determine which ones are dispensable taxonomically.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a list of taxonomic terms currently represented in the clade.</span>
    <span class="n">taxa_represented</span> <span class="o">=</span> <span class="n">get_taxa_represented_in_clade</span><span class="p">(</span><span class="n">clade</span><span class="p">,</span> <span class="n">ml_tree_info_dict</span><span class="p">)</span>

    <span class="c1">## Print.</span>
    <span class="c1">#print(&#39;\n--------------------------------&#39;)</span>
    <span class="c1">#print(&#39;BEGIN get_names_of_dispensable_seqs_in_clade function call\n&#39;)</span>

    <span class="c1">#print(&#39;Essential taxa:&#39;)</span>
    <span class="c1">#for i in essential_taxa:</span>
    <span class="c1">#    print(i)</span>

    <span class="c1">#print(&#39;\nTaxa represented already:&#39;)</span>
    <span class="c1">#for i in list(set(taxa_represented)):</span>
    <span class="c1">#    print(i)</span>

    <span class="c1">#print(&#39;\nEssential taxa represented already, but only once:&#39;)</span>
    <span class="c1">#for i in list(set(taxa_represented)):</span>
    <span class="c1">#    if i in essential_taxa:</span>
    <span class="c1">#        if taxa_represented.count(i) == 1:</span>
    <span class="c1">#            print(i)</span>

    <span class="c1">#print(&#39;\nDecisions for each sequence:&#39;)</span>

    <span class="c1"># Initiate list of names for dispensable sequences.</span>
    <span class="n">names_of_dispensable_seqs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over all the sequence names in the clade.</span>
    <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span>\
    <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">][</span><span class="s1">&#39;seq names by descending length&#39;</span><span class="p">]:</span>

        <span class="c1"># Get species name from sequence name.</span>
        <span class="n">species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

        <span class="c1"># Get taxonomic information for species name from info csv file.</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
        <span class="n">ti_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">supergroup</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>

        <span class="c1"># Determine whether any of the taxonomy terms are in the essential</span>
        <span class="c1"># list.</span>
        <span class="n">essential_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ti_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">essential_taxa</span><span class="p">:</span>
                <span class="n">essential_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Check whether any of the terms appear in the taxa_represented list</span>
        <span class="c1"># only once (if so then the sequence is essential).</span>
        <span class="n">seq_is_essential</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">essential_terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">taxa_represented</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">seq_is_essential</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Add to list if not essential.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seq_is_essential</span><span class="p">:</span>
            <span class="n">names_of_dispensable_seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

        <span class="c1">#x = &#39;Essential&#39;</span>
        <span class="c1">#if not seq_is_essential:</span>
        <span class="c1">#    x = &#39;Dispensable&#39;</span>
        <span class="c1">#print(&#39;, &#39;.join([seqname, species_name] + ti_list + [x]))</span>
        <span class="c1">#print(seqname)</span>
        <span class="c1">#print(&#39;\tessential terms: &#39; + &#39;, &#39;.join(essential_terms))</span>
        <span class="c1">#print(&#39;\t&#39; + x)</span>

    <span class="c1">## Print.</span>
    <span class="c1">#print(&#39;\nDispensable seqs:&#39;)</span>
    <span class="c1">#for i in names_of_dispensable_seqs:</span>
    <span class="c1">#    print(i)</span>
    <span class="c1">#print(&#39;\nEND get_names_of_dispensable_seqs_in_clade function call&#39;)</span>
    <span class="c1">#print(&#39;--------------------------------\n&#39;)</span>

    <span class="c1"># Return list of sequence names for dispensable sequences.</span>
    <span class="k">return</span> <span class="n">names_of_dispensable_seqs</span></div>


<div class="viewcode-block" id="new_seq_in_clade_dispensable"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.new_seq_in_clade_dispensable">[docs]</a><span class="k">def</span> <span class="nf">new_seq_in_clade_dispensable</span><span class="p">(</span><span class="n">essential_taxa</span><span class="p">,</span>
                                 <span class="n">clade</span><span class="p">,</span>
                                 <span class="n">additional_seq_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a list of essential taxonomic terms, a list of taxa represented in</span>
<span class="sd">    a clade with an added sequence (including from the added sequence), and the</span>
<span class="sd">    sequence ID of the sequence that was added. Return true if the additional</span>
<span class="sd">    sequences is taxonomically dispensable to the clade.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate variable for determining whether the added sequence is</span>
    <span class="c1"># dispensable.</span>
    <span class="n">new_seq_dispensable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Iterate over all the sequence names in the clade.</span>
    <span class="n">taxonomic_terms_in_clade</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">clade</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]:</span>
        <span class="c1"># Get species name from sequence name.</span>
        <span class="n">species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

        <span class="c1"># Get taxonomic information for species name from info csv file.</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
        <span class="n">ti_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">supergroup</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>

        <span class="c1"># Add to list of taxa represented.</span>
        <span class="n">taxonomic_terms_in_clade</span> <span class="o">=</span> <span class="n">taxonomic_terms_in_clade</span> <span class="o">+</span> <span class="n">ti_list</span>

    <span class="c1"># Get species name from sequence name.</span>
    <span class="n">added_species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">additional_seq_id</span><span class="p">)</span>

    <span class="c1"># Get taxonomic information for species name from info csv file.</span>
    <span class="n">added_species_ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">added_species_name</span><span class="p">)</span>
    <span class="n">added_species_ti_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">supergroup</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>

    <span class="c1"># Determine whether any of the taxonomy terms for the added species are</span>
    <span class="c1"># in the essential list.</span>
    <span class="n">essential_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">added_species_ti_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">essential_taxa</span><span class="p">:</span>
            <span class="n">essential_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Check whether any of the terms appear in the taxa_represented list</span>
    <span class="c1"># only once (if so then the sequence is essential).</span>
    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">essential_terms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">taxonomic_terms_in_clade</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_seq_dispensable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>

    <span class="c1"># Return result.</span>
    <span class="k">return</span> <span class="n">new_seq_dispensable</span> </div>


<div class="viewcode-block" id="get_new_type_seqs_dict"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_new_type_seqs_dict">[docs]</a><span class="k">def</span> <span class="nf">get_new_type_seqs_dict</span><span class="p">(</span><span class="n">seqname</span><span class="p">,</span> <span class="n">ml_tree_info_dict</span><span class="p">,</span> <span class="n">type_seqs_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a type sequence name dictionary and a sequence name, and return a</span>
<span class="sd">    new dictionary with the sequence replaced with another sequence if</span>
<span class="sd">    necessary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy the input dict.</span>
    <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="n">type_seqs_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Determine whether the seqname is one of the type seqnames in the dict.</span>
    <span class="n">is_type_seq</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">type_seqs_dict2</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">seqname</span> <span class="o">==</span> <span class="n">type_seqs_dict2</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
            <span class="n">is_type_seq</span> <span class="o">=</span> <span class="kc">True</span>
    
            <span class="c1"># If it is a type seq, then replace it with another sequence name.</span>
            <span class="c1"># Identify an alternative type sequence for the same</span>
            <span class="c1"># (current) clade.</span>
            <span class="k">for</span> <span class="n">seqname2</span> <span class="ow">in</span>\
            <span class="nb">reversed</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span>\
            <span class="p">[</span><span class="s1">&#39;seq names by descending length&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">seqname2</span> <span class="o">!=</span> <span class="n">seqname</span><span class="p">:</span>
                    <span class="c1"># Change type seq for clade to a different sequence.</span>
                    <span class="n">type_seqs_dict2</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span> <span class="o">=</span> <span class="n">seqname2</span>
    
    <span class="c1"># Return the new dict.</span>
    <span class="k">return</span> <span class="n">type_seqs_dict2</span></div>


<div class="viewcode-block" id="reduce_alignment"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.reduce_alignment">[docs]</a><span class="k">def</span> <span class="nf">reduce_alignment</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">,</span> <span class="n">output_alignment_file</span><span class="p">,</span> <span class="n">removal_name_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take file path for an existing alignment and an output alignment, and</span>
<span class="sd">    a list of sequence names for removal. Write the reduced alignment to the</span>
<span class="sd">    output path in nexus format. Note: This function assumes that the names in</span>
<span class="sd">    the removal lit and the alignment are all either coded or uncoded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that at least one sequence name listed for removal.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">removal_name_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Remove extra mesquite lines if present.</span>
    <span class="n">delete_extra_mesquite_lines</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">)</span>

    <span class="c1"># Get list of names of sequences in alignment.</span>
    <span class="n">names_in_alignment</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)]</span>

    <span class="c1"># Check number of sequences in input alignment.</span>
    <span class="n">num_seqs1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_in_alignment</span><span class="p">)</span>

    <span class="c1"># Check that all the sequences listed for removal are actually in the input</span>
    <span class="c1"># alignment.</span>
    <span class="c1">#names_in_alignment = [x.replace(&#39;-&#39;, &#39;_&#39;) for x in names_in_alignment]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">removal_name_list</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names_in_alignment</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Sequence </span><span class="si">%s</span><span class="s2"> cannot be identified</span>
<span class="s2">        in the alignment </span><span class="si">%s</span><span class="s2"> and therefore cannot be removed.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">))</span>
        <span class="c1"># If this happens, then maybe there are characters that are in the</span>
        <span class="c1"># alignment that were changed or removed when parsing the resulting</span>
        <span class="c1"># tree (&#39;.&#39; or &#39;-&#39; ?). This shouldn&#39;t be a problem with the new trees.</span>
    <span class="c1">#assert\</span>
    <span class="c1">#len(list(set(removal_name_list).intersection(set(names_in_alignment))))\</span>
    <span class="c1">#== len(removal_name_list)</span>

    <span class="c1"># Make a copy of the input alignment file with the listed sequences</span>
    <span class="c1"># removed.</span>
    <span class="n">coded_seqs_to_not_remove_from_dataset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alignment_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_alignment_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
        <span class="c1">#print(&#39;number of seqs in original alignment&#39;)</span>
        <span class="c1">#print(len(alignment))</span>
        <span class="n">alignment2</span> <span class="o">=</span> <span class="n">MultipleSeqAlignment</span><span class="p">([])</span>
        <span class="c1">#print(&#39;number of seqs in alignment2:&#39;)</span>
        <span class="c1">#print(len(alignment2))</span>
        <span class="c1">#print(&#39;Removing sequences from alignment.&#39;)</span>
        <span class="c1">#ali_len = len(alignment)</span>
        <span class="n">removed_a_seq</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">inum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alignment</span><span class="p">:</span>
            <span class="n">inum</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removal_name_list</span><span class="p">:</span>
                <span class="n">alignment2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alignment</span><span class="p">[</span><span class="n">inum</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">removed_a_seq</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">assert</span> <span class="n">removed_a_seq</span>

        <span class="n">alignment3</span> <span class="o">=</span>\
        <span class="n">MultipleSeqAlignment</span><span class="p">(</span><span class="n">alignment2</span><span class="p">[:,:])</span>
        <span class="c1">#print(&#39;number of seqs in alignment3:&#39;)</span>
        <span class="c1">#print(len(alignment3))</span>

        <span class="c1"># Get list of sequences in new alignment.</span>
        <span class="n">ids_in_alignment3</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alignment3</span><span class="p">:</span>
            <span class="n">ids_in_alignment3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="c1"># Write reduced alignment.</span>
        <span class="c1">#print(&#39;Writing modified alignment file:\n\t%s&#39; % o.name)</span>
        <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">alignment3</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>

    <span class="c1"># Check that number of sequences in new alignment is one less than in the</span>
    <span class="c1"># input alignment.</span>
    <span class="n">num_seqs2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">output_alignment_file</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">num_seqs2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">num_seqs1</span></div>


<div class="viewcode-block" id="write_constraint_tree_without_extra_parentheses"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.write_constraint_tree_without_extra_parentheses">[docs]</a><span class="k">def</span> <span class="nf">write_constraint_tree_without_extra_parentheses</span><span class="p">(</span><span class="n">ete3_tree_obj</span><span class="p">,</span> <span class="n">tree_outpath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take an ETE3 TreeNode object and write to a file, but ensure that there</span>
<span class="sd">    are not double outer parentheses in the output newick tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Write tree object to a newick file without any branch info.</span>
    <span class="n">ete3_tree_obj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">tree_outpath</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>

    <span class="c1"># Check whether there are double outer parentheses.</span>
    <span class="n">double_outer_parentheses</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree_outpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="n">newick_tree_string</span> <span class="o">=</span> <span class="n">infh</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">newick_tree_string</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;((&#39;</span><span class="p">):</span>
            <span class="n">last_parenthesis_position</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newick_tree_string</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">string_position_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">open_parenthesis_count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">newick_tree_string</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">string_position_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">string_position_num</span> <span class="o">==</span> <span class="n">last_parenthesis_position</span><span class="p">:</span>
                    <span class="n">double_outer_parentheses</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="c1"># This perhaps assumes that there are no parentheses in the</span>
                <span class="c1"># taxon names.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
                    <span class="n">open_parenthesis_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                    <span class="n">open_parenthesis_count</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">open_parenthesis_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

    <span class="c1"># If necessary, modify the newick tree string in the output file.</span>
    <span class="k">if</span> <span class="n">double_outer_parentheses</span><span class="p">:</span>
        <span class="n">newick_tree_string</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree_outpath</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
            <span class="n">newick_tree_string</span> <span class="o">=</span> <span class="n">infh</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree_outpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">newick_tree_string_without_extra_parentheses</span> <span class="o">=</span>\
                    <span class="n">newick_tree_string</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newick_tree_string_without_extra_parentheses</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_seq_placement_in_tree"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_seq_placement_in_tree">[docs]</a><span class="k">def</span> <span class="nf">get_seq_placement_in_tree</span><span class="p">(</span><span class="n">ml_placement_tree_path</span><span class="p">,</span>
                              <span class="n">seq_to_add</span><span class="p">,</span>
                              <span class="n">type_seqs_dict</span><span class="p">,</span>
                              <span class="n">essential_taxa</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse a tree to find out where a sequence was placed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parse tree using ete3.</span>
    <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">ml_placement_tree_path</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">## Convert names in tree back to original names.</span>
    <span class="c1">#uncode_tree_obj(t1, outtablefp)</span>

    <span class="c1">## Define name for tree without branch lengths.</span>
    <span class="c1">#simple_tree = tree_file_path.rsplit(&#39;_&#39;, 1)[0] + &#39;_TEMP2&#39; </span>

    <span class="c1">## Write simple tree to a new file </span>
    <span class="c1">#t1.write(format=9, outfile=simple_tree)</span>

    <span class="c1">## Parse simple tree.</span>
    <span class="c1">#t2 = Tree(simple_tree)</span>

    <span class="c1"># Print simple tree.</span>
    <span class="c1">#print(&#39;ML tree:&#39;)</span>
    <span class="c1">#print(t1)</span>


    <span class="c1"># Make a copy of the tree object.</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Get list of &quot;type&quot; sequences from input.</span>
    <span class="n">type_seq_list</span> <span class="o">=</span> <span class="n">type_seqs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="c1"># For each &quot;type&quot; sequence, traverse all nodes and find the node with</span>
    <span class="c1"># the largest number of child nodes that are leaf (terminal) nodes,</span>
    <span class="c1"># containing the &quot;type&quot; sequence of interest, but not containing any of</span>
    <span class="c1"># the other &quot;type&quot; sequences.</span>
    <span class="n">ts_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
        <span class="n">ts_num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="c1"># Root on another &quot;type&quot; sequence for the first type sequence in</span>
            <span class="c1"># the list to get whole clade, then root the tree on the ancestor</span>
            <span class="c1"># node of that first clade.</span>

            <span class="c1"># Get a node name for a node corresponding to a different</span>
            <span class="c1"># &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ts</span><span class="p">:</span>
                    <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>

            <span class="c1"># Get node corresponding to a different &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_type_seq_node_name</span><span class="p">:</span>
                    <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">break</span>

            <span class="c1"># Root on the other &quot;type&quot; sequence node.</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">other_type_seq_node</span><span class="p">)</span>

            <span class="c1">#print(&#39;\n\n\nTree rooted on a type sequence other than the first type sequence.&#39;)</span>
            <span class="c1">#print(t2)</span>

        <span class="k">elif</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Root on the first &quot;type&quot; sequence node for all subsequent</span>
            <span class="c1"># clades.</span>
            <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="n">leaf_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_type_seq_node_name</span><span class="p">:</span>
                        <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">first_type_seq_node</span><span class="p">)</span>
            <span class="c1">#print(&#39;\n\n\nTree re-rooted on first type sequence:&#39;)</span>
            <span class="c1">#print(t2)</span>


        <span class="c1"># Make a copy of the tree topology to work with for each run</span>
        <span class="c1"># through this loop.</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Make a list of nodes that contain type seq, but not any others. #</span>
        <span class="c1"># SEPARATE</span>
        <span class="n">nodes_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="c1"># Search in nodes that contain the type sequence.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts</span><span class="p">):</span>
                <span class="c1"># Search in nodes that don&#39;t contain other type sequences.</span>
                <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">ts2</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ts2</span> <span class="o">==</span> <span class="n">ts</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts2</span><span class="p">):</span>
                            <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_other_type_seqs</span><span class="p">:</span>
                    <span class="c1"># Add nodes of interest to list.</span>
                    <span class="n">nodes_of_interest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># find the node with the most child leaf nodes.</span>
        <span class="c1">#node_num = 0</span>
        <span class="c1">#for node in nodes_of_interest:</span>
        <span class="c1">#    node_num += 1 </span>
        <span class="c1">#    print(&#39;Node &#39; + str(node_num) + &#39; Number of leaves:  &#39; + str(len(node.get_leaves())))</span>
        <span class="c1">#    print(node)</span>
        <span class="n">node_w_most_leaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
        <span class="c1">#print(&#39;\n\nClade defined by sequence &#39; + ts + &#39;:&#39;)</span>
        <span class="c1">#print(node_w_most_leaves)</span>

        <span class="c1">#name_of_additional_seq = record.description</span>
        <span class="n">name_of_additional_seq</span> <span class="o">=</span> <span class="n">seq_to_add</span><span class="o">.</span><span class="n">id</span> <span class="c1">#record.id # + &#39; &#39; + record.description</span>

        <span class="c1">#print(&#39;\n\n\n&#39;)</span>
        <span class="c1">#print(name_of_additional_seq)</span>
        <span class="c1">#print(&#39;\n\n\n&#39;)</span>
        <span class="c1">#for i in [x.name for x in node_w_most_leaves.get_leaves()]:</span>
        <span class="c1">#    print(i)</span>
        <span class="c1">#print(&#39;\n\n\n&#39;)</span>

        <span class="k">if</span> <span class="n">name_of_additional_seq</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_w_most_leaves</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]:</span>
            <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="c1">#print(&#39;%s is in this clade.&#39; % name_of_additional_seq)</span>

            <span class="c1">## Make a list of taxonomic terms currently represented in the clade.</span>
            <span class="c1">#taxa_represented = get_taxa_represented_in_clade(node_w_most_leaves,</span>
            <span class="c1">#                                                 ml_tree_info_dict)</span>

            <span class="c1">## Get clade name for type seq name from type seqs dict.</span>
            <span class="c1">#clade_name = None</span>
            <span class="c1">#for c in type_seqs_dict.keys():</span>
            <span class="c1">#    if type_seqs_dict[c] ==\</span>
            <span class="c1">#    ts_that_additional_seq_was_placed_in:</span>
            <span class="c1">#        clade_name = c</span>
            <span class="c1">#        break</span>
            <span class="c1">#assert clade_name is not None</span>

            <span class="c1"># Determine which seqs in the clade are dispensable, considering their</span>
            <span class="c1"># taxonomic placement.</span>
            <span class="c1">#names_of_dispensable_seqs_in_clade =\</span>
            <span class="c1">#get_names_of_dispensable_seqs_in_clade(clade_name,</span>
            <span class="c1">#                                       ml_tree_info_dict,</span>
            <span class="c1">#                                       essential_taxa,</span>
            <span class="c1">#                                       taxa_represented) </span>
            <span class="n">additional_seq_dispensable</span> <span class="o">=</span>\
            <span class="n">new_seq_in_clade_dispensable</span><span class="p">(</span><span class="n">essential_taxa</span><span class="p">,</span>
                                         <span class="n">node_w_most_leaves</span><span class="p">,</span>
                                         <span class="n">seq_to_add</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

            <span class="c1"># Determine whether the additional sequence is dispensable</span>
            <span class="c1"># or not in the new clade.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">additional_seq_dispensable</span><span class="p">:</span>
                <span class="n">added_seq_adds_essential_taxon</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">new_seq_essential</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="c1"># Break the loop, because no other clades need to be</span>
            <span class="c1"># considered after the relevant clade has been identified.</span>
            <span class="k">break</span>

    <span class="c1"># Return the name of the type sequence of the clade that the sequence is</span>
    <span class="c1"># placed in.</span>
    <span class="k">return</span> <span class="n">ts_that_additional_seq_was_placed_in</span></div>


<div class="viewcode-block" id="modify_alignment_in_x_way"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.modify_alignment_in_x_way">[docs]</a><span class="k">def</span> <span class="nf">modify_alignment_in_x_way</span><span class="p">(</span><span class="n">previous_ali_tree_tuple</span><span class="p">,</span> <span class="n">mod_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modify an alignment (and associated tree) and return a tuple with all</span>
<span class="sd">    the same type of elements as the input tuple, except for the new</span>
<span class="sd">    alignment (and associated tree).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Unpack objects from input tuple.</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#print(&#39;tree:&#39;)</span>
    <span class="c1">#print(tree)</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">positions_attempted_to_remove</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">subs_model</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">type_seqs_dict</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">ml_tree_info_dict</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">seqs</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">seqs_attempted_to_remove</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">seqs_attempted_to_add</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
    <span class="n">essential_taxa</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
    <span class="n">new_seq_essential</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
    <span class="n">modified_clade_name</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>

    <span class="c1"># Check that the stop variable was not set to True in the last iteration.</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">stop</span>

    <span class="c1"># Define the current iteration number (for naming output files).</span>
    <span class="n">iteration2</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Define path to new alignment file.</span>
    <span class="n">alignment2</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iteration2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nex&#39;</span>

    <span class="c1"># Determine number of sequences in input alignment.</span>
    <span class="n">seqnames_in_alignment</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)]</span>
    <span class="n">num_seqs_in_alignment</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqnames_in_alignment</span><span class="p">)</span>

    <span class="c1"># Define path to new tree file.</span>
    <span class="n">tree2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignment2</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_newick.tre&#39;</span><span class="p">)</span>

    <span class="c1"># Determine number of sequences represented in the input tree.</span>
    <span class="n">seqnames_in_tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
    <span class="n">num_seqs_in_tree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqnames_in_tree</span><span class="p">)</span>

    <span class="c1"># Check that number of sequences in alignment and tree are the same.</span>
    <span class="k">assert</span> <span class="n">num_seqs_in_alignment</span> <span class="o">==</span> <span class="n">num_seqs_in_tree</span>

    <span class="c1">## Check that the sequence names in the alignment and the tree are the same.</span>
    <span class="c1">#print(&#39;Name in alignment\tName in tree&#39;)</span>
    <span class="c1">#for i, j in zip(sorted(seqnames_in_alignment), sorted(seqnames_in_tree)):</span>
    <span class="c1">#    print(i + &#39;\t&#39; + j)</span>
    <span class="c1">#    assert i == j, &quot;&quot;&quot;These sequence names should be the same.&quot;&quot;&quot;</span>

    <span class="c1"># Define output path for annotated tree image file.</span>
    <span class="n">annotated_tree_outpath2</span> <span class="o">=</span>\
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignment2</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_annotated_result.png&#39;</span><span class="p">)</span>

    <span class="c1"># Define output directory path.</span>
    <span class="n">outputdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">alignment2</span><span class="p">)</span>

    <span class="c1"># Initiate variable for new type sequence dictionary.</span>
    <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Initiate variable to store name of the clade that is modified here.</span>
    <span class="n">modified_clade_name2</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#############################################</span>
    <span class="c1">#############################################</span>
    <span class="c1"># This portion of the code is different depending on what type of</span>
    <span class="c1"># modification is needed:</span>

    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;remove_seqs&#39;</span><span class="p">:</span>
        <span class="c1"># Check that essential taxa were specified.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">essential_taxa</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No essential taxa are specified.&quot;&quot;&quot;</span>

        <span class="c1"># Determine what sequence to remove.</span>

        <span class="c1"># Set variables that won&#39;t be modified.</span>
        <span class="n">subs_model2</span> <span class="o">=</span> <span class="n">subs_model</span>
        <span class="n">positions_attempted_to_remove2</span> <span class="o">=</span> <span class="n">positions_attempted_to_remove</span>
        <span class="n">seqs_attempted_to_add2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_add</span>

        <span class="c1"># Initiate variables that will be modified later.</span>
        <span class="n">seqs_attempted_to_remove2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_remove</span>

        <span class="c1"># Determine the clade with the worst support.</span>
        <span class="c1">#clades_by_ascending_ratio = sorted(branch_length_info_dict.keys(),\</span>
        <span class="c1">#        key=lambda x: branch_length_info_dict[x][&#39;stem/branch ratio&#39;])</span>
        <span class="n">clade_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">clade_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">)</span>
        <span class="c1">#clades_by_ascending_support_measure =\</span>
        <span class="c1">#sorted(clade_list, key=lambda x: ml_tree_info_dict[x][&#39;alrt support&#39;])</span>
        <span class="n">clades_by_ascending_support_measure</span> <span class="o">=</span>\
        <span class="nb">sorted</span><span class="p">(</span><span class="n">clade_list</span><span class="p">,</span>\
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;stem/branch ratio&#39;</span><span class="p">])</span>

        <span class="n">removed_a_sequence</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clades_by_ascending_support_measure</span><span class="p">:</span>
            <span class="c1"># Determine which seqs in the clade are dispensable, considering their</span>
            <span class="c1"># taxonomic placement.</span>
            <span class="n">names_of_dispensable_seqs_in_clade</span> <span class="o">=</span>\
            <span class="n">get_names_of_dispensable_seqs_in_clade</span><span class="p">(</span><span class="n">clade</span><span class="p">,</span>
                                                   <span class="n">ml_tree_info_dict</span><span class="p">,</span>
                                                   <span class="n">essential_taxa</span><span class="p">,</span>
                                                   <span class="p">)</span> 
            <span class="c1">## Get list of sequence names in clade by descending order of branch</span>
            <span class="c1">## length (from the root of the clade).</span>
            <span class="c1">#seqnames = ml_tree_info_dict[clade][&#39;seq names by descending length&#39;]</span>

            <span class="c1"># Remove sequence names from the list that have already been removed</span>
            <span class="c1"># (and did not improve the tree).</span>
            <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="n">seqs_attempted_to_remove</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="n">names_of_dispensable_seqs_in_clade</span><span class="p">:</span>
                    <span class="n">names_of_dispensable_seqs_in_clade</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

            <span class="c1"># Iterate over sequence names in descending order of branch length.</span>
            <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="n">names_of_dispensable_seqs_in_clade</span><span class="p">:</span>
                <span class="c1"># Try removing the corresponding sequence from the</span>
                <span class="c1"># tree, and see whether it improves the branch length</span>
                <span class="c1"># ratios.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">removing sequence </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">seqname</span><span class="p">)</span>

                <span class="c1"># If the sequence is a type sequence, then you have to</span>
                <span class="c1"># choose another sequence in the clade as a replacement</span>
                <span class="c1"># type sequence.</span>
                <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="n">get_new_type_seqs_dict</span><span class="p">(</span><span class="n">seqname</span><span class="p">,</span>
                                                         <span class="n">ml_tree_info_dict</span><span class="p">,</span>
                                                         <span class="n">type_seqs_dict</span><span class="p">)</span>

                <span class="c1"># Remove seq from alignment.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Writing reduced alignment to &#39;</span> <span class="o">+</span>\
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment2</span><span class="p">))</span>
                <span class="n">reduce_alignment</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">,</span> <span class="p">[</span><span class="n">seqname</span><span class="p">])</span>


                <span class="c1"># Code alignment (get table file).???</span>

                <span class="c1"># Remove seq from parsed tree object, and</span>
                <span class="c1"># use that as a constraint tree.</span>
                <span class="c1"># Copy tree.</span>
                <span class="c1">#t2 = t1.copy()</span>
                <span class="c1">#t2 = Tree(tree, quoted_node_names=False)</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Whether quoted_node_names is true or false may be different for older trees.</span>

                <span class="c1"># Get a list of all node objects with the same name as the</span>
                <span class="c1"># sequence of interest.</span>
                <span class="n">seq_nodes</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">seqname</span><span class="p">)</span>

                <span class="c1"># Check that one and only one such node was found.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Sequence names in tree may not</span>
<span class="s2">                be formatted as expected.&quot;&quot;&quot;</span>

                <span class="c1"># Remove the node from the new tree object.</span>
                <span class="n">node_to_remove</span> <span class="o">=</span> <span class="n">seq_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">t2_len_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span>
                <span class="n">node_to_remove</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

                <span class="c1"># Check that a node was actually removed.</span>
                <span class="n">t2_len_after</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span>
                <span class="k">assert</span> <span class="n">t2_len_before</span> <span class="o">==</span> <span class="n">t2_len_after</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Write modified tree to a file.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Writing annotated tree to &#39;</span> <span class="o">+</span>\
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree2</span><span class="p">))</span>
                <span class="c1">#t2.write(outfile=tree2, format=9)</span>
                <span class="n">write_constraint_tree_without_extra_parentheses</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">tree2</span><span class="p">)</span>

                <span class="c1"># Add sequence name to list of sequences that have been removed. </span>
                <span class="n">seqs_attempted_to_remove2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

                <span class="c1"># Record name of clade that was modified.</span>
                <span class="n">modified_clade_name2</span> <span class="o">=</span> <span class="n">clade</span>

                <span class="c1"># Break the loop so that only one sequence gets removed per</span>
                <span class="c1"># iteration.</span>
                <span class="n">removed_a_sequence</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="c1"># Break this loop too, if a sequence was removed.</span>
            <span class="k">if</span> <span class="n">removed_a_sequence</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Check that a sequence was removed, if not then stop iterating.</span>
        <span class="k">if</span> <span class="n">removed_a_sequence</span><span class="p">:</span>
            <span class="c1"># Check that the output alignment has one less sequence than the</span>
            <span class="c1"># input alignment.</span>
            <span class="n">num_seqs_in_new_alignment</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment2</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">num_seqs_in_new_alignment</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">num_seqs_in_alignment</span>
            <span class="c1"># Check that the output tree has one less sequence than the input</span>
            <span class="c1"># tree.</span>
            <span class="n">num_seqs_in_new_tree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree2</span><span class="p">)</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()))</span>
            <span class="k">assert</span> <span class="n">num_seqs_in_new_tree</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">num_seqs_in_tree</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find a sequence to remove.&#39;</span><span class="p">)</span>
            <span class="c1"># Stop iterative calling of modify_seq_in_x_way function (at least</span>
            <span class="c1"># with the current modification type).</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>


    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;add_seqs&#39;</span><span class="p">:</span>
        <span class="c1"># Check that a file with sequences to try adding was specified.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No sequences provided as input.&quot;&quot;&quot;</span>

        <span class="c1"># Determine what sequence to add.</span>

        <span class="c1"># Set variables that won&#39;t be modified.</span>
        <span class="n">subs_model2</span> <span class="o">=</span> <span class="n">subs_model</span>
        <span class="n">positions_attempted_to_remove2</span> <span class="o">=</span> <span class="n">positions_attempted_to_remove</span>
        <span class="n">seqs_attempted_to_remove2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_remove</span>
        <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="n">type_seqs_dict</span>

        <span class="c1"># Initiate variables that will be modified later.</span>
        <span class="n">seqs_attempted_to_add2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_add</span>

        <span class="c1"># Initiate variable to indicate whether a sequence was found to add or</span>
        <span class="c1"># not.</span>
        <span class="n">added_a_sequence</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Initiate variables to indicate whether the new tree and alignment are</span>
        <span class="c1"># usable (if the added sequence was placed into a clade of interest or</span>
        <span class="c1"># not).</span>
        <span class="n">ali_and_tree_usable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">any_ali_and_tree_usable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Initiate a variable to indicate whether the added sequence adds an</span>
        <span class="c1"># essential taxon that was missing in the clade before (if it does,</span>
        <span class="c1"># then even if the resulting tree yields lower support then it still</span>
        <span class="c1"># might be considered better).</span>
        <span class="n">added_seq_adds_essential_taxon</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Determine which sequences, if any, could be added to the tree.</span>
        <span class="n">seqnames_in_tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
        <span class="n">all_seqnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seqs</span><span class="p">]</span> 
        <span class="n">seqnames_to_be_added</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seqname</span> <span class="ow">in</span> <span class="n">all_seqnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seqname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seqs_attempted_to_add2</span> <span class="o">+</span> <span class="n">seqnames_in_tree</span><span class="p">:</span>
                <span class="c1"># Add sequence name to list.</span>
                <span class="n">seqnames_to_be_added</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqname</span><span class="p">)</span>

        <span class="c1"># Make a list of taxonomic terms currently represented in the clade.</span>
        <span class="c1">#taxa_represented = get_taxa_represented_in_clade(clade, ml_tree_info_dict)</span>
        <span class="c1"># *** ToDo: Add functionality to add sequences with taxonomic terms in</span>
        <span class="c1"># the essential taxa list that are missing in the taxa_represented</span>
        <span class="c1"># list.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqnames_to_be_added</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find a sequence to add.&#39;</span><span class="p">)</span>
            <span class="c1"># Stop iterative calling of modify_seq_in_x_way function (at least</span>
            <span class="c1"># with the current modification type).</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Shuffle the sequences if it&#39;s the first iteration.</span>
            <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Define a seed for the random shuffle of sequences so that it</span>
                <span class="c1"># can be reproduced.</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="mi">12345</span>
                <span class="c1"># Shuffle the list of sequences deterministically</span>
                <span class="c1"># (reproducibly).</span>
                <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span>
            
            <span class="c1"># Loop over candidate sequences and try adding them to the tree.</span>
            <span class="n">seq_to_add</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">seqs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">seqnames_to_be_added</span><span class="p">:</span>
                    <span class="n">seq_to_add</span> <span class="o">=</span> <span class="n">seq</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Try another sequence in the list.</span>
                    <span class="k">continue</span>

                <span class="k">assert</span> <span class="n">seq_to_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Adding sequence &#39;</span> <span class="o">+</span> <span class="n">seq_to_add</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

                <span class="c1"># Add to list of sequences added to to the tree.</span>
                <span class="n">seqs_attempted_to_add2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq_to_add</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>

                <span class="c1"># Add sequence to alignment.</span>
                <span class="n">add_seq_to_alignment3</span><span class="p">(</span><span class="n">seq_to_add</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">)</span>

                <span class="c1"># Check that the added sequence is not identical (after trimming)</span>
                <span class="c1"># to a sequence already present in the trimmed alignment. </span>
                <span class="n">ali_with_new_seq</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment2</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
                <span class="n">last_seq</span> <span class="o">=</span> <span class="n">ali_with_new_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">identical_to_existing_seq</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">xseq</span> <span class="ow">in</span> <span class="n">ali_with_new_seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1">#print(str(xseq.seq))</span>
                    <span class="c1">#print(str(last_seq.seq))</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">xseq</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_seq</span><span class="o">.</span><span class="n">seq</span><span class="p">):</span>
                        <span class="n">identical_to_existing_seq</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">The sequence is identical to a previous one&#39;</span><span class="p">)</span>
                        <span class="k">break</span>

                <span class="c1"># Only run a tree if the added sequence is not identical to any</span>
                <span class="c1"># existing sequences.</span>
                <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">identical_to_existing_seq</span><span class="p">:</span> 
                    <span class="c1"># Use the previous constraint tree as a constraint tree.</span>
                    <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">get_constraint_tree_fp</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
                    <span class="c1">#constraint_tree_fp = tree</span>
                    <span class="c1"># Unless the path to such a file doesn&#39;t exist, then just use</span>
                    <span class="c1"># whatever tree was input.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">Constraint tree doesnt exist:&#39;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="k">assert</span> <span class="mi">2</span><span class="o">!=</span><span class="mi">2</span>
                        <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">tree</span>

                    <span class="c1"># Call function to run IQtree (specifying option to input a</span>
                    <span class="c1"># constraint tree and run ML search with the -g option instead of</span>
                    <span class="c1"># using the -te, --alrt, and --abayes options.</span>
                    <span class="n">place_seq</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">ml_placement_tree_path</span> <span class="o">=</span>\
                    <span class="n">run_tree_for_branch_lengths_and_supports_for_topology</span><span class="p">(</span>
                                                                  <span class="n">constraint_tree_fp</span><span class="p">,</span>
                                                                  <span class="n">alignment2</span><span class="p">,</span>
                                                                  <span class="n">subs_model</span><span class="p">,</span>
                                                                  <span class="n">outputdir</span><span class="p">,</span>
                                                                  <span class="n">place_seq</span><span class="p">)</span>

                    <span class="c1"># Indicate that a new tree was produced.</span>
                    <span class="n">added_a_sequence</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Confirm that the sequence went into one of the clades of</span>
                    <span class="c1"># interest, and which clade it was placed in.</span>
                    <span class="c1">#first_type_seq_node_name = None</span>
                    <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span>\
                    <span class="n">get_seq_placement_in_tree</span><span class="p">(</span><span class="n">ml_placement_tree_path</span><span class="p">,</span>
                                              <span class="n">seq_to_add</span><span class="p">,</span>
                                              <span class="n">type_seqs_dict</span><span class="p">,</span>
                                              <span class="n">essential_taxa</span><span class="p">)</span>

                    <span class="c1"># If the sequence could not be placed in any of the clades of interest,</span>
                    <span class="c1"># then set the name of the type sequence to a string &#39;None&#39;.</span>
                    <span class="k">if</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>

                    <span class="c1"># If the sequence was placed in a clade of interest, then the tree</span>
                    <span class="c1"># is usable.</span>
                    <span class="k">if</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>\
                    <span class="ow">and</span> <span class="n">ts_that_additional_seq_was_placed_in</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
                        <span class="c1"># Change variable to indicate that the alignment and</span>
                        <span class="c1"># tree are usable.</span>
                        <span class="n">ali_and_tree_usable</span> <span class="o">=</span> <span class="kc">True</span> 

                        <span class="c1"># Get name of clade that the type sequence is in.</span>
                        <span class="n">clade_name</span> <span class="o">=</span>\
                        <span class="n">get_clade_name_from_model2</span><span class="p">(</span><span class="n">ts_that_additional_seq_was_placed_in</span><span class="p">,</span>
                                                   <span class="n">type_seqs_dict2</span><span class="p">)</span>

                        <span class="c1"># Record name of clade that was modified.</span>
                        <span class="n">modified_clade_name2</span> <span class="o">=</span> <span class="n">clade_name</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">The sequence was not placed in any of the clades of interest&#39;</span><span class="p">)</span>

                    <span class="c1">## Temp:</span>
                    <span class="c1">## Check that the clade that the additional sequence was placed in was</span>
                    <span class="c1">## identified.</span>
                    <span class="c1">#assert ts_that_additional_seq_was_placed_in is not None, &quot;&quot;&quot;Sequence was</span>
                    <span class="c1">#not placed in any of the clades of interest: %s&quot;&quot;&quot; % record.description</span>

                    <span class="c1"># Parse tree using ete3.</span>
                    <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">ml_placement_tree_path</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># Write modified tree to a file.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Writing annotated tree to &#39;</span> <span class="o">+</span>\
                            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tree2</span><span class="p">))</span>
                    <span class="c1">#t1.write(outfile=tree2, format=9)</span>
                    <span class="n">write_constraint_tree_without_extra_parentheses</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">tree2</span><span class="p">)</span>




                <span class="c1"># *** This check may be redundant.</span>
                <span class="c1"># Check that a sequence was added, if not then stop iterating.</span>
                <span class="k">if</span> <span class="n">added_a_sequence</span> <span class="ow">and</span> <span class="n">ali_and_tree_usable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">identical_to_existing_seq</span><span class="p">:</span>
                    <span class="c1"># Check that the output alignment has one more sequence than the</span>
                    <span class="c1"># input alignment.</span>
                    <span class="n">num_seqs_in_new_alignment</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment2</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">))</span>
                    <span class="k">assert</span> <span class="n">num_seqs_in_new_alignment</span> <span class="o">==</span> <span class="n">num_seqs_in_alignment</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="c1"># Check that the output tree has one less sequence than the input</span>
                    <span class="c1"># tree.</span>
                    <span class="n">num_seqs_in_new_tree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree2</span><span class="p">)</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()))</span>
                    <span class="k">assert</span> <span class="n">num_seqs_in_new_tree</span> <span class="o">==</span> <span class="n">num_seqs_in_tree</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="c1"># Change variable value to indicate that a usable sequence</span>
                    <span class="c1"># was found.</span>
                    <span class="n">any_ali_and_tree_usable</span> <span class="o">=</span> <span class="kc">True</span>
                    
                    <span class="c1"># Break the loop over the sequences to add.</span>
                    <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Do not use the alignment and tree if the above conditions are not</span>
                    <span class="c1"># met (try another sequence).</span>
                    <span class="k">pass</span>

        <span class="c1"># Stop this type of modification if no sequences could be found that</span>
        <span class="c1"># actually work.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">any_ali_and_tree_usable</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>


    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;remove_columns&#39;</span><span class="p">:</span>
        <span class="c1"># Set variables that won&#39;t be modified.</span>
        <span class="n">subs_model2</span> <span class="o">=</span> <span class="n">subs_model</span>
        <span class="n">seqs_attempted_to_remove2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_remove</span>
        <span class="n">type_seqs_dict2</span> <span class="o">=</span> <span class="n">type_seqs_dict</span>
        <span class="n">seqs_attempted_to_add2</span> <span class="o">=</span> <span class="n">seqs_attempted_to_add</span>

        <span class="c1"># Initiate variables that will be modified later.</span>
        <span class="n">positions_attempted_to_remove2</span> <span class="o">=</span> <span class="n">positions_attempted_to_remove</span>
        
        <span class="c1"># The tree topology will be the same, so just copy the tree topology</span>
        <span class="c1"># file to the new path.</span>
        <span class="c1"># Read input tree and write to a new file.</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Whether quoted_node_names is true or false may be different for older trees.</span>
        <span class="n">t2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">tree2</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>

        <span class="c1">#shutil.copyfile(tree, tree2)</span>

        <span class="c1"># Define variable for storing True if a column was removed.</span>
        <span class="n">removed_a_column</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Parse input alignment, and find a column to try to remove.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
            <span class="n">alignment_obj</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>

            <span class="c1"># Get length of sequences in alignment.</span>
            <span class="n">seq_len</span> <span class="o">=</span> <span class="n">alignment_obj</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()</span>

            <span class="c1"># get a list of columns as strings in the original alignment.</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">alignment_obj</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_len</span><span class="p">)]</span> 

            <span class="c1"># Iterate over column sequences and remove a column that has</span>
            <span class="c1"># not been removed before.</span>
            <span class="n">column_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                <span class="n">column_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Determine whether the column has been removed before.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">positions_attempted_to_remove</span><span class="p">:</span>
                    <span class="c1"># Remove column from alignment.</span>
                    <span class="n">trim_one_column_from_alignment</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">,</span>
                            <span class="n">column_index</span><span class="p">)</span>
                    <span class="c1"># Define path to new modified alignment file.</span>
                    <span class="n">new_alignment</span> <span class="o">=</span> <span class="n">alignment2</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Removed column from alignment&#39;</span><span class="p">)</span>

                    <span class="c1"># Set variable to indicate that a column was successfully</span>
                    <span class="c1"># removed.</span>
                    <span class="n">removed_a_column</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Add column to list of columns that have been removed.</span>
                    <span class="n">positions_attempted_to_remove2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

                    <span class="c1"># Break this loop if a column was removed.</span>
                    <span class="k">if</span> <span class="n">removed_a_column</span><span class="p">:</span>
                        <span class="k">break</span>

        <span class="c1"># Check that a sequence was removed, if not then stop iterating.</span>
        <span class="k">if</span> <span class="n">removed_a_column</span><span class="p">:</span>
            <span class="c1"># Check that the output alignment has one less column than the</span>
            <span class="c1"># input alignment.</span>
            <span class="c1"># ... redundant with another check?</span>
            <span class="k">pass</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find a column to remove.&#39;</span><span class="p">)</span>
            <span class="c1"># Stop iterative calling of modify_seq_in_x_way function (at least</span>
            <span class="c1"># with the current modification type).</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Write code for the following options... </span>

    <span class="c1"># elif mod_type == &#39;refine_alignment&#39;:</span>
    <span class="c1">#     ...Use the muscle -refine option...</span>

    <span class="c1"># elif mod_type == &#39;update_subs_model&#39;:</span>
    <span class="c1">#     ...use iqtree ModelFinder to find the best fit model for the modified</span>
    <span class="c1">#     alignment...</span>

    <span class="c1"># elif mod_type == &#39;reduce_tree&#39;:</span>
    <span class="c1">#    ...remove taxonomically redundant and long-branching sequences.</span>


    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;mod_type variable not set properly.&quot;&quot;&quot;</span>

    <span class="c1">#############################################</span>
    <span class="c1">#############################################</span>

    <span class="c1"># Only run a tree if a new alignment and topology were produced.</span>
    <span class="n">ml_tree_path2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ml_tree_info_dict2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
        <span class="c1"># Run IQ-tree to get ML tree with branch supports for new alignment and/or</span>
        <span class="c1"># tree topology.</span>
        <span class="c1">#print(&#39;tree2:&#39;)</span>
        <span class="c1">#print(tree2)</span>
        <span class="n">ml_tree_path2</span> <span class="o">=</span>\
        <span class="n">run_tree_for_branch_lengths_and_supports_for_topology</span><span class="p">(</span><span class="n">tree2</span><span class="p">,</span>
                                                              <span class="n">alignment2</span><span class="p">,</span>
                                                              <span class="n">subs_model2</span><span class="p">,</span>
                                                              <span class="n">outputdir</span><span class="p">)</span>


        <span class="c1"># Extract relevant information from ML tree.</span>
        <span class="n">ml_tree_info_dict2</span> <span class="o">=</span> <span class="n">get_ml_tree_info_dict</span><span class="p">(</span><span class="n">ml_tree_path2</span><span class="p">,</span>
                                                  <span class="n">type_seqs_dict2</span><span class="p">,</span>
                                                  <span class="n">annotated_tree_outpath2</span><span class="p">)</span>

        <span class="c1"># Write a type_seqs file.</span>
        <span class="n">type_seqs_filepath</span> <span class="o">=</span> <span class="n">alignment2</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.type_seqs&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">type_seqs_filepath</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_seqs_filepath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">type_seqs_dict2</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span>\
                <span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">type_seqs_dict2</span><span class="o">.</span><span class="n">keys</span><span class="p">()]))</span>

    <span class="c1"># Construct a tuple with new info for new alignment and tree.</span>
    <span class="n">new_ali_tree_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">iteration2</span><span class="p">,</span>
                          <span class="n">tree2</span><span class="p">,</span>
                          <span class="n">alignment2</span><span class="p">,</span>
                          <span class="n">positions_attempted_to_remove2</span><span class="p">,</span>
                          <span class="n">subs_model2</span><span class="p">,</span>
                          <span class="n">type_seqs_dict2</span><span class="p">,</span>
                          <span class="n">ml_tree_info_dict2</span><span class="p">,</span>
                          <span class="n">seqs</span><span class="p">,</span>
                          <span class="n">seqs_attempted_to_remove2</span><span class="p">,</span>
                          <span class="n">seqs_attempted_to_add2</span><span class="p">,</span>
                          <span class="n">essential_taxa</span><span class="p">,</span>
                          <span class="n">stop</span><span class="p">,</span>
                          <span class="n">new_seq_essential</span><span class="p">,</span>
                          <span class="n">modified_clade_name2</span><span class="p">)</span>

    <span class="c1"># Return the new tuple.</span>
    <span class="k">return</span> <span class="n">new_ali_tree_tuple</span></div>


<div class="viewcode-block" id="get_taxonomic_info"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_taxonomic_info">[docs]</a><span class="k">def</span> <span class="nf">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a species name that appears in the genome info csv file in the</span>
<span class="sd">    genomes folder, return taxonomic information from that csv file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define path to info file.</span>
    <span class="n">info_csv</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">db_info_csv</span>

    <span class="c1"># Parse info file with pandas.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">info_csv</span><span class="p">)</span>

    <span class="c1"># Iterate through rows until one is found with the same species name.</span>
    <span class="n">taxonomic_info_obj</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">found_row</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">species</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">species</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Species (if applicable)&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">parsed_species_name</span> <span class="o">=</span> <span class="n">species_name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">species</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">parsed_species_name</span><span class="p">:</span>
                <span class="n">found_row</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">superbranch</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Superbranch&#39;</span><span class="p">]</span>
                <span class="n">supergroup</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Supergroup&#39;</span><span class="p">]</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Group&#39;</span><span class="p">]</span>
                <span class="n">taxonomic_info_obj</span> <span class="o">=</span> <span class="n">TaxonomicInfo</span><span class="p">(</span><span class="n">superbranch</span><span class="p">,</span> <span class="n">supergroup</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">species</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">found_row</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">found_row</span><span class="p">:</span>
            <span class="k">break</span>


    <span class="k">assert</span> <span class="n">taxonomic_info_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify taxonomic</span>
<span class="s2">    information for species </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">species_name</span>

    <span class="k">return</span> <span class="n">taxonomic_info_obj</span></div>


<div class="viewcode-block" id="define_textface_for_labeling_stem"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.define_textface_for_labeling_stem">[docs]</a><span class="k">def</span> <span class="nf">define_textface_for_labeling_stem</span><span class="p">(</span><span class="n">clade_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define ete3 textface styles for different nodes of interest that need to be</span>
<span class="sd">    labeled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define TextFace objects for clade stem nodes/branches.</span>
    <span class="n">stem_clade</span> <span class="o">=</span> <span class="n">TextFace</span><span class="p">(</span><span class="n">clade_name</span><span class="p">)</span>

    <span class="c1"># Set some attributes</span>
    <span class="c1">#stem_clade.margin_top = 10</span>
    <span class="c1">#stem_clade.margin_right = 10</span>
    <span class="c1">#stem_clade.margin_left = 10</span>
    <span class="c1">#stem_clade.margin_bottom = 10</span>
    <span class="c1">#stem_clade.opacity = 0.5 # from 0 to 1</span>
    <span class="c1">#stem_clade.inner_border.width = 1 # 1 pixel border</span>
    <span class="c1">#stem_clade.inner_border.type = 1  # dashed line</span>
    <span class="c1">#stem_clade.border.width = 1</span>
    <span class="c1">#stem_clade.background.color = &quot;LightGreen&quot;</span>

    <span class="c1"># Return dictionary.</span>
    <span class="k">return</span> <span class="n">stem_clade</span></div>


<div class="viewcode-block" id="get_corresponding_node"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_corresponding_node">[docs]</a><span class="k">def</span> <span class="nf">get_corresponding_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the ete3 TreeNode object in a tree that corresponds to</span>
<span class="sd">    a given node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Search for a node with child leaf nodes that have the same set of names.</span>
    <span class="n">corresponding_node</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">node_leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_leaves</span><span class="p">):</span>
            <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">break</span>
    <span class="c1"># If necessary, re-root input tree on midpoint for parsing.</span>
    <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Re-root on midpoint.</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>
        <span class="c1"># Search for node of interest again.</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_leaves</span><span class="p">):</span>
                <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">break</span>

    <span class="c1"># Try rooting on random leaf nodes until the corresponding node can be</span>
    <span class="c1"># found.</span>
    <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Loop through random leaf nodes in tree, rooting on them, and then</span>
        <span class="c1"># searching for the corresponding node.</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="c1"># Search for node of interest again.</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_leaves</span><span class="p">):</span>
                    <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="c1"># Check that a corresponding node was identified.</span>
    <span class="k">assert</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not find corresponding</span>
<span class="s2">    node.&quot;&quot;&quot;</span>

    <span class="c1"># Return corresponding node.</span>
    <span class="k">return</span> <span class="n">corresponding_node</span></div>


<div class="viewcode-block" id="get_list_of_leaf_names_for_node"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_list_of_leaf_names_for_node">[docs]</a><span class="k">def</span> <span class="nf">get_list_of_leaf_names_for_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an ete3 TreeNode object, return a list of terminal/leaf node</span>
<span class="sd">    names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">leaf_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">leaf_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf_names</span></div>


<div class="viewcode-block" id="get_clade_name_from_model2"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_clade_name_from_model2">[docs]</a><span class="k">def</span> <span class="nf">get_clade_name_from_model2</span><span class="p">(</span><span class="n">type_seq_name</span><span class="p">,</span> <span class="n">type_seqs_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return clade name for given type sequence name and type seqs info file</span>
<span class="sd">    (from models directory).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get clade name.</span>
    <span class="n">clade_name</span> <span class="o">=</span> <span class="s1">&#39;?&#39;</span>
    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">type_seqs_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">type_seq_name</span> <span class="o">==</span> <span class="n">type_seqs_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
                <span class="n">clade_name</span> <span class="o">=</span> <span class="n">clade</span>
                <span class="k">break</span>
        <span class="k">elif</span> <span class="n">type_seq_name</span> <span class="o">==</span> <span class="n">type_seqs_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="n">clade_name</span> <span class="o">=</span> <span class="n">clade</span>
            <span class="k">break</span>
    <span class="k">assert</span> <span class="n">clade_name</span> <span class="o">!=</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify clade name for type</span>
<span class="s2">    sequence name </span><span class="si">%s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">type_seq_name</span>

    <span class="k">return</span> <span class="n">clade_name</span></div>


<div class="viewcode-block" id="get_nodes_from_actual_tree_obj"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_nodes_from_actual_tree_obj">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_from_actual_tree_obj</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">nodes_of_interest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get nodes in the given tree object that correspond to the nodes in a</span>
<span class="sd">    given list of nodes from another tree object, and return as a list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">## Temp.</span>
    <span class="c1">#print(&#39;\n\nget_nodes_from_actual_tree_obj function call...&#39;)</span>
    <span class="c1">#print(&#39;Input tree:&#39;)</span>
    <span class="c1">#print(t3)</span>

    <span class="c1"># Get original root node for tree object.</span>
    <span class="n">original_outgroup</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">())[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Compile a list of corresponding nodes.</span>
    <span class="n">new_node_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes_of_interest</span><span class="p">:</span>
        <span class="c1">## Temp.</span>
        <span class="c1">#print(&#39;Node of interest&#39;)</span>
        <span class="c1">#print(i)</span>

        <span class="n">i_leaf_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span>
        <span class="n">corresponding_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Traverse the tree to find node.</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="n">node_leaf_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
            <span class="c1"># If the node has the same set of leaf names, then it is the</span>
            <span class="c1"># corresponding node.</span>
            <span class="k">if</span> <span class="n">node_leaf_names</span> <span class="o">==</span> <span class="n">i_leaf_names</span><span class="p">:</span>
                <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">node</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Generate a list of three different rootings for the tree, at</span>
            <span class="c1"># least one of which should allow identification of the clade of</span>
            <span class="c1"># interest.</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>
            <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>
            <span class="c1">#print(&#39;Rerooted tree on midpoint:&#39;)</span>
            <span class="c1">#print(t3)</span>
            <span class="n">side1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">())[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">side2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">())[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="n">side1</span><span class="p">,</span> <span class="n">side2</span><span class="p">]:</span>
                <span class="n">side_longest_length</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">side_longest_leaf</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># Apparently need to account for the strange case that one</span>
                <span class="c1"># sequence constitutes one side of the tree rooted on the</span>
                <span class="c1"># midpoint.</span>
                <span class="k">if</span> <span class="n">side</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                    <span class="n">length</span> <span class="o">=</span> <span class="n">t3</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">side_longest_length</span><span class="p">:</span>
                        <span class="n">side_longest_length</span> <span class="o">=</span> <span class="n">length</span>
                        <span class="n">side_longest_leaf</span> <span class="o">=</span> <span class="n">side</span>
                <span class="c1"># In most cases there will be multiple leaves on both sides of</span>
                <span class="c1"># the midpoint root.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">side</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                        <span class="n">length</span> <span class="o">=</span> <span class="n">side</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">side_longest_length</span><span class="p">:</span>
                            <span class="n">side_longest_length</span> <span class="o">=</span> <span class="n">length</span>
                            <span class="n">side_longest_leaf</span> <span class="o">=</span> <span class="n">leaf</span>
                <span class="c1"># Check that a leaf was identified.</span>
                <span class="k">assert</span> <span class="n">side_longest_leaf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="c1"># Add the longest leaf on this side of the midpoint to the list</span>
                <span class="c1"># of nodes on which to try rooting the tree.</span>
                <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">side_longest_leaf</span><span class="p">)</span>

            <span class="c1"># Try finding the corresponding node again.</span>
            <span class="k">for</span> <span class="n">root_node</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
                <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">root_node</span><span class="p">)</span>
                <span class="c1">#print(&#39;Rerooted tree:&#39;)</span>
                <span class="c1">#print(t3)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                    <span class="n">node_leaf_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span>
                    <span class="c1"># If the node has the same set of leaf names, then it is the</span>
                    <span class="c1"># corresponding node.</span>
                    <span class="k">if</span> <span class="n">node_leaf_names</span> <span class="o">==</span> <span class="n">i_leaf_names</span><span class="p">:</span>
                        <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
                <span class="c1"># Break loop so that tree does not get re-rooted unnecessarily.</span>
                <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># Try finding the corresponding node again by rooting on every</span>
            <span class="c1"># single leaf until the node of interest is found.</span>
            <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                    <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
                    <span class="c1">#print(&#39;Rerooted tree:&#39;)</span>
                    <span class="c1">#print(t3)</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                        <span class="n">node_leaf_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span>
                        <span class="c1"># If the node has the same set of leaf names, then it is the</span>
                        <span class="c1"># corresponding node.</span>
                        <span class="k">if</span> <span class="n">node_leaf_names</span> <span class="o">==</span> <span class="n">i_leaf_names</span><span class="p">:</span>
                            <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">node</span>
                            <span class="k">break</span>
                    <span class="c1"># Break loop so that tree does not get re-rooted unnecessarily.</span>
                    <span class="k">if</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">break</span>

            <span class="c1"># Check that the corresponding node was found.</span>
            <span class="k">assert</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># Root on the corresponding node identified. This is important,</span>
            <span class="c1"># because if the tree is not rooted on such a node, then the set of</span>
            <span class="c1"># leaves may be different for the node when it is identified again.</span>
            <span class="n">t3</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">corresponding_node</span><span class="p">)</span>

        <span class="c1"># Check that the corresponding node was found.</span>
        <span class="k">assert</span> <span class="n">corresponding_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>


        <span class="c1"># Temp.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corresponding_node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Query node:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Corresponding node:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">corresponding_node</span><span class="p">)</span>

        <span class="c1"># Check that the corresponding node has the same number of leaves.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span> <span class="o">==</span>\
        <span class="nb">len</span><span class="p">(</span><span class="n">corresponding_node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="s2">&quot;&quot;&quot;Identified node has a different</span>
<span class="s2">        number of leaves than expected.&quot;&quot;&quot;</span>

        <span class="c1"># Append the corresponding node to the list.</span>
        <span class="n">new_node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corresponding_node</span><span class="p">)</span>

    <span class="c1"># Don&#39;t do this, because the leaves for the clades of interest may not be</span>
    <span class="c1"># properly identified after re-rooting.</span>
    <span class="c1">## Re-root the tree object on the original root node.</span>
    <span class="c1">#t3.set_outgroup(original_outgroup)</span>

    <span class="c1"># Return the list of corresponding nodes.</span>
    <span class="k">return</span> <span class="n">new_node_list</span></div>


<div class="viewcode-block" id="get_nodes_of_interest"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_nodes_of_interest">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_of_interest</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">type_seq_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take an ete3 tree (TreeNode object), a list of type sequence names, and</span>
<span class="sd">    return a list of nodes of interest defined by clades (as ete3 TreeNode</span>
<span class="sd">    objects).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate list of orthogroup nodes of interest.</span>
    <span class="n">orthogroup_nodes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Make a copy of the input tree.</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># For each &quot;type&quot; sequence, traverse all nodes and find the node with</span>
    <span class="c1"># the largest number of child nodes that are leaf (terminal) nodes,</span>
    <span class="c1"># containing the &quot;type&quot; sequence of interest, but not containing any of</span>
    <span class="c1"># the other &quot;type&quot; sequences.</span>
    <span class="n">ts_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
        <span class="n">ts_num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Check that the sequence is in the tree.</span>
        <span class="k">assert</span> <span class="n">ts</span> <span class="ow">in</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()],</span> <span class="s2">&quot;&quot;&quot;There are no taxa in</span>
<span class="s2">        the tree with the name </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">ts</span>

        <span class="k">if</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first_type_seq_node_name</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="c1"># Root on another &quot;type&quot; sequence for the first type sequence in</span>
            <span class="c1"># the list to get whole clade, then root the tree on the ancestor</span>
            <span class="c1"># node of that first clade.</span>

            <span class="c1"># Get a node name for a node corresponding to a different</span>
            <span class="c1"># &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ts</span><span class="p">:</span>
                    <span class="n">other_type_seq_node_name</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
            <span class="k">assert</span> <span class="n">other_type_seq_node_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># Get node corresponding to a different &quot;type&quot; sequence.</span>
            <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_type_seq_node_name</span><span class="p">:</span>
                    <span class="n">other_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">break</span>
            <span class="k">assert</span> <span class="n">other_type_seq_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify</span>
<span class="s2">            a type seq node with name: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">other_type_seq_node_name</span>

            <span class="c1"># Root on the other &quot;type&quot; sequence node.</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">other_type_seq_node</span><span class="p">)</span>

            <span class="c1">#print(&#39;\n\n\nTree rooted on a type sequence other than the first type sequence.&#39;)</span>
            <span class="c1">#print(t2)</span>

        <span class="k">elif</span> <span class="n">ts_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Root on the first &quot;type&quot; sequence node for all subsequent</span>
            <span class="c1"># clades.</span>
            <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="n">leaf_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_type_seq_node_name</span><span class="p">:</span>
                        <span class="n">first_type_seq_node</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">first_type_seq_node</span><span class="p">)</span>
            <span class="c1">#print(&#39;\n\n\nTree re-rooted on first type sequence:&#39;)</span>
            <span class="c1">#print(t2)</span>


        <span class="c1"># Make a copy of the tree topology to work with for each run</span>
        <span class="c1"># through this loop.</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Make a list of nodes that contain type seq, but not any others. #</span>
        <span class="c1"># SEPARATE</span>
        <span class="n">nodes_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="c1"># Search in nodes that contain the type sequence.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts</span><span class="p">):</span>
                <span class="c1"># Search in nodes that don&#39;t contain other type sequences.</span>
                <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">ts2</span> <span class="ow">in</span> <span class="n">type_seq_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ts2</span> <span class="o">==</span> <span class="n">ts</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ts2</span><span class="p">):</span>
                            <span class="n">contains_other_type_seqs</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_other_type_seqs</span><span class="p">:</span>
                    <span class="c1"># Add nodes of interest to list.</span>
                    <span class="n">nodes_of_interest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Check that a node of interest was found.</span>
        <span class="c1"># This assumes that there is more than one sequence in the clade, which</span>
        <span class="c1"># is true if the clades were constrained, but not necessarily</span>
        <span class="c1"># otherwise.</span>
        <span class="c1">#assert len(nodes_of_interest) &gt;= 2 </span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> 

        <span class="c1"># find the node with the most child leaf nodes.</span>
        <span class="n">node_w_most_leaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_of_interest</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>\
                <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#node_w_most_leaves.name = &#39;X&#39;</span>

        <span class="c1"># Add node to list of nodes of interest.</span>
        <span class="n">orthogroup_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ts</span><span class="p">,</span> <span class="n">node_w_most_leaves</span><span class="p">])</span>

    <span class="c1"># Return list of lists containing defining sequence name and node object.</span>
    <span class="k">return</span> <span class="n">orthogroup_nodes</span></div>


<div class="viewcode-block" id="define_nodestyles_dict_for_colourcoding"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.define_nodestyles_dict_for_colourcoding">[docs]</a><span class="k">def</span> <span class="nf">define_nodestyles_dict_for_colourcoding</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Define node styles for different nodes of interest that need to be</span>
<span class="sd">    colour-coded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate dict.</span>
    <span class="n">nodestyle_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># General default style for tree (apply using the node.set_style(style)</span>
    <span class="c1"># function).</span>
    <span class="n">style</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;fgcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#0f0f0f&quot;</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;vt_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#ff0000&quot;</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#ff0000&quot;</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;vt_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;vt_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 0 solid, 1 dashed, 2 dotted</span>
    <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># dashed blue lines</span>
    <span class="n">style1</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;fgcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#000000&quot;</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;circle&quot;</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;vt_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#0000aa&quot;</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;hz_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#0000aa&quot;</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;vt_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;vt_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 0 solid, 1 dashed, 2 dotted</span>
    <span class="n">style1</span><span class="p">[</span><span class="s2">&quot;hz_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># stem_node</span>
    <span class="n">stem_node</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="n">stem_node</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># bold lines</span>
    <span class="n">style2</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="c1">#style2[&quot;vt_line_width&quot;] = 8</span>
    <span class="n">style2</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># bold dashed lines</span>
    <span class="n">style3</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
    <span class="n">style3</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">style3</span><span class="p">[</span><span class="s2">&quot;hz_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>


    <span class="c1"># Set dashed blue lines in all leaves</span>
    <span class="c1">#style3 = NodeStyle()</span>
    <span class="c1">#style3[&quot;fgcolor&quot;] = &quot;#000000&quot;</span>
    <span class="c1">#style3[&quot;shape&quot;] = &quot;circle&quot;</span>
    <span class="c1">#style3[&quot;vt_line_color&quot;] = &quot;#0000aa&quot;</span>
    <span class="c1">#style3[&quot;hz_line_color&quot;] = &quot;#0000aa&quot;</span>
    <span class="c1">#style3[&quot;vt_line_width&quot;] = 2</span>
    <span class="c1">#style3[&quot;hz_line_width&quot;] = 2</span>
    <span class="c1">#style3[&quot;vt_line_type&quot;] = 1 # 0 solid, 1 dashed, 2 dotted</span>
    <span class="c1">#style3[&quot;hz_line_type&quot;] = 1</span>


    <span class="c1"># Add styles to dictionary.</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">style1</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;stem_node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stem_node</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;shortest branch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">style2</span> <span class="c1"># bold.</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;longest branch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">style3</span> <span class="c1"># dashed.</span>
    <span class="n">nodestyle_dict</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">style1</span>

    <span class="c1"># Return dict.</span>
    <span class="k">return</span> <span class="n">nodestyle_dict</span></div>

<div class="viewcode-block" id="get_abayes_support_for_node_from_another_tree"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_abayes_support_for_node_from_another_tree">[docs]</a><span class="k">def</span> <span class="nf">get_abayes_support_for_node_from_another_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                                                  <span class="n">t_with_abayes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a node from one ete3 TreeNode object and find the corresponding</span>
<span class="sd">    node in another ete3 TreeNode object and return the support value for the</span>
<span class="sd">    node in the second tree (the abayes support value).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get corresponding node.</span>
    <span class="n">corresponding_node</span> <span class="o">=</span> <span class="n">get_corresponding_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t_with_abayes</span><span class="p">)</span>

    <span class="c1"># Return support value.</span>
    <span class="k">return</span> <span class="n">corresponding_node</span><span class="o">.</span><span class="n">support</span></div>


<div class="viewcode-block" id="get_ml_tree_info_dict"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_ml_tree_info_dict">[docs]</a><span class="k">def</span> <span class="nf">get_ml_tree_info_dict</span><span class="p">(</span><span class="n">ml_tree_path</span><span class="p">,</span>
                          <span class="n">type_seqs_dict</span><span class="p">,</span>
                          <span class="n">annotated_tree_outpath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to an ML tree and return a dict with information about</span>
<span class="sd">    lengths and supports of relevant branches.</span>
<span class="sd">    </span>
<span class="sd">    Return a dictionary with keys as type sequence names and values lists with branch</span>
<span class="sd">    length ratios and branch support values for the respective clades in the input tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initiate output dictionary.</span>
    <span class="n">branch_length_info_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Parse tree file.</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">ml_tree_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Define a dictionary of ete3 NodeStyle objects for different branch types</span>
    <span class="c1"># in the tree to be visualized.</span>
    <span class="n">style_dict</span> <span class="o">=</span> <span class="n">define_nodestyles_dict_for_colourcoding</span><span class="p">()</span> <span class="c1"># Temporarily commented out.</span>

    <span class="c1"># Get a list of nodes of interest (ancestral nodes for clades of interest).</span>
    <span class="n">orthogroup_nodes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Get list of &quot;type&quot; sequences from input.</span>
    <span class="c1">#type_seq_list = []</span>
    <span class="c1">#for i in open(type_seqs):</span>
    <span class="c1">#    type_seq_list.append(i.strip().split(&#39;,&#39;)[0])</span>
    <span class="n">type_seq_list</span> <span class="o">=</span> <span class="n">type_seqs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="c1"># Copy tree for colour-coding etc.</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Translate node names (support values) to branch supports so that when the</span>
    <span class="c1"># tree is re-rooted, the supports won&#39;t be mixed up.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># Assign support attribute value to node.</span>
                <span class="n">alrt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">abayes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">node</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">alrt</span> <span class="c1"># Get abayes later.</span>
                <span class="c1">## Round up the node support value to 2 significant digits.</span>
                <span class="c1">#node.support = float(format(node.support * 0.01, &#39;3.2f&#39;))</span>
                <span class="c1"># Delete existing node name attribute for node.</span>
                <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># Make a tree object with abayes supports instead of alrt.</span>
    <span class="n">t_with_abayes</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># Use this tree later to retrieve abayes values for nodes.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t_with_abayes</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># Assign support attribute value to node.</span>
                <span class="n">alrt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">abayes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">node</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">abayes</span>
                <span class="c1">## Round up the node support value to 2 significant digits.</span>
                <span class="c1">#node.support = float(format(node.support * 0.01, &#39;3.2f&#39;))</span>
                <span class="c1"># Delete existing node name attribute for node.</span>
                <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>


    <span class="c1"># Root on the midpoint, because ete3 was having trouble identifying clades</span>
    <span class="c1"># in some of the unrooted trees.</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>
    <span class="n">t_with_abayes</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">t_with_abayes</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">())</span>

    <span class="c1"># Get list of nodes of interest.</span>
    <span class="n">orthogroup_nodes</span> <span class="o">=</span> <span class="n">get_nodes_of_interest</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">type_seq_list</span><span class="p">)</span>

    <span class="c1">## Construct a dictionary storing the clade name corresponding to each</span>
    <span class="c1">## sequence name in the input tree.</span>
    <span class="c1">#seq_clade_name_dict = {}</span>
    <span class="c1">#for nl in orthogroup_nodes:</span>
    <span class="c1">#    clade_name = get_clade_name_from_model2(nl[0], type_seqs_dict)</span>
    <span class="c1">#    for ln in [x.name for x in nl[1].get_leaves()]:</span>
    <span class="c1">#        seq_clade_name_dict[ln] = clade_name</span>


    <span class="c1">###########################</span>
    <span class="c1"># Get lengths and supports for internal branches (excluding those within</span>
    <span class="c1"># the specific clades of interest) and add those to the dictionary as a</span>
    <span class="c1"># list of dictionaries.</span>

    <span class="c1"># Initiate list to store dictionaries with info for each internal branch.</span>
    <span class="n">internal_branch_info_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Copy the tree object(s).</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">t3_abayes</span> <span class="o">=</span> <span class="n">t_with_abayes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Record initial number of nodes.</span>
    <span class="n">initial_node_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span>

    <span class="c1"># Record which node is the original outgroup.</span>
    <span class="n">original_outgroup</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">())[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Find nodes of interest in new tree object for detaching.</span>
    <span class="n">orthogroup_nodes_t3</span> <span class="o">=</span> <span class="n">get_nodes_from_actual_tree_obj</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orthogroup_nodes</span><span class="p">])</span>
    <span class="n">orthogroup_nodes_t3_abayes</span> <span class="o">=</span> <span class="n">get_nodes_from_actual_tree_obj</span><span class="p">(</span><span class="n">t3_abayes</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orthogroup_nodes</span><span class="p">])</span>

    <span class="c1"># Not necessary, because this is done in the get_nodes_from_actual_tree_obj</span>
    <span class="c1"># function.</span>
    <span class="c1">## Re-root on one of the nodes of interest.</span>
    <span class="c1">#t3.set_outgroup(orthogroup_nodes_t3[0])</span>
    <span class="c1">#t3_abayes.set_outgroup(orthogroup_nodes_t3_abayes[0])</span>

    <span class="c1">#print(&#39;\nt3 before detaching nodes of interest:&#39;)</span>
    <span class="c1">#print(t3)</span>

    <span class="c1"># Detach all nodes of interest in the copy of the tree.</span>
    <span class="c1">#for i in to_remove_list:</span>
    <span class="c1">#print(&#39;orthogroup nodes:&#39;)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">orthogroup_nodes_t3</span><span class="p">:</span>
        <span class="c1">#print(i)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">():</span>
            <span class="n">j</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">orthogroup_nodes_t3_abayes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">():</span>
            <span class="n">j</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

    <span class="c1">## Temp.</span>
    <span class="c1">#print(&#39;\ntree with nodes removed (is this right???***):&#39;)</span>
    <span class="c1">#print(t3)</span>
    <span class="c1">#print(&#39;leaf nodes:&#39;)</span>
    <span class="c1">#print(t3.get_leaves())</span>

    <span class="c1"># Record (reduced) number of nodes.</span>
    <span class="n">reduced_node_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span>

    <span class="c1"># Check that at least one node was actually removed.</span>
    <span class="k">assert</span> <span class="n">reduced_node_num</span> <span class="o">&lt;</span> <span class="n">initial_node_num</span>
    <span class="c1"># Check that the tree has the minimum number of nodes.</span>
    <span class="k">assert</span> <span class="n">reduced_node_num</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orthogroup_nodes</span><span class="p">)</span>
    <span class="c1"># Check that the two pruned trees have the same number of nodes.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t3_abayes</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span>

    <span class="c1"># Unroot pruned tree so that there are no internal branches that are split</span>
    <span class="c1"># up by the root.</span>
    <span class="n">t3</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>
    <span class="n">t3_abayes</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>

    <span class="c1"># Get *internal* branch lengths and support values from pruned copy of the</span>
    <span class="c1"># tree (all the branches left are internal branches of interest).</span>
    <span class="n">internal_branch_info_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">intbrnum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">node_alrt_sup</span><span class="p">,</span> <span class="n">node_abayes_sup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">traverse</span><span class="p">(),</span> <span class="n">t3_abayes</span><span class="o">.</span><span class="n">traverse</span><span class="p">()):</span>
        <span class="c1"># ***Ignore the branches that lead to clades of interest. Note: This</span>
        <span class="c1"># may not always be what is needed.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node_alrt_sup</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node_alrt_sup</span><span class="o">.</span><span class="n">traverse</span><span class="p">()))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Get branch length.</span>
            <span class="k">assert</span> <span class="n">node_alrt_sup</span><span class="o">.</span><span class="n">dist</span> <span class="o">==</span> <span class="n">node_abayes_sup</span><span class="o">.</span><span class="n">dist</span>
            <span class="n">branch_length</span> <span class="o">=</span> <span class="n">node_alrt_sup</span><span class="o">.</span><span class="n">dist</span>

            <span class="c1"># Ignore the root node (branch length 0).</span>
            <span class="k">if</span> <span class="n">branch_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Initiate dict to store info for this branch.</span>
                <span class="n">branch_dict</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># Add branch length to dict.</span>
                <span class="n">branch_dict</span><span class="p">[</span><span class="s1">&#39;branch length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_length</span>

                <span class="c1"># Add branch supports to dict.</span>
                <span class="n">branch_dict</span><span class="p">[</span><span class="s1">&#39;alrt support&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_alrt_sup</span><span class="o">.</span><span class="n">support</span>
                <span class="n">branch_dict</span><span class="p">[</span><span class="s1">&#39;abayes support&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_abayes_sup</span><span class="o">.</span><span class="n">support</span>

                <span class="c1"># Add dict to list of branch dicts.</span>
                <span class="n">internal_branch_info_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch_dict</span><span class="p">)</span>

    <span class="c1"># Check that a minimum number of internal nodes were identified.</span>
    <span class="c1">#assert len(internal_branch_lengths) &gt;= len(orthogroup_nodes), &quot;&quot;&quot;Too few</span>
    <span class="c1">#internal nodes identified.&quot;&quot;&quot;</span>

    <span class="c1"># Add internal branch lengths and supports as a list of dicts to the output</span>
    <span class="c1"># dict.</span>
    <span class="n">branch_length_info_dict</span><span class="p">[</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">internal_branch_info_list</span>

    <span class="c1">###########################</span>
    <span class="c1"># Determine characteristics of clades of interest.</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">seq_node_list</span> <span class="ow">in</span> <span class="n">orthogroup_nodes</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">type_seq</span> <span class="o">=</span> <span class="n">seq_node_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">clade_name</span> <span class="o">=</span> <span class="n">get_clade_name_from_model2</span><span class="p">(</span><span class="n">type_seq</span><span class="p">,</span> <span class="n">type_seqs_dict</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">seq_node_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1">#print(&#39;\n\nClade defined by sequence &#39; + type_seq + &#39;:&#39;)</span>
        <span class="c1">#print(node)</span>

        <span class="c1"># Get list of leaf names.</span>
        <span class="n">leaf_names</span> <span class="o">=</span> <span class="n">get_list_of_leaf_names_for_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Get stem length for node.</span>
        <span class="n">stem_len</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span>
        <span class="c1">#print(&#39;\nStem length: &#39; + str(stem_len))</span>

        <span class="c1"># Get branch lengths for all sequences in the clade.</span>
        <span class="c1">#print(&#39;\nBranch lengths:&#39;)</span>
        <span class="n">seq_branch_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="c1">#print(&#39;\t&#39; + n.name + &#39;: &#39; + str(length))</span>
                <span class="n">seq_branch_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="p">])</span>

        <span class="c1"># Get longest branch length.</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">seq_branch_lengths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#print(&#39;\n\tLongest branch: &#39; + max_len[0] + &#39; &#39; + str(max_len[1]))</span>

        <span class="c1"># Get shortest branch length.</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">seq_branch_lengths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#print(&#39;\n\tShortest branch: &#39; + min_len[0] + &#39; &#39; + str(min_len[1]))</span>

        <span class="c1"># Get average branch length relative to ancestral/root node in the</span>
        <span class="c1"># clade for each sequence/terminal/leaf node.</span>
        <span class="n">mean_len</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq_branch_lengths</span><span class="p">])</span>
        <span class="c1">#print(&#39;\n\tMean length: &#39; + str(mean_len))</span>

        <span class="c1"># Get median branch length relative to ancestral/root node in the</span>
        <span class="c1"># clade for each sequence/terminal/leaf node.</span>
        <span class="n">median_len</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">median</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq_branch_lengths</span><span class="p">])</span>
        <span class="c1">#print(&#39;\n\tMedian length: &#39; + str(median_len))</span>

        <span class="c1"># Calculate ratio of stem length to average branch length.</span>
        <span class="n">stem_branches_ratio</span> <span class="o">=</span> <span class="n">stem_len</span> <span class="o">/</span> <span class="n">mean_len</span>
        <span class="c1">#print(&#39;\n\tRatio of stem len to avg branch len: &#39; + str(stem_branches_ratio))</span>


        <span class="c1"># Format tree for visualization.</span>

        <span class="c1"># Root on first clade of interest.</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#print(&#39;\n\n\n\n&#39;)</span>
            <span class="c1">#print(&#39;t2:&#39;)</span>
            <span class="c1">#print(t2)</span>
            <span class="c1">#print(t2.write())</span>
            <span class="c1">#print(&#39;node:&#39;)</span>
            <span class="c1">#print(node)</span>
            <span class="c1">#print(&#39;\n\n\n\n&#39;)</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">get_corresponding_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">t2</span><span class="p">))</span>


        <span class="c1"># This loop temporarily commented out to allow running on</span>
        <span class="c1"># computecanada (see also below):</span>

        <span class="c1"># Make stem branch for clade of interest bold.</span>
        <span class="n">stem_node</span> <span class="o">=</span> <span class="n">get_corresponding_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
        <span class="n">stem_node</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="n">style_dict</span><span class="p">[</span><span class="s1">&#39;stem_node&#39;</span><span class="p">])</span>

        <span class="c1"># Add clade name to stem branch.</span>
        <span class="c1">#stem_node.name = clade_name</span>
        <span class="n">stem_node</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">define_textface_for_labeling_stem</span><span class="p">(</span><span class="n">clade_name</span><span class="p">),</span> <span class="n">column</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="s2">&quot;branch-top&quot;</span><span class="p">)</span>

        <span class="c1"># Iterate over branches within clade and customize appearance.</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
            <span class="c1"># Set general features for all leaf nodes.</span>
            <span class="n">style</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
            <span class="n">style</span><span class="p">[</span><span class="s2">&quot;fgcolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#0f0f0f&quot;</span>
            <span class="n">style</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">style</span><span class="p">[</span><span class="s2">&quot;vt_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#000000&quot;</span>
            <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;#000000&quot;</span>

            <span class="c1">#style[&quot;vt_line_width&quot;] = 8</span>
            <span class="c1">#style[&quot;hz_line_width&quot;] = 8</span>
            <span class="c1">#style[&quot;vt_line_type&quot;] = 0 # 0 solid, 1 dashed, 2 dotted</span>
            <span class="c1">#style[&quot;hz_line_type&quot;] = 0</span>

            <span class="c1"># Make shortest branch in clade of interest bold.</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">min_len</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1">#shortbranchnode = get_corresponding_node(t1.search_nodes(name=min_len[0])[0], t2)</span>
                <span class="c1">#shortbranchnode.set_style(style_dict[&#39;shortest branch&#39;])</span>
                <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

            <span class="c1"># Make longest branch in clade of interest bold.</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">max_len</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1">#longbranchnode = get_corresponding_node(t1.search_nodes(name=max_len[0])[0], t2)</span>
                <span class="c1">#longbranchnode.set_style(style_dict[&#39;longest branch&#39;])</span>
                <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">style</span><span class="p">[</span><span class="s2">&quot;hz_line_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            
            <span class="c1"># Customize leaf node appearance.</span>
            <span class="c1"># Get species name.</span>
            <span class="c1">#species_name = leaf.name.replace(&#39;__&#39;, &#39; &#39;).replace(&#39;_&#39;, &#39; &#39;).split(&#39; &#39;, 1)[1]</span>
            <span class="n">species_name</span> <span class="o">=</span> <span class="n">get_species_name_from_seq_id</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="c1">#print(species_name)</span>

            <span class="c1"># Check that the name does not end with &#39;.copy&#39;.</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">species_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.copy&#39;</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;A sequence with an</span>
<span class="s2">            identical name to a sequence already in the alignment/tree was</span>
<span class="s2">            apparently added: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span>

            <span class="n">ti</span> <span class="o">=</span> <span class="n">get_taxonomic_info</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
            <span class="c1">#print(&#39;\t&#39; + &#39; &#39;.join([str(ti.superbranch), str(ti.supergroup),</span>
            <span class="c1">#    str(ti.group), str(ti.species)]))</span>

            <span class="c1"># Set style for node.</span>
            <span class="n">get_corresponding_node</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="n">style</span><span class="p">)</span>

        <span class="c1"># Sort seq names by descending branch lengths.</span>
        <span class="n">seq_names_by_br_len</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">(),</span>\
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="c1"># Identify most &quot;basal&quot; sequence in the clade, and the length of the</span>
        <span class="c1"># stem for the remaining seqs.</span>
        <span class="c1"># The node that is sister to the most basal sequence would be the one</span>
        <span class="c1"># that has the most daughter nodes.</span>
        <span class="n">basal_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">node_sister_to_basal_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node_sister_to_basal_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node_sister_to_basal_node</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_sister_to_basal_node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()):</span>
                <span class="n">node_sister_to_basal_node</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">sister_leaf_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_sister_to_basal_node</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">in_sister</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">sister_leaf_names</span><span class="p">:</span> 
                    <span class="n">in_sister</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_sister</span><span class="p">:</span>
                <span class="n">basal_node</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">break</span>
        <span class="c1"># Check whether the basal node was identified.</span>
        <span class="k">assert</span> <span class="n">basal_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># Define name of basal node.</span>
        <span class="n">basal_node_name</span> <span class="o">=</span> <span class="s1">&#39;clade&#39;</span>
        <span class="k">if</span> <span class="n">basal_node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">basal_node_name</span> <span class="o">=</span> <span class="n">basal_node</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># Define stem length of the clade that is sister to the &quot;basal&quot; clade.</span>
        <span class="n">basal_node_depth</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">node_sister_to_basal_node</span><span class="p">)</span>

        <span class="c1"># Get support values for clade.</span>
        <span class="n">alrt_support_value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">support</span>
        <span class="c1">#print(&#39;alrt: &#39; + str(alrt_support_value))</span>
        <span class="c1"># Have to retrieve abayes value from another tree object.</span>
        <span class="n">abayes_support_value</span> <span class="o">=</span>\
        <span class="n">get_abayes_support_for_node_from_another_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t_with_abayes</span><span class="p">)</span>
        <span class="c1">#print(&#39;abayes: &#39; + str(abayes_support_value))</span>

        <span class="c1"># Add info to output dictionary.</span>
        <span class="n">branch_length_info_dict</span><span class="p">[</span><span class="n">clade_name</span><span class="p">]</span> <span class="o">=</span>\
                <span class="p">{</span><span class="s1">&#39;stem length&#39;</span><span class="p">:</span> <span class="n">stem_len</span><span class="p">,</span>
                 <span class="s1">&#39;average branch length&#39;</span><span class="p">:</span> <span class="n">mean_len</span><span class="p">,</span>
                 <span class="s1">&#39;stem/branch ratio&#39;</span><span class="p">:</span> <span class="n">stem_branches_ratio</span><span class="p">,</span>
                 <span class="s1">&#39;seq names by descending length&#39;</span><span class="p">:</span> <span class="n">seq_names_by_br_len</span><span class="p">,</span>
                 <span class="s1">&#39;basal node name&#39;</span><span class="p">:</span> <span class="n">basal_node_name</span><span class="p">,</span>
                 <span class="s1">&#39;basal node depth&#39;</span><span class="p">:</span> <span class="n">basal_node_depth</span><span class="p">,</span>
                 <span class="c1">#&#39;internal branch lengths&#39;: internal_branch_lengths,</span>
                 <span class="s1">&#39;alrt support&#39;</span><span class="p">:</span> <span class="n">alrt_support_value</span><span class="p">,</span>
                 <span class="s1">&#39;abayes support&#39;</span><span class="p">:</span> <span class="n">abayes_support_value</span>
                 <span class="p">}</span>


    <span class="c1">## Write a modified taxon name conversion table file with clade names</span>
    <span class="c1">## appended to taxon/sequence names for future use. ***No longer necessary,</span>
    <span class="c1">## because this is handled by the visualize_tree command.</span>

    <span class="c1">## Define path to original table file.</span>
    <span class="c1">#original_table_file =\</span>
    <span class="c1">#find_input_file_in_parent_directory(os.path.dirname(ml_tree_path), &#39;table&#39;, [])</span>

    <span class="c1">## Make a copy of the original table file.</span>
    <span class="c1">#original_table_file_copy =\</span>
    <span class="c1">#original_table_file + &#39;_original&#39;</span>
    <span class="c1">#shutil.copyfile(original_table_file, original_table_file_copy)</span>

    <span class="c1">## Define path to temporary modified file.</span>
    <span class="c1">#original_table_file_temp =\</span>
    <span class="c1">#original_table_file + &#39;_TEMP&#39;</span>

    <span class="c1">## Loop over lines in original table.</span>
    <span class="c1">#with open(original_table_file) as tablefh,\</span>
    <span class="c1">#    open(original_table_file_temp,&#39;w&#39;) as o:</span>
    <span class="c1">#    for i in tablefh:</span>
    <span class="c1">#        if i.startswith(&#39;ZZ&#39;) and &#39;_&#39; not in i:</span>
    <span class="c1">#            o.write(i)</span>
    <span class="c1">#        elif i.strip() == &#39;&#39;:</span>
    <span class="c1">#            o.write(i)</span>
    <span class="c1">#        else:</span>
    <span class="c1">#            o.write(i.strip() + &#39;__&#39; + seq_clade_name_dict[i.strip()].strip() + &#39;\n&#39;)</span>

    <span class="c1">## Copy over the original table file path with the temporary file contents.</span>
    <span class="c1">#os.remove(original_table_file)</span>
    <span class="c1">#os.rename(original_table_file_temp, original_table_file)</span>


    <span class="c1"># Show tree annotations.</span>

    <span class="c1"># Remove underscores from leaf names.</span>
    <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t2</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">():</span>
        <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>

    <span class="c1"># Stretch branches.</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">TreeStyle</span><span class="p">()</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">show_leaf_name</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span>  <span class="mi">120</span> <span class="c1"># 120 pixels per branch length unit</span>

    <span class="c1"># Add title.</span>
    <span class="c1">#tree_title = &quot;[Tree title here]&quot;</span>
    <span class="n">tree_title</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">TextFace</span><span class="p">(</span><span class="n">tree_title</span><span class="p">,</span> <span class="n">fsize</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span> <span class="n">column</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Show.</span>
    <span class="c1">#t2.show(tree_style=ts)</span>

    <span class="c1"># Write tree to file.</span>
    <span class="k">if</span> <span class="n">annotated_tree_outpath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t2</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">annotated_tree_outpath</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">183</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="n">tree_style</span><span class="o">=</span><span class="n">ts</span><span class="p">)</span>

    <span class="c1"># Return main output path.</span>
    <span class="k">return</span> <span class="n">branch_length_info_dict</span></div>


<div class="viewcode-block" id="get_constraint_tree_fp"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_constraint_tree_fp">[docs]</a><span class="k">def</span> <span class="nf">get_constraint_tree_fp</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to an alignment, and return a path to use for a</span>
<span class="sd">    corresponding contraint tree topology.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#constraint_tree_fp = outalifpnex.rsplit(&#39;.&#39;, 1)[0] + &#39;_constraint_tree.newick&#39;</span>
    <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C_constraint_tree.newick&#39;</span>
    <span class="k">return</span> <span class="n">constraint_tree_fp</span></div>


<div class="viewcode-block" id="run_tree_for_branch_lengths_and_supports_for_topology"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.run_tree_for_branch_lengths_and_supports_for_topology">[docs]</a><span class="k">def</span> <span class="nf">run_tree_for_branch_lengths_and_supports_for_topology</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span>
                                                          <span class="n">alignment</span><span class="p">,</span>
                                                          <span class="n">subs_model</span><span class="p">,</span>
                                                          <span class="n">outputdir</span><span class="p">,</span>
                                                          <span class="n">place_seq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run an ML tree and branch support tests given a tree (for constraining</span>
<span class="sd">    topology), an alignment file, and a substitution model. Return path to</span>
<span class="sd">    output tree file.</span>

<span class="sd">    Optionally use the place_seq option to just do an ML search to place a</span>
<span class="sd">    sequence in a constrained topology with the -g option.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get list of all sequence names in alignment.</span>
    <span class="n">all_seq_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)]</span>

    <span class="c1"># Check that the input tree file exists.</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Input tree file path doesn&#39;t exist.&quot;&quot;&quot;</span>

    <span class="c1"># Get list of all leaf names for tree.</span>
    <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">infh</span><span class="o">.</span><span class="n">read</span><span class="p">():</span> 
            <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="n">quoted_node_names_var</span><span class="p">)</span>
    <span class="n">all_leaf_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tx</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>

    <span class="c1"># Check that the list of leaf names is the same as the list of sequence</span>
    <span class="c1"># names in the alignment.</span>
    <span class="c1">#for i, j in zip(sorted(all_seq_names), sorted(all_leaf_names)):</span>
    <span class="c1">#    print(i + &#39;, &#39; + j)</span>
    <span class="c1">#print(all_seq_names)</span>
    <span class="c1">#print(all_leaf_names)</span>
    <span class="k">if</span> <span class="n">place_seq</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Constraint tree</span>
<span class="s2">        should have one less sequence than alignment.&quot;&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Different number of</span>
<span class="s2">        sequences represented in the tree vs. alignment.&quot;&quot;&quot;</span>

    <span class="c1"># Convert nexus alignment to afa.</span>
    <span class="n">temp_fa_1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span>\
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_temp1.afa&#39;</span><span class="p">)</span>
    <span class="n">nex_to_afa</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">)</span> 

    <span class="c1"># Code names in alignment.</span>
    <span class="n">outalifp</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.afa&#39;</span>
    <span class="n">outtablefp</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.table&#39;</span>
    <span class="n">code_names_in_ali</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">temp_fa_1</span><span class="p">,</span> <span class="n">outalifp</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span> 

    <span class="c1"># Convert alignment back to nexus.</span>
    <span class="n">outalifpnex</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.nex&#39;</span>
    <span class="n">afa_to_nex</span><span class="p">(</span><span class="n">outalifp</span><span class="p">,</span> <span class="n">outalifpnex</span><span class="p">)</span>

    <span class="c1"># Get list of all sequence names in coded alignment.</span>
    <span class="n">all_seq_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)]</span>

    <span class="c1"># Delete temporary files.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_fa_1</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outalifp</span><span class="p">)</span>

    <span class="c1"># Define path for intermediate unrooted tree.</span>
    <span class="n">tree2</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_unrooted_tree.newick&#39;</span>

    <span class="c1"># Parse tree using ete3.</span>
    <span class="c1"># Note: parentheses and commas and colons get replaced with underscores by</span>
    <span class="c1"># ete3.</span>
    <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">infh</span><span class="o">.</span><span class="n">read</span><span class="p">():</span> 
            <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="n">quoted_node_names_var</span><span class="p">)</span>

    <span class="c1"># Unroot tree.</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">unroot</span><span class="p">()</span>

    <span class="c1"># Write unrooted tree to a new file.</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outfile</span><span class="o">=</span><span class="n">tree2</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
    <span class="c1">#print(&#39;tree2:&#39;)</span>
    <span class="c1">#print(tree2)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree2</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Tree topology file not produced:</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">tree2</span>

    <span class="c1"># Define path for constraint tree file.</span>
    <span class="n">constraint_tree_fp_coded</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Only do the following steps once for all the alignments, because all the</span>
    <span class="c1"># constrained topology analyses will use the same constraint trees.</span>

    <span class="c1"># Put quotation marks around names in constraint tree. # SEPARATE</span>
    <span class="c1">#outtreefp = ali.rsplit(&#39;.&#39;, 1)[0] + &#39;.constraint_tree0.Q.newick&#39;</span>
    <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">place_seq</span><span class="p">:</span>
        <span class="c1"># Use the input tree path as the constraint tree if the place_seq</span>
        <span class="c1"># option is used (because using the previous topology without the new</span>
        <span class="c1"># sequence to constrain the ML tree search).</span>
        <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="c1">#constraint_tree_fp = get_constraint_tree_fp(alignment)</span>
        <span class="c1">#print(&#39;\n\n&#39;)</span>
        <span class="c1">#print(tree)</span>
        <span class="c1">#print(alignment)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Expected to find</span>
<span class="s2">        constraint tree at this file path:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">constraint_tree_fp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">constraint_tree_fp</span> <span class="o">=</span> <span class="n">get_constraint_tree_fp</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree2</span><span class="p">)</span> <span class="k">as</span> <span class="n">intreefh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">intreefh</span><span class="p">:</span>
                <span class="n">o</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">quote_tree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Expected to find</span>
<span class="s2">    constraint tree at this file path:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">constraint_tree_fp</span>

    <span class="c1"># Make constraint tree with coded names.</span>
    <span class="n">constraint_tree_fp_coded</span> <span class="o">=</span> <span class="n">constraint_tree_fp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.C.tre&#39;</span>
    <span class="n">code_tree</span><span class="p">(</span><span class="n">constraint_tree_fp</span><span class="p">,</span> <span class="n">constraint_tree_fp_coded</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span>
    <span class="c1">#print(&#39;constraint_tree_fp_coded:&#39;)</span>
    <span class="c1">#print(constraint_tree_fp_coded)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">constraint_tree_fp_coded</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Coded constraint tree</span>
<span class="s2">    not produced.&quot;&quot;&quot;</span>

    <span class="c1"># Get list of all leaf names for tree.</span>
    <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">constraint_tree_fp_coded</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">infh</span><span class="o">.</span><span class="n">read</span><span class="p">():</span> 
            <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">constraint_tree_fp_coded</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="n">quoted_node_names_var</span><span class="p">)</span>
    <span class="n">all_leaf_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tx</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>

    <span class="c1"># Check that the list of leaf names is the same as the list of sequence</span>
    <span class="c1"># names in the alignment.</span>
    <span class="k">if</span> <span class="n">place_seq</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Different number of</span>
<span class="s2">        sequences represented in the tree vs. alignment.&quot;&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Different number of</span>
<span class="s2">        sequences represented in the tree vs. alignment.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_leaf_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_seq_names</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Sequence names in tree</span>
<span class="s2">        and alignment differ.&quot;&quot;&quot;</span>


    <span class="c1"># Make a copy of the alignment in phylip format for input to IQtree.</span>
    <span class="n">phy_out</span> <span class="o">=</span> <span class="n">outalifpnex</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.phy&#39;</span>
    <span class="n">nex_to_phylip</span><span class="p">(</span><span class="n">outalifpnex</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">)</span>

    <span class="c1"># Do phylogenetic analysis.</span>

    <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">place_seq</span><span class="p">:</span>
        <span class="c1"># Make subdir for output.</span>
        <span class="n">iter_num_str</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">subdirp</span> <span class="o">=</span> <span class="n">constraint_tree_fp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>\
        <span class="s1">&#39;_IQ-tree_output_place_seq_&#39;</span> <span class="o">+</span> <span class="n">iter_num_str</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">):</span>
            <span class="n">random_id_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
            <span class="n">subdirp</span> <span class="o">=</span> <span class="n">subdirp</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">random_id_string</span> 
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">)</span>


        <span class="c1"># ***This code block may not always be necessary, and can be commented out</span>
        <span class="c1"># later to speed up the analysis:</span>
        <span class="c1"># Check that constraint tree is as expected:</span>
        <span class="c1"># Check number of taxa in constraint tree.</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">constraint_tree_fp_coded</span><span class="p">)</span>
        <span class="n">num_taxa_in_constraint_tree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span>
        <span class="n">nonredun_num_taxa_in_constraint_tree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tx</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])))</span>
        <span class="c1"># Check that there is at least one taxon represented in the constraint</span>
        <span class="c1"># tree.</span>
        <span class="k">assert</span> <span class="n">num_taxa_in_constraint_tree</span> <span class="o">&gt;=</span> <span class="mi">1</span> 
        <span class="c1"># Check that there are no redundant sequences in constraint tree.</span>
        <span class="k">assert</span> <span class="n">num_taxa_in_constraint_tree</span> <span class="o">==</span> <span class="n">nonredun_num_taxa_in_constraint_tree</span>
        <span class="c1"># Get number of sequences in alignment.</span>
        <span class="n">num_seqs_in_ali</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">phy_out</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Check that the number of sequences in the constraint tree is one less</span>
        <span class="c1"># than the number in the alignment, because the alignment should have</span>
        <span class="c1"># the additional sequence to be placed.</span>
        <span class="k">assert</span> <span class="n">num_taxa_in_constraint_tree</span> <span class="o">==</span> <span class="n">num_seqs_in_ali</span> <span class="o">-</span> <span class="mi">1</span>


        <span class="c1"># Use IQtree to do an ML search</span>
        <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirp</span><span class="p">,</span> <span class="s1">&#39;iqtree&#39;</span><span class="p">)</span>
        <span class="n">iqtree_command_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span>
                               <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span>
                               <span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="n">constraint_tree_fp_coded</span><span class="p">,</span> 
                               <span class="s1">&#39;-pre&#39;</span><span class="p">,</span> <span class="n">output_file_prefix</span><span class="p">,</span> 
                               <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span>
                               <span class="p">]</span>
        <span class="c1">#print(&#39; &#39;.join(iqtree_command_list))</span>
        <span class="c1">#print(&#39;constraint_tree_fp_coded&#39;)</span>
        <span class="c1">#print(constraint_tree_fp_coded)</span>
        <span class="n">stdout_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.stdout.txt&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stdout_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">o</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">stdout_path</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;IQtree standard output not</span>
<span class="s2">        written to a file.&quot;&quot;&quot;</span>
        <span class="c1">#print(&#39;stdout_path:&#39;)</span>
        <span class="c1">#print(stdout_path)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Make subdir for output.</span>
        <span class="n">subdirp</span> <span class="o">=</span> <span class="n">constraint_tree_fp</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_IQ-tree_output&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subdirp</span><span class="p">)</span>

        <span class="c1"># Use IQtree to do an ML search</span>
        <span class="n">output_file_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirp</span><span class="p">,</span> <span class="s1">&#39;iqtree&#39;</span><span class="p">)</span>
        <span class="n">iqtree_command_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iqtree&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="n">phy_out</span><span class="p">,</span>
                               <span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">subs_model</span><span class="p">,</span>
                               <span class="s1">&#39;-te&#39;</span><span class="p">,</span> <span class="n">constraint_tree_fp_coded</span><span class="p">,</span>
                               <span class="s1">&#39;-alrt&#39;</span><span class="p">,</span> <span class="s1">&#39;1000&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;-abayes&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;-pre&#39;</span><span class="p">,</span> <span class="n">output_file_prefix</span><span class="p">,</span> 
                               <span class="s1">&#39;-nt&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span>
                               <span class="p">]</span>
        <span class="c1">#print(&#39; &#39;.join(iqtree_command_list))</span>
        <span class="c1">#print(&#39;constraint_tree_fp_coded&#39;)</span>
        <span class="c1">#print(constraint_tree_fp_coded)</span>
        <span class="n">stdout_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.stdout.txt&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stdout_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">iqtree_command_list</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">o</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">stdout_path</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;IQtree standard output not</span>
<span class="s2">        written to a file.&quot;&quot;&quot;</span>

    <span class="c1"># Define path to output file.</span>
    <span class="n">tree_file_path</span> <span class="o">=</span> <span class="n">output_file_prefix</span> <span class="o">+</span> <span class="s1">&#39;.treefile&#39;</span>
    <span class="c1"># Check that the output file was actually produced.</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;IQtree did not produce a</span>
<span class="s2">    treefile.&quot;&quot;&quot;</span>

    <span class="c1"># Parse output tree.</span>
    <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>

    <span class="c1"># Uncode tree.</span>
    <span class="n">tree_file_path2</span> <span class="o">=</span> <span class="n">tree_file_path</span> <span class="o">+</span> <span class="s1">&#39;2&#39;</span>
    <span class="n">uncode_tree</span><span class="p">(</span><span class="n">tree_file_path</span><span class="p">,</span> <span class="n">tree_file_path2</span><span class="p">,</span> <span class="n">outtablefp</span><span class="p">)</span>

    <span class="c1"># Return path to the tree with uncoded taxon names.</span>
    <span class="k">return</span> <span class="n">tree_file_path2</span> </div>


<div class="viewcode-block" id="get_type_seqs_dict"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_type_seqs_dict">[docs]</a><span class="k">def</span> <span class="nf">get_type_seqs_dict</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to a file listing sequences that define nodes of interest in</span>
<span class="sd">    a tree, and construct a dictionary with clade names as keys and sequence</span>
<span class="sd">    names as values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">type_seqs_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_seqs</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="n">spliti</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                <span class="n">seqname</span> <span class="o">=</span> <span class="n">spliti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cladename</span> <span class="o">=</span> <span class="n">spliti</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">type_seqs_dict</span><span class="p">[</span><span class="n">cladename</span><span class="p">]</span> <span class="o">=</span> <span class="n">seqname</span>
    <span class="k">return</span> <span class="n">type_seqs_dict</span></div>

<div class="viewcode-block" id="get_essential_taxa_list"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_essential_taxa_list">[docs]</a><span class="k">def</span> <span class="nf">get_essential_taxa_list</span><span class="p">(</span><span class="n">essential_taxa_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a path to a file listing essential taxa (taxonomy terms) and return</span>
<span class="sd">    a list of the terms in the file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">essential_taxa</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">essential_taxa_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">essential_taxa_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infh</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                    <span class="n">taxon</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">essential_taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">essential_taxa</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">essential_taxa</span></div>


<div class="viewcode-block" id="get_y_measure_of_support"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_y_measure_of_support">[docs]</a><span class="k">def</span> <span class="nf">get_y_measure_of_support</span><span class="p">(</span><span class="n">previous_ali_tree_tuple</span><span class="p">,</span>
                             <span class="n">include_internal_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">input_modified_clade_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a tuple with objects containing info about an alignment and tree,</span>
<span class="sd">    and extract specific info to use as a measure of support for nodes of</span>
<span class="sd">    interest.</span>

<span class="sd">    *** Need to get support for all nodes of interest, not just for clades of</span>
<span class="sd">    interest, but also backbone nodes, and find the one with the lowest</span>
<span class="sd">    support.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get info dict from input tuple.</span>
    <span class="n">ml_tree_info_dict</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">modified_clade_name</span> <span class="o">=</span> <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">modified_clade_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">modified_clade_name</span> <span class="o">=</span> <span class="n">input_modified_clade_name</span>

    <span class="c1"># For reference:</span>
    <span class="c1">#ml_tree_info_dict[clade_name] =\</span>
    <span class="c1">#        {&#39;stem length&#39;: stem_len,</span>
    <span class="c1">#         &#39;average branch length&#39;: mean_len,</span>
    <span class="c1">#         &#39;stem/branch ratio&#39;: stem_branches_ratio,</span>
    <span class="c1">#         &#39;seq names by descending length&#39;: seq_names_by_br_len,</span>
    <span class="c1">#         &#39;basal node name&#39;: basal_node_name,</span>
    <span class="c1">#         &#39;basal node depth&#39;: basal_node_depth,</span>
    <span class="c1">#         &#39;internal branch lengths&#39;: internal_branch_lengths,</span>
    <span class="c1">#         &#39;alrt support&#39;: alrt_support_value,</span>
    <span class="c1">#         &#39;abayes support&#39;: abayes_support_value</span>
    <span class="c1">#         }</span>

    <span class="c1"># Initiate variable for storing lowest support value.</span>
    <span class="n">lowest_support_value</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="n">average_support_value</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Remove info list for internal branches from dict keys for</span>
    <span class="c1"># consideration.</span>
    <span class="n">clade_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">clade_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">)</span>

    <span class="c1"># Get list of stem/branch length ratios for all clades of interest.</span>
    <span class="n">all_stem_branch_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">][</span><span class="s1">&#39;stem/branch ratio&#39;</span><span class="p">])</span>\
                              <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clade_list</span><span class="p">]</span> 

    <span class="c1"># Get minimum stem/branch ratio for clades of interest. </span>
    <span class="n">minimum_stem_branch_ratio</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">all_stem_branch_ratios</span><span class="p">)</span>

    <span class="c1"># Get stem/branch ratio for the clade that was modified (if applicable). </span>
    <span class="n">modified_clade_stem_branch_ratio</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">modified_clade_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">modified_clade_stem_branch_ratio</span> <span class="o">=</span>\
        <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">modified_clade_name</span><span class="p">][</span><span class="s1">&#39;stem/branch ratio&#39;</span><span class="p">]</span>

    <span class="c1"># Get average stem/branch ratio for clades of interest.</span>
    <span class="n">average_stem_branch_ratio</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">all_stem_branch_ratios</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_stem_branch_ratios</span><span class="p">)</span>

    <span class="c1"># Get list of all deep branch lengths.</span>
    <span class="n">all_dbranch_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;branch length&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">]]</span>

    <span class="c1">## Get average length of stems for clades of interest.</span>
    <span class="c1">#all_clade_stem_lengths = [float(ml_tree_info_dict[clade][&#39;stem length&#39;])\</span>
    <span class="c1">#                          for clade in clade_list]</span>
    <span class="c1">#average_clade_stem_lengths = sum(all_clade_stem_lengths) / len(all_clade_stem_lengths)</span>

    <span class="c1">## Get list of all deep branch/average stem length ratios.</span>
    <span class="c1">#all_dbranch_avgstem_ratios = [float(x / average_clade_stem_lengths)\</span>
    <span class="c1">#                              for x in all_dbranch_lengths]</span>

    <span class="c1">## Get minimum deep branch/average stem length ratio.</span>
    <span class="c1">## Get all average branch length ratios.</span>
    <span class="c1">#min_dbranch_avgstem_ratio = min(all_dbranch_avgstem_ratios)</span>

    <span class="c1"># Get average of average leaf lengths (measured from the parent node of the</span>
    <span class="c1"># clade of interest that the leaf is in).</span>
    <span class="n">avg_leaf_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">][</span><span class="s1">&#39;average branch length&#39;</span><span class="p">])</span>\
                       <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clade_list</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">clade_list</span><span class="p">)</span>

    <span class="c1"># Get list of all deep branch/average leaf lengths (measured from nodes for</span>
    <span class="c1"># specific clades of interest, averaged over all leaves).</span>
    <span class="n">all_dbranch_avgleaf_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">avg_leaf_length</span><span class="p">)</span>\
                                  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_dbranch_lengths</span><span class="p">]</span>

    <span class="c1"># Get minimum ratio of deep branch length to average leaf length.</span>
    <span class="n">min_dbranch_avgleaf_ratio</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">all_dbranch_avgleaf_ratios</span><span class="p">)</span>

    <span class="c1"># Get average ratio of deep branch length to average leaf length.</span>
    <span class="n">avg_dbranch_avgleaf_ratio</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">all_dbranch_avgleaf_ratios</span><span class="p">)</span>\
                                <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_dbranch_avgleaf_ratios</span><span class="p">)</span>

    <span class="c1"># Examine the alrt and abayes support values for relevant clades.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_internal_branches</span><span class="p">:</span>
        <span class="c1"># Just consider branch supports for the specific clades of interest.</span>

        <span class="c1"># Compile a list of all the relevant support values (both alrt and</span>
        <span class="c1"># abayes).</span>
        <span class="n">all_alrt_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;alrt support&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">clade_list</span><span class="p">]</span>
        <span class="n">all_abayes_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;abayes support&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">clade_list</span><span class="p">]</span>

        <span class="c1"># Get the lowest values.</span>
        <span class="n">lowest_alrt_support_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">all_alrt_values</span><span class="p">)</span>
        <span class="c1">#print(lowest_alrt_support_value)</span>
        <span class="n">lowest_abayes_support_value</span> <span class="o">=</span>\
            <span class="nb">min</span><span class="p">(</span><span class="n">all_abayes_values</span><span class="p">)</span>
        <span class="c1">#print(lowest_abayes_support_value)</span>
        <span class="n">lowest_support_value</span> <span class="o">=</span>\
            <span class="nb">min</span><span class="p">([</span><span class="n">lowest_alrt_support_value</span><span class="p">,</span> <span class="n">lowest_abayes_support_value</span><span class="p">])</span>

        <span class="c1"># Calculate the average over all the values.</span>
        <span class="n">all_values</span> <span class="o">=</span> <span class="n">all_alrt_values</span> <span class="o">+</span> <span class="n">all_abayes_values</span>
        <span class="n">average_support_value</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Consider the branch supports for the specific clades of interest, as well</span>
        <span class="c1"># as all branches that are internal to those clades.</span>

        <span class="c1"># Get values for internal branches.</span>
        <span class="n">internal_alrt_values</span> <span class="o">=</span>\
            <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;alrt support&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">]]</span>
        <span class="n">internal_abayes_values</span> <span class="o">=</span>\
            <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;abayes support&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="s1">&#39;internal branches info list&#39;</span><span class="p">]]</span>

        <span class="c1"># Compile a list of all the relevant support values (both alrt and</span>
        <span class="c1"># abayes).</span>
        <span class="n">all_alrt_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;alrt support&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">clade_list</span><span class="p">]</span>\
                <span class="o">+</span> <span class="n">internal_alrt_values</span>
        <span class="n">all_abayes_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ml_tree_info_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;abayes support&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">clade_list</span><span class="p">]</span>\
                <span class="o">+</span> <span class="n">internal_abayes_values</span>

        <span class="c1"># Get the lowest values.</span>
        <span class="n">lowest_alrt_support_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">all_alrt_values</span><span class="p">)</span>
        <span class="c1">#print(lowest_alrt_support_value)</span>
        <span class="n">lowest_abayes_support_value</span> <span class="o">=</span>\
            <span class="nb">min</span><span class="p">(</span><span class="n">all_abayes_values</span><span class="p">)</span>
        <span class="c1">#print(lowest_abayes_support_value)</span>
        <span class="n">lowest_support_value</span> <span class="o">=</span>\
            <span class="nb">min</span><span class="p">([</span><span class="n">lowest_alrt_support_value</span><span class="p">,</span> <span class="n">lowest_abayes_support_value</span><span class="p">])</span>

        <span class="c1"># Calculate the average over all the values.</span>
        <span class="n">all_values</span> <span class="o">=</span> <span class="n">all_alrt_values</span> <span class="o">+</span> <span class="n">all_abayes_values</span>
        <span class="n">average_support_value</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span>

    <span class="c1"># Check that the value was found.</span>
    <span class="k">assert</span> <span class="n">lowest_support_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="n">average_support_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># Return measure of support.</span>
    <span class="c1">#return lowest_support_value</span>
    <span class="c1">#return average_support_value</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">lowest_support_value</span><span class="p">,</span> <span class="n">average_support_value</span><span class="p">,</span>
            <span class="n">minimum_stem_branch_ratio</span><span class="p">,</span> <span class="n">average_stem_branch_ratio</span><span class="p">,</span>
            <span class="n">min_dbranch_avgleaf_ratio</span><span class="p">,</span> <span class="n">avg_dbranch_avgleaf_ratio</span><span class="p">,</span>
            <span class="n">modified_clade_stem_branch_ratio</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_ali_length"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.get_ali_length">[docs]</a><span class="k">def</span> <span class="nf">get_ali_length</span><span class="p">(</span><span class="n">alignment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a filepath to an alignment file in nexus format and return the</span>
<span class="sd">    length of the sequences in the alignment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alignment_length</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="n">ali_obj</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
        <span class="n">first_seq_obj</span> <span class="o">=</span> <span class="n">ali_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">alignment_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_seq_obj</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alignment_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">alignment_length</span> </div>


<div class="viewcode-block" id="new_tree_better"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.new_tree_better">[docs]</a><span class="k">def</span> <span class="nf">new_tree_better</span><span class="p">(</span><span class="n">prev_tree_measure</span><span class="p">,</span>
                    <span class="n">new_tree_measure</span><span class="p">,</span>
                    <span class="n">mod_type</span><span class="p">,</span>
                    <span class="n">intensive_mod_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply criteria to tuples containing information about two trees to</span>
<span class="sd">    determine which is better (old or new), and return True if the new tree is</span>
<span class="sd">    better.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: Contents of tuple returned by the get_y_measure_of_support function</span>
    <span class="c1"># (X_tree_measure variables):</span>
    <span class="c1"># 1. lowest_support_value,</span>
    <span class="c1"># 2. average_support_value,</span>
    <span class="c1"># 3. minimum_stem_branch_ratio,</span>
    <span class="c1"># 4. average_stem_branch_ratio,</span>
    <span class="c1"># 5. min_dbranch_avgleaf_ratio,</span>
    <span class="c1"># 6. avg_dbranch_avgleaf_ratio,</span>
    <span class="c1"># 7. modified_clade_stem_branch_ratio</span>

    <span class="c1"># Apply criteria based on comparing values between trees.</span>
    <span class="c1">#if new_tree_measure[0] &gt;= prev_tree_measure[0] and new_tree_measure[1] &gt;= prev_tree_measure[1]:</span>
    <span class="c1">#if new_tree_measure[2] &gt;= prev_tree_measure[2] and new_tree_measure[3] &gt;= prev_tree_measure[3]:</span>
    <span class="c1"># This is the best so far:</span>
    <span class="c1">#if new_tree_measure[4] &gt;= prev_tree_measure[4] and new_tree_measure[5] &gt;= prev_tree_measure[5]:</span>
    <span class="c1"># No attention to deep backbone:</span>
    <span class="c1">#if new_tree_measure[4] &gt;= prev_tree_measure[4]:</span>

    <span class="c1">## No criteria applied at all:</span>
    <span class="c1">#if 2 == 2:</span>
    <span class="c1">#    print(&#39;\t\t\tWarning: No criteria applied.&#39;)</span>
    <span class="c1">#    print(&#39;\t\t\tNew tree is better.&#39;)</span>
    <span class="c1">#    previous_ali_tree_tuple = new_ali_tree_tuple</span>

    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;add_seqs&#39;</span><span class="p">:</span>
        <span class="c1">## Just say the new tree is better if a sequence has been added.</span>
        <span class="c1">#return True</span>

        <span class="c1">## Apply inclusive criteria.</span>
        <span class="c1">#if new_tree_measure[4] &gt;= prev_tree_measure[4] and new_tree_measure[5] &gt;= prev_tree_measure[5]:</span>
        <span class="c1"># Only require that the clade that was modified has a branch length</span>
        <span class="c1"># ratio that is at least as good as in the previous tree.</span>
        <span class="k">if</span> <span class="n">new_tree_measure</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">prev_tree_measure</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.95</span><span class="p">):</span>
            <span class="c1"># Return True to indicate that the new tree is better.</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return False to indicate that the old tree is better.</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">## Apply inclusive criteria.</span>
        <span class="c1">#if new_tree_measure[4] &gt;= prev_tree_measure[4] and new_tree_measure[5] &gt;= prev_tree_measure[5]:</span>
        <span class="c1"># Only require that the clade that was modified has a branch length</span>
        <span class="c1"># ratio that is at least as good as in the previous tree.</span>
        <span class="k">if</span> <span class="n">new_tree_measure</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">prev_tree_measure</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span>
            <span class="c1"># Return True to indicate that the new tree is better.</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return False to indicate that the old tree is better.</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="search_alignment_space"><a class="viewcode-back" href="../search_alignment_space.html#search_alignment_space.search_alignment_space">[docs]</a><span class="k">def</span> <span class="nf">search_alignment_space</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span>
                           <span class="n">out_dir_path</span><span class="p">,</span>
                           <span class="n">mod_type</span><span class="p">,</span>
                           <span class="n">iterations</span><span class="p">,</span>
                           <span class="n">keep_all_output</span><span class="p">,</span>
                           <span class="n">timestamp</span><span class="p">,</span>
                           <span class="n">file_with_seqs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                           <span class="n">essential_taxa_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Master function to manage the iterative process of modifying an</span>
<span class="sd">    alignment/tree, and assessing whether the modification results in better</span>
<span class="sd">    branch support for a topology of interest. In other words, optimize an</span>
<span class="sd">    alignment to support a backbone topology for clades of interest in the</span>
<span class="sd">    tree. IMPORTANT: Do this in parallel for alternative topologies and compare</span>
<span class="sd">    results to avoid cherry-picking.</span>

<span class="sd">    Replacement for optimize_sequence_selection2 and</span>
<span class="sd">    optimize_position_selection functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that modification type is valid.</span>
    <span class="k">assert</span> <span class="n">mod_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;remove_seqs&#39;</span><span class="p">,</span> <span class="s1">&#39;add_seqs&#39;</span><span class="p">,</span> <span class="s1">&#39;remove_columns&#39;</span><span class="p">,</span> <span class="s1">&#39;mixed&#39;</span><span class="p">,</span>
    <span class="s1">&#39;intensive&#39;</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;Invalid value provided with --mod_type option.&quot;&quot;&quot;</span>

    <span class="c1"># Define output directory path.</span>
    <span class="n">outputdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir_path</span><span class="p">,</span>\
            <span class="n">model_name</span> <span class="o">+</span> <span class="s1">&#39;_srch_ali_space_&#39;</span> <span class="o">+</span> <span class="n">timestamp</span><span class="p">)</span>

    <span class="c1"># Make output directory.</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outputdir</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outputdir</span><span class="p">)</span>

    <span class="c1"># Unpack information about current dataset and tree including assessment of</span>
    <span class="c1"># relevant branch supports.</span>

    <span class="c1"># Parse data from model.</span>
    <span class="c1"># Get info about model that is relevant.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parsing input alignment/tree...&#39;</span><span class="p">)</span>
    <span class="n">model_info</span> <span class="o">=</span> <span class="n">ModelInfoFromCSV</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">alignment_file</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">tree_topology_file</span>
    <span class="n">subs_model</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">subs_model</span>
    <span class="n">type_seqs_dict</span> <span class="o">=</span> <span class="n">get_type_seqs_dict</span><span class="p">(</span><span class="n">model_info</span><span class="o">.</span><span class="n">type_seqs_file</span><span class="p">)</span>

    <span class="c1"># Parse tree using ete3.</span>
    <span class="c1"># Note: parentheses and commas get replaced with underscores.</span>
    <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">infh</span><span class="o">.</span><span class="n">read</span><span class="p">():</span>
            <span class="n">quoted_node_names_var</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="n">quoted_node_names_var</span><span class="p">)</span>

    <span class="c1"># Print tree.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input tree:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>

    <span class="c1"># Compile list of sequences represented in the input initial tree.</span>
    <span class="n">names_of_seqs_in_tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t1</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_of_seqs_in_tree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Could not identify names of</span>
<span class="s2">    sequences in the tree.&quot;&quot;&quot;</span>

    <span class="c1"># Get list of essential taxa from file. </span>
    <span class="n">essential_taxa</span> <span class="o">=</span> <span class="n">get_essential_taxa_list</span><span class="p">(</span><span class="n">essential_taxa_file</span><span class="p">)</span>

    <span class="c1"># Copy alignment file to new path, and replace parentheses and commas and</span>
    <span class="c1"># colons with underscores in the sequence descriptions.</span>
    <span class="n">new_ali_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_0.nex&#39;</span><span class="p">)</span>
    <span class="n">problem_characters</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\(|\)|:|,&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span> <span class="k">as</span> <span class="n">infh</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">new_ali_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">o</span><span class="p">:</span>
        <span class="n">ali_obj</span> <span class="o">=</span> <span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">infh</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">ali_obj</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">problem_characters</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">seq</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">AlignIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ali_obj</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s1">&#39;nexus&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">new_ali_path</span><span class="p">)</span>
    <span class="n">alignment</span> <span class="o">=</span> <span class="n">new_ali_path</span> 

    <span class="c1"># Run ML search on model tree to get branch lengths and branch supports.</span>
    <span class="n">ml_tree_path</span> <span class="o">=</span>\
    <span class="n">run_tree_for_branch_lengths_and_supports_for_topology</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span>
                                                          <span class="n">alignment</span><span class="p">,</span>
                                                          <span class="n">subs_model</span><span class="p">,</span>
                                                          <span class="n">outputdir</span><span class="p">)</span>

    <span class="c1"># Define path to tree to use as a constraint tree for further analysis.</span>
    <span class="n">constraint_tree_fp_for_future</span> <span class="o">=</span> <span class="n">get_constraint_tree_fp</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
    <span class="c1">#constraint_tree_fp_for_future = alignment.rsplit(&#39;.&#39;, 1)[0] + &#39;_constraint_tree.newick&#39;</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">constraint_tree_fp_for_future</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Expected to find</span>
<span class="s2">    constraint tree with file path:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">constraint_tree_fp_for_future</span>

    <span class="c1"># Define output path for annotated tree image file.</span>
    <span class="n">annotated_tree_outpath</span> <span class="o">=</span>\
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alignment</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_annotated_result.png&#39;</span><span class="p">)</span>

    <span class="c1"># Extract info about branch lengths and supports from tree, and write</span>
    <span class="c1"># annotated tree image file.</span>
    <span class="n">ml_tree_info_dict</span> <span class="o">=</span> <span class="n">get_ml_tree_info_dict</span><span class="p">(</span><span class="n">ml_tree_path</span><span class="p">,</span>
                                              <span class="n">type_seqs_dict</span><span class="p">,</span>
                                              <span class="n">annotated_tree_outpath</span><span class="p">)</span>


    <span class="c1"># ***Also, need to make it stop iterating if it can&#39;t do any more</span>
    <span class="c1"># modifications.</span>

    <span class="c1"># Parse input sequence file, and construct a list of sequence objects for</span>
    <span class="c1"># potential inclusion in the tree.</span>
    <span class="n">seqs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">file_with_seqs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">file_with_seqs</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">):</span>
            <span class="n">seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;add_seqs&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;No sequences provided for addition to the</span>
<span class="s2">        alignment.&quot;&quot;&quot;</span>

    <span class="c1"># Initiate lists of elements that will be modified.</span>
    <span class="n">positions_attempted_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seqs_attempted_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seqs_attempted_to_add</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Stores true if no modification can be made by the modify_alignment_in_x_way function.</span>

    <span class="c1"># Construct a tuple with all the relevant info from the original tree and</span>
    <span class="c1"># alignment.</span>
    <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                               <span class="c1">#tree, # ???</span>
                               <span class="n">constraint_tree_fp_for_future</span><span class="p">,</span>
                               <span class="n">alignment</span><span class="p">,</span>
                               <span class="n">positions_attempted_to_remove</span><span class="p">,</span>
                               <span class="n">subs_model</span><span class="p">,</span>
                               <span class="n">type_seqs_dict</span><span class="p">,</span>
                               <span class="n">ml_tree_info_dict</span><span class="p">,</span>
                               <span class="n">seqs</span><span class="p">,</span>
                               <span class="n">seqs_attempted_to_remove</span><span class="p">,</span>
                               <span class="n">seqs_attempted_to_add</span><span class="p">,</span>
                               <span class="n">essential_taxa</span><span class="p">,</span>
                               <span class="n">stop</span><span class="p">,</span>
                               <span class="kc">False</span><span class="p">,</span>
                               <span class="kc">None</span><span class="p">)</span>


    <span class="c1"># Handle number of iterations.</span>
    <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">iterations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Specify a very large number by default so that it will run until no</span>
        <span class="c1"># further modifications result in improvements (it should break the</span>
        <span class="c1"># loop before 10000!).</span>
        <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_iterations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">max_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1">## Specify number of iterations that do not find improved support before the</span>
    <span class="c1">## loop gets broken.</span>
    <span class="c1">#max_failed_iterations = 0</span>
    <span class="c1">#if mod_type == &#39;remove_seqs&#39;:</span>
    <span class="c1">#    #max_failed_iterations = len(names_of_seqs_in_tree) * 2</span>
    <span class="c1">#    #max_failed_iterations = len(names_of_seqs_in_tree) / 2</span>
    <span class="c1">#    max_failed_iterations = 2</span>
    <span class="c1">#elif mod_type == &#39;add_seqs&#39;:</span>
    <span class="c1">#    #max_failed_iterations = len(seqs) * 2</span>
    <span class="c1">#    #max_failed_iterations = len(seqs)</span>
    <span class="c1">#    #max_failed_iterations = len(names_of_seqs_in_tree)</span>
    <span class="c1">#    max_failed_iterations = 2</span>
    <span class="c1">#elif mod_type == &#39;remove_columns&#39;:</span>
    <span class="c1">#    original_alignment_length = get_ali_length(alignment)</span>
    <span class="c1">#    max_failed_iterations = original_alignment_length</span>
    <span class="c1">#elif mod_type == &#39;mixed&#39;:</span>
    <span class="c1">#    max_failed_iterations = max_iterations</span>
    <span class="c1">#assert max_failed_iterations &gt; 0</span>

    <span class="c1"># Determine number of positions in the input alignment (length of the</span>
    <span class="c1"># sequences including gaps).</span>
    <span class="n">original_alignment_length</span> <span class="o">=</span> <span class="n">get_ali_length</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>

    <span class="c1"># Specify number of iterations that do not find improved support before the</span>
    <span class="c1"># loop gets broken.</span>
    <span class="n">max_failed_iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_failed_iterations_dict</span> <span class="o">=</span> <span class="p">{</span>
                                 <span class="c1">#&#39;remove_seqs&#39;: len(names_of_seqs_in_tree) / 10,</span>
                                 <span class="s1">&#39;remove_seqs&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_of_seqs_in_tree</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                                 <span class="c1">#&#39;add_seqs&#39;: len(names_of_seqs_in_tree) / 10,</span>
                                 <span class="s1">&#39;add_seqs&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">),</span>
                                 <span class="s1">&#39;remove_columns&#39;</span><span class="p">:</span> <span class="n">original_alignment_length</span><span class="p">,</span>
                                 <span class="s1">&#39;mixed&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="c1"># Not used.</span>
                                 <span class="s1">&#39;intensive&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="c1"># Not used.</span>
                                 <span class="p">}</span>
    <span class="n">max_failed_iterations</span> <span class="o">=</span> <span class="n">max_failed_iterations_dict</span><span class="p">[</span><span class="n">mod_type</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">max_failed_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Define iterable to provide order of different modification types if the</span>
    <span class="c1"># mod_type is set to &#39;mixed&#39;. The mod_type will repeat through this</span>
    <span class="c1"># sequence, switching the value of the mod_type variable when the default</span>
    <span class="c1"># maximum number of failed modifications are reached for each modification</span>
    <span class="c1"># type.</span>
    <span class="n">mod_type_mix_iterable</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([</span>
                                 <span class="s1">&#39;remove_seqs&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;add_seqs&#39;</span>
                                 <span class="p">]</span> <span class="o">*</span> <span class="mi">100000</span><span class="p">)</span>

    <span class="c1"># Define iterable to provide a program of different modification types for</span>
    <span class="c1"># if the mod_type variable is set to &#39;intensive&#39;. The iterative</span>
    <span class="c1"># modifications will stop when the &#39;Stop&#39; value is reached.</span>
    <span class="n">mod_type_intensive_iterable</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([</span><span class="s1">&#39;add_seqs&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;remove_seqs&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;remove_seqs&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;Stop&#39;</span>
                                        <span class="p">])</span>

    <span class="c1"># Set initial mod_type value if mod_type was set to mixed. </span>
    <span class="n">mixed_mod_type</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;mixed&#39;</span><span class="p">:</span>
        <span class="c1"># Set this variable to True so that the mod_type will be switched</span>
        <span class="c1"># instead of exiting after one modification type is completed.</span>
        <span class="n">mixed_mod_type</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Get initial value from iterable.</span>
        <span class="n">mod_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mod_type_mix_iterable</span><span class="p">)</span>

    <span class="c1"># Set initial mod_type value if mod_type was set to intensive.</span>
    <span class="n">intensive_mod_type</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;intensive&#39;</span><span class="p">:</span>
        <span class="n">intensive_mod_type</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mod_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mod_type_intensive_iterable</span><span class="p">)</span>

    <span class="c1"># Initiate variable for storing the number of the best alignment.</span>
    <span class="c1">#best_alignment_num = &#39;the original input alignment&#39;</span>
    <span class="n">best_alignment_num</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>

    <span class="c1"># Initiate a list of alignment/iteration numbers corresponding to output</span>
    <span class="c1"># files to keep for future reference.</span>
    <span class="n">alignment_nums_to_keep</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iteratively modify the alignment and assess support in the tree.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Iteratively modifying and assessing alignments/trees...&#39;</span><span class="p">)</span>
    <span class="n">failed_iterations_tally</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_iterations</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Iteration &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="c1"># Modify alignment (and tree if necessary). There are various types of</span>
        <span class="c1"># modifications that could be done: 1) Remove a sequence, 2) Add a</span>
        <span class="c1"># sequence, 3) Remove positions/columns from the alignment, 4)</span>
        <span class="c1"># Re-align, 5) Reset the substitution model.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Modifying alignment (and tree) in X way, and assessing measures of branch support in new tree...&#39;</span><span class="p">)</span> 
        <span class="n">new_ali_tree_tuple</span> <span class="o">=</span>\
        <span class="n">modify_alignment_in_x_way</span><span class="p">(</span><span class="n">previous_ali_tree_tuple</span><span class="p">,</span> <span class="n">mod_type</span><span class="p">)</span>

        <span class="c1"># Report name of modified clade.</span>
        <span class="n">modified_clade_name</span> <span class="o">=</span> <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">modified_clade_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Modified clade with name: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">modified_clade_name</span><span class="p">)</span>

        <span class="c1"># Stop if no modification could be made (the stop variable is set to</span>
        <span class="c1"># True).</span>
        <span class="k">if</span> <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">11</span><span class="p">]:</span>
            <span class="c1"># Stop iterations.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Stopping iterations because no further modification could be made.&#39;</span><span class="p">)</span>
            <span class="c1">#break</span>

            <span class="c1"># Or, reset the list of items to be modified and continue instead of</span>
            <span class="c1"># break.</span>

            <span class="c1"># Reset lists of elements that have been modified already.</span>
            <span class="n">positions_attempted_to_remove</span> <span class="o">=</span> <span class="p">[]</span> 
            <span class="n">seqs_attempted_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">seqs_attempted_to_add</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Apply changes to previous alignment/tree info tuple.</span>
            <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                       <span class="n">positions_attempted_to_remove</span><span class="p">,</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
                                       <span class="n">seqs_attempted_to_remove</span><span class="p">,</span>
                                       <span class="n">seqs_attempted_to_add</span><span class="p">,</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
                                       <span class="kc">False</span><span class="p">,</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span>
                                       <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
                                       <span class="p">)</span>

            <span class="c1"># If in the &#39;intensive&#39; mode, then switch to the next stage of</span>
            <span class="c1"># analysis.</span>
            <span class="k">if</span> <span class="n">intensive_mod_type</span><span class="p">:</span>
                <span class="c1"># Add iteration number for current best iteration to the list</span>
                <span class="c1"># of those whos corresponding output files should be kept for</span>
                <span class="c1"># future reference.</span>
                <span class="n">alignment_nums_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_alignment_num</span><span class="p">)</span>

                <span class="c1"># Change the mod_type to the next stage.</span>
                <span class="n">mod_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mod_type_intensive_iterable</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s2">Switching to modification type: </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">mod_type</span><span class="p">)</span>

                <span class="c1"># If the mod_type is &#39;remove_seqs&#39; then it should just keep</span>
                <span class="c1"># going until there are no more sequences to try removing.</span>

                <span class="c1"># If the mod_type is not &#39;Stop&#39;, then stop the analysis at the</span>
                <span class="c1"># current best tree.</span>
                <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="s1">&#39;Stop&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s2">Reached the end of the intensive dataset</span>
<span class="s2">                    searching strategy.&quot;&quot;&quot;</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="c1"># Go to the next iteration so that nothing else is done before</span>
            <span class="c1"># trying another modification.</span>
            <span class="k">continue</span>

        <span class="c1"># Get measures of support for both trees (lowest value among abayes and</span>
        <span class="c1"># alrt supports for all branches for specific clades of interest as</span>
        <span class="c1"># well as branches that are internal to those branches).</span>
        <span class="c1"># Contents of tuple returned by the get_y_measure_of_support function</span>
        <span class="c1"># (X_tree_measure variables):</span>
        <span class="c1"># 1. lowest_support_value,</span>
        <span class="c1"># 2. average_support_value,</span>
        <span class="c1"># 3. minimum_stem_branch_ratio,</span>
        <span class="c1"># 4. average_stem_branch_ratio,</span>
        <span class="c1"># 5. min_dbranch_avgleaf_ratio,</span>
        <span class="c1"># 6. avg_dbranch_avgleaf_ratio,</span>
        <span class="c1"># 7. modified_clade_stem_branch_ratio</span>
        <span class="n">prev_tree_measure</span> <span class="o">=</span> <span class="n">get_y_measure_of_support</span><span class="p">(</span><span class="n">previous_ali_tree_tuple</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span> <span class="n">modified_clade_name</span><span class="p">)</span>
        <span class="n">new_tree_measure</span> <span class="o">=</span> <span class="n">get_y_measure_of_support</span><span class="p">(</span><span class="n">new_ali_tree_tuple</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Decide whether to use new alignment/tree based on various criteria.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Comparing measures of branch support in new tree to those of the previous tree...&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Old tree support measure: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">prev_tree_measure</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">New tree support measure: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_tree_measure</span><span class="p">))</span>
        <span class="c1"># The measures of support are support values (such as probabilities</span>
        <span class="c1"># from alrt branch tests), so better trees have higher values.</span>

        <span class="c1"># Apply criteria based on comparing values between trees to determine</span>
        <span class="c1"># whether the new tree is better.</span>
        <span class="n">new_tree_is_better</span> <span class="o">=</span> <span class="n">new_tree_better</span><span class="p">(</span><span class="n">prev_tree_measure</span><span class="p">,</span>
                                             <span class="n">new_tree_measure</span><span class="p">,</span>
                                             <span class="n">mod_type</span><span class="p">,</span> 
                                             <span class="n">intensive_mod_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_tree_is_better</span><span class="p">:</span>
            <span class="c1"># Set best tree to this tree.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">New tree is better.&#39;</span><span class="p">)</span>
            <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="n">new_ali_tree_tuple</span>
            <span class="n">best_alignment_num</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If a sequence was added, then make sure that it is not essential</span>
            <span class="c1"># before discarding the new alignment.</span>
            <span class="n">new_seq_is_essential</span> <span class="o">=</span> <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_seq_is_essential</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">New tree has an additional essential sequence in a clade of interest.&#39;</span><span class="p">)</span>

                <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="n">new_ali_tree_tuple</span>

                <span class="c1"># Reset variable that stores True if the added sequence is</span>
                <span class="c1"># essential.</span>
                <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># Set best tree to this tree.</span>
                <span class="n">best_alignment_num</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Old tree is better.&#39;</span><span class="p">)</span>
                <span class="n">failed_iterations_tally</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Just update the lists of modifications that have already been</span>
                <span class="c1"># attempted.</span>
                <span class="n">previous_ali_tree_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                           <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
                                           <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
                                           <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
                                           <span class="n">new_ali_tree_tuple</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span>
                                           <span class="n">previous_ali_tree_tuple</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
                                           <span class="p">)</span>


        <span class="c1"># Break the loop if the max number of failed iterations have occured.</span>
        <span class="n">max_failed_iterations</span> <span class="o">=</span> <span class="n">max_failed_iterations_dict</span><span class="p">[</span><span class="n">mod_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">failed_iterations_tally</span> <span class="o">&gt;=</span> <span class="n">max_failed_iterations</span><span class="p">:</span>
            <span class="c1"># Don&#39;t stop if the intensive option was selected. </span>
            <span class="k">if</span> <span class="n">intensive_mod_type</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Switch to a different modification type if the mod_type was</span>
            <span class="c1"># mixed.</span>
            <span class="k">elif</span> <span class="n">mixed_mod_type</span><span class="p">:</span>
                <span class="c1"># Define the new modification type.</span>
                <span class="n">mod_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mod_type_mix_iterable</span><span class="p">)</span>
                <span class="c1"># Reset tally of failed iterations.</span>
                <span class="n">failed_iterations_tally</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Otherwise stop further modification of the alignment.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s2">Reached maximum number of failed iterations (modifications that</span>
<span class="s2">                do not result in a tree with better support).&quot;&quot;&quot;</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="c1"># Report which alignment is the best.</span>
    <span class="k">if</span> <span class="n">best_alignment_num</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Best alignment is the original input alignment&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Best alignment is alignment &#39;</span> <span class="o">+</span> <span class="n">best_alignment_num</span><span class="p">)</span>

    <span class="c1"># Remove all output files, except those for the best alignment.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_all_output</span><span class="p">:</span>
        <span class="c1"># Get list of &quot;names&quot; that should be in files to keep.</span>
        <span class="n">alignment_to_keep_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">alignment_nums_to_keep</span> <span class="o">+</span> <span class="p">[</span><span class="n">best_alignment_num</span><span class="p">]:</span>
            <span class="n">alignment_to_keep_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>\
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">new_ali_path</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="c1"># Remove all output files and directories that do not have one of the</span>
        <span class="c1"># listed names.</span>
        <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">new_ali_path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span><span class="p">):</span>
            <span class="n">output_matches_an_alignment_to_keep</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alignment_to_keep_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
                    <span class="n">output_matches_an_alignment_to_keep</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">output_matches_an_alignment_to_keep</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>


    <span class="c1"># Return path to main/final output file or directory.</span>
    <span class="k">return</span> <span class="n">outputdir</span></div>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">amoebae 0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Lael D. Barlow.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>